var ci = (h) => {
  throw TypeError(h);
};
var Ss = (h, t, e) => t.has(h) || ci("Cannot " + e);
var ot = (h, t, e) => (Ss(h, t, "read from private field"), e ? e.call(h) : t.get(h)), Wt = (h, t, e) => t.has(h) ? ci("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(h) : t.set(h, e), Dt = (h, t, e, s) => (Ss(h, t, "write to private field"), s ? s.call(h, e) : t.set(h, e), e), Xt = (h, t, e) => (Ss(h, t, "access private method"), e);
var di = (h, t, e, s) => ({
  set _(i) {
    Dt(h, t, i, e);
  },
  get _() {
    return ot(h, t, s);
  }
});
var Cn = {
  /***/
  34: (
    /***/
    ((h, t, e) => {
      var s = e(4901);
      h.exports = function(i) {
        return typeof i == "object" ? i !== null : s(i);
      };
    })
  ),
  /***/
  81: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(9306), n = e(8551), r = e(6823), a = e(851), o = TypeError;
      h.exports = function(l, c) {
        var d = arguments.length < 2 ? a(l) : c;
        if (i(d)) return n(s(d, l));
        throw new o(r(l) + " is not iterable");
      };
    })
  ),
  /***/
  116: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(2652), r = e(9306), a = e(8551), o = e(1767), l = e(9539), c = e(4549), d = c("find", TypeError);
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        find: function(f) {
          a(this);
          try {
            r(f);
          } catch (v) {
            l(this, "throw", v);
          }
          if (d) return i(d, this, f);
          var g = o(this), p = 0;
          return n(g, function(v, m) {
            if (f(v, p++)) return m(v);
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).result;
        }
      });
    })
  ),
  /***/
  283: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(9039), n = e(4901), r = e(9297), a = e(3724), o = e(350).CONFIGURABLE, l = e(3706), c = e(1181), d = c.enforce, u = c.get, f = String, g = Object.defineProperty, p = s("".slice), v = s("".replace), m = s([].join), b = a && !i(function() {
        return g(function() {
        }, "length", { value: 8 }).length !== 8;
      }), y = String(String).split("String"), E = h.exports = function(A, w, S) {
        p(f(w), 0, 7) === "Symbol(" && (w = "[" + v(f(w), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), S && S.getter && (w = "get " + w), S && S.setter && (w = "set " + w), (!r(A, "name") || o && A.name !== w) && (a ? g(A, "name", { value: w, configurable: !0 }) : A.name = w), b && S && r(S, "arity") && A.length !== S.arity && g(A, "length", { value: S.arity });
        try {
          S && r(S, "constructor") && S.constructor ? a && g(A, "prototype", { writable: !1 }) : A.prototype && (A.prototype = void 0);
        } catch {
        }
        var x = d(A);
        return r(x, "source") || (x.source = m(y, typeof w == "string" ? w : "")), A;
      };
      Function.prototype.toString = E(function() {
        return n(this) && u(this).source || l(this);
      }, "toString");
    })
  ),
  /***/
  350: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(9297), n = Function.prototype, r = s && Object.getOwnPropertyDescriptor, a = i(n, "name"), o = a && (function() {
      }).name === "something", l = a && (!s || s && r(n, "name").configurable);
      h.exports = {
        EXISTS: a,
        PROPER: o,
        CONFIGURABLE: l
      };
    })
  ),
  /***/
  397: (
    /***/
    ((h, t, e) => {
      var s = e(7751);
      h.exports = s("document", "documentElement");
    })
  ),
  /***/
  421: (
    /***/
    ((h) => {
      h.exports = {};
    })
  ),
  /***/
  456: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(9504), r = e(4154), a = e(5169), o = n(1.1.toString), l = i.Uint8Array, c = !l || !l.prototype.toHex || !(function() {
        try {
          var d = new l([255, 255, 255, 255, 255, 255, 255, 255]);
          return d.toHex() === "ffffffffffffffff";
        } catch {
          return !1;
        }
      })();
      l && s({ target: "Uint8Array", proto: !0, forced: c }, {
        toHex: function() {
          r(this), a(this.buffer);
          for (var u = "", f = 0, g = this.length; f < g; f++) {
            var p = o(this[f], 16);
            u += p.length === 1 ? "0" + p : p;
          }
          return u;
        }
      });
    })
  ),
  /***/
  507: (
    /***/
    ((h, t, e) => {
      var s = e(9565);
      h.exports = function(i, n, r) {
        for (var a = r ? i : i.iterator, o = i.next, l, c; !(l = s(o, a)).done; )
          if (c = n(l.value), c !== void 0) return c;
      };
    })
  ),
  /***/
  531: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(9306), r = e(8551), a = e(1767), o = e(8646), l = e(9462), c = e(9539), d = e(6395), u = e(684), f = e(4549), g = !d && !u("flatMap", function() {
      }), p = !d && !g && f("flatMap", TypeError), v = d || g || p, m = l(function() {
        for (var b = this.iterator, y = this.mapper, E, A; ; ) {
          if (A = this.inner) try {
            if (E = r(i(A.next, A.iterator)), !E.done) return E.value;
            this.inner = null;
          } catch (w) {
            c(b, "throw", w);
          }
          if (E = r(i(this.next, b)), this.done = !!E.done) return;
          try {
            this.inner = o(y(E.value, this.counter++), !1);
          } catch (w) {
            c(b, "throw", w);
          }
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: v }, {
        flatMap: function(y) {
          r(this);
          try {
            n(y);
          } catch (E) {
            c(this, "throw", E);
          }
          return p ? i(p, this, y) : new m(a(this), {
            mapper: y,
            inner: null
          });
        }
      });
    })
  ),
  /***/
  616: (
    /***/
    ((h, t, e) => {
      var s = e(9039);
      h.exports = !s(function() {
        var i = (function() {
        }).bind();
        return typeof i != "function" || i.hasOwnProperty("prototype");
      });
    })
  ),
  /***/
  655: (
    /***/
    ((h, t, e) => {
      var s = e(6955), i = String;
      h.exports = function(n) {
        if (s(n) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return i(n);
      };
    })
  ),
  /***/
  679: (
    /***/
    ((h, t, e) => {
      var s = e(1625), i = TypeError;
      h.exports = function(n, r) {
        if (s(r, n)) return n;
        throw new i("Incorrect invocation");
      };
    })
  ),
  /***/
  684: (
    /***/
    ((h) => {
      h.exports = function(t, e) {
        var s = typeof Iterator == "function" && Iterator.prototype[t];
        if (s) try {
          s.call({ next: null }, e).next();
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  741: (
    /***/
    ((h) => {
      var t = Math.ceil, e = Math.floor;
      h.exports = Math.trunc || function(i) {
        var n = +i;
        return (n > 0 ? e : t)(n);
      };
    })
  ),
  /***/
  757: (
    /***/
    ((h, t, e) => {
      var s = e(7751), i = e(4901), n = e(1625), r = e(7040), a = Object;
      h.exports = r ? function(o) {
        return typeof o == "symbol";
      } : function(o) {
        var l = s("Symbol");
        return i(l) && n(l.prototype, a(o));
      };
    })
  ),
  /***/
  851: (
    /***/
    ((h, t, e) => {
      var s = e(6955), i = e(5966), n = e(4117), r = e(6269), a = e(8227), o = a("iterator");
      h.exports = function(l) {
        if (!n(l)) return i(l, o) || i(l, "@@iterator") || r[s(l)];
      };
    })
  ),
  /***/
  944: (
    /***/
    ((h) => {
      var t = TypeError;
      h.exports = function(e) {
        var s = e && e.alphabet;
        if (s === void 0 || s === "base64" || s === "base64url") return s || "base64";
        throw new t("Incorrect `alphabet` option");
      };
    })
  ),
  /***/
  1072: (
    /***/
    ((h, t, e) => {
      var s = e(1828), i = e(8727);
      h.exports = Object.keys || function(r) {
        return s(r, i);
      };
    })
  ),
  /***/
  1103: (
    /***/
    ((h) => {
      h.exports = function(t) {
        try {
          return { error: !1, value: t() };
        } catch (e) {
          return { error: !0, value: e };
        }
      };
    })
  ),
  /***/
  1108: (
    /***/
    ((h, t, e) => {
      var s = e(6955);
      h.exports = function(i) {
        var n = s(i);
        return n === "BigInt64Array" || n === "BigUint64Array";
      };
    })
  ),
  /***/
  1148: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(2652), r = e(9306), a = e(8551), o = e(1767), l = e(9539), c = e(4549), d = c("every", TypeError);
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        every: function(f) {
          a(this);
          try {
            r(f);
          } catch (v) {
            l(this, "throw", v);
          }
          if (d) return i(d, this, f);
          var g = o(this), p = 0;
          return !n(g, function(v, m) {
            if (!f(v, p++)) return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    })
  ),
  /***/
  1181: (
    /***/
    ((h, t, e) => {
      var s = e(8622), i = e(4576), n = e(34), r = e(6699), a = e(9297), o = e(7629), l = e(6119), c = e(421), d = "Object already initialized", u = i.TypeError, f = i.WeakMap, g, p, v, m = function(A) {
        return v(A) ? p(A) : g(A, {});
      }, b = function(A) {
        return function(w) {
          var S;
          if (!n(w) || (S = p(w)).type !== A)
            throw new u("Incompatible receiver, " + A + " required");
          return S;
        };
      };
      if (s || o.state) {
        var y = o.state || (o.state = new f());
        y.get = y.get, y.has = y.has, y.set = y.set, g = function(A, w) {
          if (y.has(A)) throw new u(d);
          return w.facade = A, y.set(A, w), w;
        }, p = function(A) {
          return y.get(A) || {};
        }, v = function(A) {
          return y.has(A);
        };
      } else {
        var E = l("state");
        c[E] = !0, g = function(A, w) {
          if (a(A, E)) throw new u(d);
          return w.facade = A, r(A, E, w), w;
        }, p = function(A) {
          return a(A, E) ? A[E] : {};
        }, v = function(A) {
          return a(A, E);
        };
      }
      h.exports = {
        set: g,
        get: p,
        has: v,
        enforce: m,
        getterFor: b
      };
    })
  ),
  /***/
  1291: (
    /***/
    ((h, t, e) => {
      var s = e(741);
      h.exports = function(i) {
        var n = +i;
        return n !== n || n === 0 ? 0 : s(n);
      };
    })
  ),
  /***/
  1385: (
    /***/
    ((h, t, e) => {
      var s = e(9539);
      h.exports = function(i, n, r) {
        for (var a = i.length - 1; a >= 0; a--)
          if (i[a] !== void 0)
            try {
              r = s(i[a].iterator, n, r);
            } catch (o) {
              n = "throw", r = o;
            }
        if (n === "throw") throw r;
        return r;
      };
    })
  ),
  /***/
  1548: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(9039), n = e(9519), r = e(4215), a = s.structuredClone;
      h.exports = !!a && !i(function() {
        if (r === "DENO" && n > 92 || r === "NODE" && n > 94 || r === "BROWSER" && n > 97) return !1;
        var o = new ArrayBuffer(8), l = a(o, { transfer: [o] });
        return o.byteLength !== 0 || l.byteLength !== 8;
      });
    })
  ),
  /***/
  1549: (
    /***/
    ((h, t, e) => {
      e(6632);
    })
  ),
  /***/
  1625: (
    /***/
    ((h, t, e) => {
      var s = e(9504);
      h.exports = s({}.isPrototypeOf);
    })
  ),
  /***/
  1689: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(8745), r = e(7680), a = e(6043), o = e(9306), l = e(1103), c = i.Promise, d = !1, u = !c || !c.try || l(function() {
        c.try(function(f) {
          d = f === 8;
        }, 8);
      }).error || !d;
      s({ target: "Promise", stat: !0, forced: u }, {
        try: function(f) {
          var g = arguments.length > 1 ? r(arguments, 1) : [], p = a.f(this), v = l(function() {
            return n(o(f), void 0, g);
          });
          return (v.error ? p.reject : p.resolve)(v.value), p.promise;
        }
      });
    })
  ),
  /***/
  1698: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4204), n = e(9835), r = e(4916), a = !r("union") || !n("union");
      s({ target: "Set", proto: !0, real: !0, forced: a }, {
        union: i
      });
    })
  ),
  /***/
  1701: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(9306), r = e(8551), a = e(1767), o = e(9462), l = e(6319), c = e(9539), d = e(684), u = e(4549), f = e(6395), g = !f && !d("map", function() {
      }), p = !f && !g && u("map", TypeError), v = f || g || p, m = o(function() {
        var b = this.iterator, y = r(i(this.next, b)), E = this.done = !!y.done;
        if (!E) return l(b, this.mapper, [y.value, this.counter++], !0);
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: v }, {
        map: function(y) {
          r(this);
          try {
            n(y);
          } catch (E) {
            c(this, "throw", E);
          }
          return p ? i(p, this, y) : new m(a(this), {
            mapper: y
          });
        }
      });
    })
  ),
  /***/
  1767: (
    /***/
    ((h) => {
      h.exports = function(t) {
        return {
          iterator: t,
          next: t.next,
          done: !1
        };
      };
    })
  ),
  /***/
  1828: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(9297), n = e(5397), r = e(9617).indexOf, a = e(421), o = s([].push);
      h.exports = function(l, c) {
        var d = n(l), u = 0, f = [], g;
        for (g in d) !i(a, g) && i(d, g) && o(f, g);
        for (; c.length > u; ) i(d, g = c[u++]) && (~r(f, g) || o(f, g));
        return f;
      };
    })
  ),
  /***/
  2106: (
    /***/
    ((h, t, e) => {
      var s = e(283), i = e(4913);
      h.exports = function(n, r, a) {
        return a.get && s(a.get, r, { getter: !0 }), a.set && s(a.set, r, { setter: !0 }), i.f(n, r, a);
      };
    })
  ),
  /***/
  2140: (
    /***/
    ((h, t, e) => {
      var s = e(8227), i = s("toStringTag"), n = {};
      n[i] = "z", h.exports = String(n) === "[object z]";
    })
  ),
  /***/
  2195: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = s({}.toString), n = s("".slice);
      h.exports = function(r) {
        return n(i(r), 8, -1);
      };
    })
  ),
  /***/
  2211: (
    /***/
    ((h, t, e) => {
      var s = e(9039);
      h.exports = !s(function() {
        function i() {
        }
        return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
      });
    })
  ),
  /***/
  2303: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(9504), n = s.Uint8Array, r = s.SyntaxError, a = s.parseInt, o = Math.min, l = /[^\da-f]/i, c = i(l.exec), d = i("".slice);
      h.exports = function(u, f) {
        var g = u.length;
        if (g % 2 !== 0) throw new r("String should be an even number of characters");
        for (var p = f ? o(f.length, g / 2) : g / 2, v = f || new n(p), m = 0, b = 0; b < p; ) {
          var y = d(u, m, m += 2);
          if (c(l, y)) throw new r("String should only contain hex characters");
          v[b++] = a(y, 16);
        }
        return { bytes: v, read: m };
      };
    })
  ),
  /***/
  2360: (
    /***/
    ((h, t, e) => {
      var s = e(8551), i = e(6801), n = e(8727), r = e(421), a = e(397), o = e(4055), l = e(6119), c = ">", d = "<", u = "prototype", f = "script", g = l("IE_PROTO"), p = function() {
      }, v = function(A) {
        return d + f + c + A + d + "/" + f + c;
      }, m = function(A) {
        A.write(v("")), A.close();
        var w = A.parentWindow.Object;
        return A = null, w;
      }, b = function() {
        var A = o("iframe"), w = "java" + f + ":", S;
        return A.style.display = "none", a.appendChild(A), A.src = String(w), S = A.contentWindow.document, S.open(), S.write(v("document.F=Object")), S.close(), S.F;
      }, y, E = function() {
        try {
          y = new ActiveXObject("htmlfile");
        } catch {
        }
        E = typeof document < "u" ? document.domain && y ? m(y) : b() : m(y);
        for (var A = n.length; A--; ) delete E[u][n[A]];
        return E();
      };
      r[g] = !0, h.exports = Object.create || function(w, S) {
        var x;
        return w !== null ? (p[u] = s(w), x = new p(), p[u] = null, x[g] = w) : x = E(), S === void 0 ? x : i.f(x, S);
      };
    })
  ),
  /***/
  2475: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(8527), n = e(4916), r = !n("isSupersetOf", function(a) {
        return !a;
      });
      s({ target: "Set", proto: !0, real: !0, forced: r }, {
        isSupersetOf: i
      });
    })
  ),
  /***/
  2489: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(9306), r = e(8551), a = e(1767), o = e(9462), l = e(6319), c = e(6395), d = e(9539), u = e(684), f = e(4549), g = !c && !u("filter", function() {
      }), p = !c && !g && f("filter", TypeError), v = c || g || p, m = o(function() {
        for (var b = this.iterator, y = this.predicate, E = this.next, A, w, S; ; ) {
          if (A = r(i(E, b)), w = this.done = !!A.done, w) return;
          if (S = A.value, l(b, y, [S, this.counter++], !0)) return S;
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: v }, {
        filter: function(y) {
          r(this);
          try {
            n(y);
          } catch (E) {
            d(this, "throw", E);
          }
          return p ? i(p, this, y) : new m(a(this), {
            predicate: y
          });
        }
      });
    })
  ),
  /***/
  2529: (
    /***/
    ((h) => {
      h.exports = function(t, e) {
        return { value: t, done: e };
      };
    })
  ),
  /***/
  2603: (
    /***/
    ((h, t, e) => {
      var s = e(655);
      h.exports = function(i, n) {
        return i === void 0 ? arguments.length < 2 ? "" : n : s(i);
      };
    })
  ),
  /***/
  2652: (
    /***/
    ((h, t, e) => {
      var s = e(6080), i = e(9565), n = e(8551), r = e(6823), a = e(4209), o = e(6198), l = e(1625), c = e(81), d = e(851), u = e(9539), f = TypeError, g = function(v, m) {
        this.stopped = v, this.result = m;
      }, p = g.prototype;
      h.exports = function(v, m, b) {
        var y = b && b.that, E = !!(b && b.AS_ENTRIES), A = !!(b && b.IS_RECORD), w = !!(b && b.IS_ITERATOR), S = !!(b && b.INTERRUPTED), x = s(m, y), T, C, P, O, D, k, H, M = function(N) {
          return T && u(T, "normal"), new g(!0, N);
        }, I = function(N) {
          return E ? (n(N), S ? x(N[0], N[1], M) : x(N[0], N[1])) : S ? x(N, M) : x(N);
        };
        if (A)
          T = v.iterator;
        else if (w)
          T = v;
        else {
          if (C = d(v), !C) throw new f(r(v) + " is not iterable");
          if (a(C)) {
            for (P = 0, O = o(v); O > P; P++)
              if (D = I(v[P]), D && l(p, D)) return D;
            return new g(!1);
          }
          T = c(v, C);
        }
        for (k = A ? v.next : T.next; !(H = i(k, T)).done; ) {
          try {
            D = I(H.value);
          } catch (N) {
            u(T, "throw", N);
          }
          if (typeof D == "object" && D && l(p, D)) return D;
        }
        return new g(!1);
      };
    })
  ),
  /***/
  2777: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(34), n = e(757), r = e(5966), a = e(4270), o = e(8227), l = TypeError, c = o("toPrimitive");
      h.exports = function(d, u) {
        if (!i(d) || n(d)) return d;
        var f = r(d, c), g;
        if (f) {
          if (u === void 0 && (u = "default"), g = s(f, d, u), !i(g) || n(g)) return g;
          throw new l("Can't convert object to primitive value");
        }
        return u === void 0 && (u = "number"), a(d, u);
      };
    })
  ),
  /***/
  2787: (
    /***/
    ((h, t, e) => {
      var s = e(9297), i = e(4901), n = e(8981), r = e(6119), a = e(2211), o = r("IE_PROTO"), l = Object, c = l.prototype;
      h.exports = a ? l.getPrototypeOf : function(d) {
        var u = n(d);
        if (s(u, o)) return u[o];
        var f = u.constructor;
        return i(f) && u instanceof f ? f.prototype : u instanceof l ? c : null;
      };
    })
  ),
  /***/
  2796: (
    /***/
    ((h, t, e) => {
      var s = e(9039), i = e(4901), n = /#|\.prototype\./, r = function(d, u) {
        var f = o[a(d)];
        return f === c ? !0 : f === l ? !1 : i(u) ? s(u) : !!u;
      }, a = r.normalize = function(d) {
        return String(d).replace(n, ".").toLowerCase();
      }, o = r.data = {}, l = r.NATIVE = "N", c = r.POLYFILL = "P";
      h.exports = r;
    })
  ),
  /***/
  2804: (
    /***/
    ((h) => {
      var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = t + "+/", s = t + "-_", i = function(n) {
        for (var r = {}, a = 0; a < 64; a++) r[n.charAt(a)] = a;
        return r;
      };
      h.exports = {
        i2c: e,
        c2i: i(e),
        i2cUrl: s,
        c2iUrl: i(s)
      };
    })
  ),
  /***/
  2812: (
    /***/
    ((h) => {
      var t = TypeError;
      h.exports = function(e, s) {
        if (e < s) throw new t("Not enough arguments");
        return e;
      };
    })
  ),
  /***/
  2839: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = s.navigator, n = i && i.userAgent;
      h.exports = n ? String(n) : "";
    })
  ),
  /***/
  2967: (
    /***/
    ((h, t, e) => {
      var s = e(6706), i = e(34), n = e(7750), r = e(3506);
      h.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
        var a = !1, o = {}, l;
        try {
          l = s(Object.prototype, "__proto__", "set"), l(o, []), a = o instanceof Array;
        } catch {
        }
        return function(d, u) {
          return n(d), r(u), i(d) && (a ? l(d, u) : d.__proto__ = u), d;
        };
      })() : void 0);
    })
  ),
  /***/
  3068: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9504), n = e(2652), r = RangeError, a = TypeError, o = 1 / 0, l = NaN, c = Math.abs, d = Math.pow, u = i([].push), f = d(2, 1023), g = d(2, 53) - 1, p = Number.MAX_VALUE, v = d(2, 971), m = {}, b = {}, y = {}, E = {}, A = {}, w = function(S, x) {
        var T = S + x, C = x - (T - S);
        return { hi: T, lo: C };
      };
      s({ target: "Math", stat: !0 }, {
        // eslint-disable-next-line max-statements -- ok
        sumPrecise: function(x) {
          var T = [], C = 0, P = E;
          switch (n(x, function(L) {
            if (++C >= g) throw new r("Maximum allowed index exceeded");
            if (typeof L != "number") throw new a("Value is not a number");
            P !== m && (L !== L ? P = m : L === o ? P = P === b ? m : y : L === -o ? P = P === y ? m : b : (L !== 0 || 1 / L === o) && (P === E || P === A) && (P = A, u(T, L)));
          }), P) {
            case m:
              return l;
            case b:
              return -o;
            case y:
              return o;
            case E:
              return -0;
          }
          for (var O = [], D = 0, k, H, M, I, N, X, tt = 0; tt < T.length; tt++) {
            k = T[tt];
            for (var ut = 0, q = 0; q < O.length; q++) {
              if (H = O[q], c(k) < c(H) && (X = k, k = H, H = X), M = w(k, H), I = M.hi, N = M.lo, c(I) === o) {
                var Q = I === o ? 1 : -1;
                D += Q, k = k - Q * f - Q * f, c(k) < c(H) && (X = k, k = H, H = X), M = w(k, H), I = M.hi, N = M.lo;
              }
              N !== 0 && (O[ut++] = N), k = I;
            }
            O.length = ut, k !== 0 && u(O, k);
          }
          var rt = O.length - 1;
          if (I = 0, N = 0, D !== 0) {
            var Et = rt >= 0 ? O[rt] : 0;
            if (rt--, c(D) > 1 || D > 0 && Et > 0 || D < 0 && Et < 0)
              return D > 0 ? o : -o;
            if (M = w(D * f, Et / 2), I = M.hi, N = M.lo, N *= 2, c(2 * I) === o)
              return I > 0 ? I === f && N === -(v / 2) && rt >= 0 && O[rt] < 0 ? p : o : I === -f && N === v / 2 && rt >= 0 && O[rt] > 0 ? -p : -o;
            N !== 0 && (O[++rt] = N, N = 0), I *= 2;
          }
          for (; rt >= 0 && (M = w(I, O[rt--]), I = M.hi, N = M.lo, N === 0); )
            ;
          return rt >= 0 && (N < 0 && O[rt] < 0 || N > 0 && O[rt] > 0) && (H = N * 2, k = I + H, H === k - I && (I = k)), I;
        }
      });
    })
  ),
  /***/
  3167: (
    /***/
    ((h, t, e) => {
      var s = e(4901), i = e(34), n = e(2967);
      h.exports = function(r, a, o) {
        var l, c;
        return (
          // it can work only with native `setPrototypeOf`
          n && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          s(l = a.constructor) && l !== o && i(c = l.prototype) && c !== o.prototype && n(r, c), r
        );
      };
    })
  ),
  /***/
  3238: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(7811), n = e(7394), r = s.DataView;
      h.exports = function(a) {
        if (!i || n(a) !== 0) return !1;
        try {
          return new r(a), !1;
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  3392: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = 0, n = Math.random(), r = s(1.1.toString);
      h.exports = function(a) {
        return "Symbol(" + (a === void 0 ? "" : a) + ")_" + r(++i + n, 36);
      };
    })
  ),
  /***/
  3440: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402), n = e(9286), r = e(5170), a = e(3789), o = e(8469), l = e(507), c = i.has, d = i.remove;
      h.exports = function(f) {
        var g = s(this), p = a(f), v = n(g);
        return r(g) <= p.size ? o(g, function(m) {
          p.includes(m) && d(v, m);
        }) : l(p.getIterator(), function(m) {
          c(v, m) && d(v, m);
        }), v;
      };
    })
  ),
  /***/
  3463: (
    /***/
    ((h) => {
      var t = TypeError;
      h.exports = function(e) {
        if (typeof e == "string") return e;
        throw new t("Argument is not a string");
      };
    })
  ),
  /***/
  3506: (
    /***/
    ((h, t, e) => {
      var s = e(3925), i = String, n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n("Can't set " + i(r) + " as a prototype");
      };
    })
  ),
  /***/
  3579: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(2652), r = e(9306), a = e(8551), o = e(1767), l = e(9539), c = e(4549), d = c("some", TypeError);
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        some: function(f) {
          a(this);
          try {
            r(f);
          } catch (v) {
            l(this, "throw", v);
          }
          if (d) return i(d, this, f);
          var g = o(this), p = 0;
          return n(g, function(v, m) {
            if (f(v, p++)) return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    })
  ),
  /***/
  3650: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402), n = e(9286), r = e(3789), a = e(507), o = i.add, l = i.has, c = i.remove;
      h.exports = function(u) {
        var f = s(this), g = r(u).getIterator(), p = n(f);
        return a(g, function(v) {
          l(f, v) ? c(p, v) : o(p, v);
        }), p;
      };
    })
  ),
  /***/
  3706: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(4901), n = e(7629), r = s(Function.toString);
      i(n.inspectSource) || (n.inspectSource = function(a) {
        return r(a);
      }), h.exports = n.inspectSource;
    })
  ),
  /***/
  3717: (
    /***/
    ((h, t) => {
      t.f = Object.getOwnPropertySymbols;
    })
  ),
  /***/
  3724: (
    /***/
    ((h, t, e) => {
      var s = e(9039);
      h.exports = !s(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    })
  ),
  /***/
  3789: (
    /***/
    ((h, t, e) => {
      var s = e(9306), i = e(8551), n = e(9565), r = e(1291), a = e(1767), o = "Invalid size", l = RangeError, c = TypeError, d = Math.max, u = function(f, g) {
        this.set = f, this.size = d(g, 0), this.has = s(f.has), this.keys = s(f.keys);
      };
      u.prototype = {
        getIterator: function() {
          return a(i(n(this.keys, this.set)));
        },
        includes: function(f) {
          return n(this.has, this.set, f);
        }
      }, h.exports = function(f) {
        i(f);
        var g = +f.size;
        if (g !== g) throw new c(o);
        var p = r(g);
        if (p < 0) throw new l(o);
        return new u(f, p);
      };
    })
  ),
  /***/
  3838: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(5170), n = e(8469), r = e(3789);
      h.exports = function(o) {
        var l = s(this), c = r(o);
        return i(l) > c.size ? !1 : n(l, function(d) {
          if (!c.includes(d)) return !1;
        }, !0) !== !1;
      };
    })
  ),
  /***/
  3853: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4449), n = e(4916), r = !n("isDisjointFrom", function(a) {
        return !a;
      });
      s({ target: "Set", proto: !0, real: !0, forced: r }, {
        isDisjointFrom: i
      });
    })
  ),
  /***/
  3925: (
    /***/
    ((h, t, e) => {
      var s = e(34);
      h.exports = function(i) {
        return s(i) || i === null;
      };
    })
  ),
  /***/
  3972: (
    /***/
    ((h, t, e) => {
      var s = e(34), i = String, n = TypeError;
      h.exports = function(r) {
        if (r === void 0 || s(r)) return r;
        throw new n(i(r) + " is not an object or undefined");
      };
    })
  ),
  /***/
  4055: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(34), n = s.document, r = i(n) && i(n.createElement);
      h.exports = function(a) {
        return r ? n.createElement(a) : {};
      };
    })
  ),
  /***/
  4114: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(8981), n = e(6198), r = e(4527), a = e(6837), o = e(9039), l = o(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), c = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (u) {
          return u instanceof TypeError;
        }
      }, d = l || !c();
      s({ target: "Array", proto: !0, arity: 1, forced: d }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(f) {
          var g = i(this), p = n(g), v = arguments.length;
          a(p + v);
          for (var m = 0; m < v; m++)
            g[p] = arguments[m], p++;
          return r(g, p), p;
        }
      });
    })
  ),
  /***/
  4117: (
    /***/
    ((h) => {
      h.exports = function(t) {
        return t == null;
      };
    })
  ),
  /***/
  4149: (
    /***/
    ((h) => {
      var t = RangeError;
      h.exports = function(e) {
        if (e === e) return e;
        throw new t("NaN is not allowed");
      };
    })
  ),
  /***/
  4154: (
    /***/
    ((h, t, e) => {
      var s = e(6955), i = TypeError;
      h.exports = function(n) {
        if (s(n) === "Uint8Array") return n;
        throw new i("Argument is not an Uint8Array");
      };
    })
  ),
  /***/
  4204: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402).add, n = e(9286), r = e(3789), a = e(507);
      h.exports = function(l) {
        var c = s(this), d = r(l).getIterator(), u = n(c);
        return a(d, function(f) {
          i(u, f);
        }), u;
      };
    })
  ),
  /***/
  4209: (
    /***/
    ((h, t, e) => {
      var s = e(8227), i = e(6269), n = s("iterator"), r = Array.prototype;
      h.exports = function(a) {
        return a !== void 0 && (i.Array === a || r[n] === a);
      };
    })
  ),
  /***/
  4215: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(2839), n = e(2195), r = function(a) {
        return i.slice(0, a.length) === a;
      };
      h.exports = (function() {
        return r("Bun/") ? "BUN" : r("Cloudflare-Workers") ? "CLOUDFLARE" : r("Deno/") ? "DENO" : r("Node.js/") ? "NODE" : s.Bun && typeof Bun.version == "string" ? "BUN" : s.Deno && typeof Deno.version == "object" ? "DENO" : n(s.process) === "process" ? "NODE" : s.window && s.document ? "BROWSER" : "REST";
      })();
    })
  ),
  /***/
  4226: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(3463), r = e(4154), a = e(5169), o = e(2303);
      i.Uint8Array && s({ target: "Uint8Array", proto: !0 }, {
        setFromHex: function(c) {
          r(this), n(c), a(this.buffer);
          var d = o(c, this).read;
          return { read: d, written: d / 2 };
        }
      });
    })
  ),
  /***/
  4235: (
    /***/
    ((h, t, e) => {
      e(3068);
    })
  ),
  /***/
  4270: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(4901), n = e(34), r = TypeError;
      h.exports = function(a, o) {
        var l, c;
        if (o === "string" && i(l = a.toString) && !n(c = s(l, a)) || i(l = a.valueOf) && !n(c = s(l, a)) || o !== "string" && i(l = a.toString) && !n(c = s(l, a))) return c;
        throw new r("Can't convert object to primitive value");
      };
    })
  ),
  /***/
  4376: (
    /***/
    ((h, t, e) => {
      var s = e(2195);
      h.exports = Array.isArray || function(n) {
        return s(n) === "Array";
      };
    })
  ),
  /***/
  4402: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = Set.prototype;
      h.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: s(i.add),
        has: s(i.has),
        remove: s(i.delete),
        proto: i
      };
    })
  ),
  /***/
  4449: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402).has, n = e(5170), r = e(3789), a = e(8469), o = e(507), l = e(9539);
      h.exports = function(d) {
        var u = s(this), f = r(d);
        if (n(u) <= f.size) return a(u, function(p) {
          if (f.includes(p)) return !1;
        }, !0) !== !1;
        var g = f.getIterator();
        return o(g, function(p) {
          if (i(u, p)) return l(g, "normal", !1);
        }) !== !1;
      };
    })
  ),
  /***/
  4483: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(9429), n = e(1548), r = s.structuredClone, a = s.ArrayBuffer, o = s.MessageChannel, l = !1, c, d, u, f;
      if (n)
        l = function(g) {
          r(g, { transfer: [g] });
        };
      else if (a) try {
        o || (c = i("worker_threads"), c && (o = c.MessageChannel)), o && (d = new o(), u = new a(2), f = function(g) {
          d.port1.postMessage(null, [g]);
        }, u.byteLength === 2 && (f(u), u.byteLength === 0 && (l = f)));
      } catch {
      }
      h.exports = l;
    })
  ),
  /***/
  4495: (
    /***/
    ((h, t, e) => {
      var s = e(9519), i = e(9039), n = e(4576), r = n.String;
      h.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var a = Symbol("symbol detection");
        return !r(a) || !(Object(a) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && s && s < 41;
      });
    })
  ),
  /***/
  4527: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(4376), n = TypeError, r = Object.getOwnPropertyDescriptor, a = s && !(function() {
        if (this !== void 0) return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (o) {
          return o instanceof TypeError;
        }
      })();
      h.exports = a ? function(o, l) {
        if (i(o) && !r(o, "length").writable)
          throw new n("Cannot set read only .length");
        return o.length = l;
      } : function(o, l) {
        return o.length = l;
      };
    })
  ),
  /***/
  4549: (
    /***/
    ((h, t, e) => {
      var s = e(4576);
      h.exports = function(i, n) {
        var r = s.Iterator, a = r && r.prototype, o = a && a[i], l = !1;
        if (o) try {
          o.call({
            next: function() {
              return { done: !0 };
            },
            return: function() {
              l = !0;
            }
          }, -1);
        } catch (c) {
          c instanceof n || (l = !1);
        }
        if (!l) return o;
      };
    })
  ),
  /***/
  4576: (
    /***/
    (function(h) {
      var t = function(e) {
        return e && e.Math === Math && e;
      };
      h.exports = // eslint-disable-next-line es/no-global-this -- safe
      t(typeof globalThis == "object" && globalThis) || t(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      t(typeof self == "object" && self) || t(typeof global == "object" && global) || t(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ (function() {
        return this;
      })() || Function("return this")();
    })
  ),
  /***/
  4603: (
    /***/
    ((h, t, e) => {
      var s = e(6840), i = e(9504), n = e(655), r = e(2812), a = URLSearchParams, o = a.prototype, l = i(o.append), c = i(o.delete), d = i(o.forEach), u = i([].push), f = new a("a=1&a=2&b=3");
      f.delete("a", 1), f.delete("b", void 0), f + "" != "a=2" && s(o, "delete", function(g) {
        var p = arguments.length, v = p < 2 ? void 0 : arguments[1];
        if (p && v === void 0) return c(this, g);
        var m = [];
        d(this, function(T, C) {
          u(m, { key: C, value: T });
        }), r(p, 1);
        for (var b = n(g), y = n(v), E = 0, A = 0, w = !1, S = m.length, x; E < S; )
          x = m[E++], w || x.key === b ? (w = !0, c(this, x.key)) : A++;
        for (; A < S; )
          x = m[A++], x.key === b && x.value === y || l(this, x.key, x.value);
      }, { enumerable: !0, unsafe: !0 });
    })
  ),
  /***/
  4628: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(6043);
      s({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var r = i.f(this);
          return {
            promise: r.promise,
            resolve: r.resolve,
            reject: r.reject
          };
        }
      });
    })
  ),
  /***/
  4644: (
    /***/
    ((h, t, e) => {
      var s = e(7811), i = e(3724), n = e(4576), r = e(4901), a = e(34), o = e(9297), l = e(6955), c = e(6823), d = e(6699), u = e(6840), f = e(2106), g = e(1625), p = e(2787), v = e(2967), m = e(8227), b = e(3392), y = e(1181), E = y.enforce, A = y.get, w = n.Int8Array, S = w && w.prototype, x = n.Uint8ClampedArray, T = x && x.prototype, C = w && p(w), P = S && p(S), O = Object.prototype, D = n.TypeError, k = m("toStringTag"), H = b("TYPED_ARRAY_TAG"), M = "TypedArrayConstructor", I = s && !!v && l(n.opera) !== "Opera", N = !1, X, tt, ut, q = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, Q = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, rt = function(nt) {
        if (!a(nt)) return !1;
        var at = l(nt);
        return at === "DataView" || o(q, at) || o(Q, at);
      }, Et = function($) {
        var nt = p($);
        if (a(nt)) {
          var at = A(nt);
          return at && o(at, M) ? at[M] : Et(nt);
        }
      }, L = function($) {
        if (!a($)) return !1;
        var nt = l($);
        return o(q, nt) || o(Q, nt);
      }, R = function($) {
        if (L($)) return $;
        throw new D("Target is not a typed array");
      }, F = function($) {
        if (r($) && (!v || g(C, $))) return $;
        throw new D(c($) + " is not a typed array constructor");
      }, V = function($, nt, at, _t) {
        if (i) {
          if (at) for (var Pt in q) {
            var vt = n[Pt];
            if (vt && o(vt.prototype, $)) try {
              delete vt.prototype[$];
            } catch {
              try {
                vt.prototype[$] = nt;
              } catch {
              }
            }
          }
          (!P[$] || at) && u(P, $, at ? nt : I && S[$] || nt, _t);
        }
      }, st = function($, nt, at) {
        var _t, Pt;
        if (i) {
          if (v) {
            if (at) {
              for (_t in q)
                if (Pt = n[_t], Pt && o(Pt, $)) try {
                  delete Pt[$];
                } catch {
                }
            }
            if (!C[$] || at)
              try {
                return u(C, $, at ? nt : I && C[$] || nt);
              } catch {
              }
            else return;
          }
          for (_t in q)
            Pt = n[_t], Pt && (!Pt[$] || at) && u(Pt, $, nt);
        }
      };
      for (X in q)
        tt = n[X], ut = tt && tt.prototype, ut ? E(ut)[M] = tt : I = !1;
      for (X in Q)
        tt = n[X], ut = tt && tt.prototype, ut && (E(ut)[M] = tt);
      if ((!I || !r(C) || C === Function.prototype) && (C = function() {
        throw new D("Incorrect invocation");
      }, I))
        for (X in q)
          n[X] && v(n[X], C);
      if ((!I || !P || P === O) && (P = C.prototype, I))
        for (X in q)
          n[X] && v(n[X].prototype, P);
      if (I && p(T) !== P && v(T, P), i && !o(P, k)) {
        N = !0, f(P, k, {
          configurable: !0,
          get: function() {
            return a(this) ? this[H] : void 0;
          }
        });
        for (X in q) n[X] && d(n[X], H, X);
      }
      h.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: I,
        TYPED_ARRAY_TAG: N && H,
        aTypedArray: R,
        aTypedArrayConstructor: F,
        exportTypedArrayMethod: V,
        exportTypedArrayStaticMethod: st,
        getTypedArrayConstructor: Et,
        isView: rt,
        isTypedArray: L,
        TypedArray: C,
        TypedArrayPrototype: P
      };
    })
  ),
  /***/
  4659: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(4913), n = e(6980);
      h.exports = function(r, a, o) {
        s ? i.f(r, a, n(0, o)) : r[a] = o;
      };
    })
  ),
  /***/
  4901: (
    /***/
    ((h) => {
      var t = typeof document == "object" && document.all;
      h.exports = typeof t > "u" && t !== void 0 ? function(e) {
        return typeof e == "function" || e === t;
      } : function(e) {
        return typeof e == "function";
      };
    })
  ),
  /***/
  4913: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(5917), n = e(8686), r = e(8551), a = e(6969), o = TypeError, l = Object.defineProperty, c = Object.getOwnPropertyDescriptor, d = "enumerable", u = "configurable", f = "writable";
      t.f = s ? n ? function(p, v, m) {
        if (r(p), v = a(v), r(m), typeof p == "function" && v === "prototype" && "value" in m && f in m && !m[f]) {
          var b = c(p, v);
          b && b[f] && (p[v] = m.value, m = {
            configurable: u in m ? m[u] : b[u],
            enumerable: d in m ? m[d] : b[d],
            writable: !1
          });
        }
        return l(p, v, m);
      } : l : function(p, v, m) {
        if (r(p), v = a(v), r(m), i) try {
          return l(p, v, m);
        } catch {
        }
        if ("get" in m || "set" in m) throw new o("Accessors not supported");
        return "value" in m && (p[v] = m.value), p;
      };
    })
  ),
  /***/
  4916: (
    /***/
    ((h, t, e) => {
      var s = e(7751), i = function(r) {
        return {
          size: r,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      }, n = function(r) {
        return {
          size: r,
          has: function() {
            return !0;
          },
          keys: function() {
            throw new Error("e");
          }
        };
      };
      h.exports = function(r, a) {
        var o = s("Set");
        try {
          new o()[r](i(0));
          try {
            return new o()[r](i(-1)), !1;
          } catch {
            if (!a) return !0;
            try {
              return new o()[r](n(-1 / 0)), !1;
            } catch {
              var l = new o();
              return l.add(1), l.add(2), a(l[r](n(1 / 0)));
            }
          }
        } catch {
          return !1;
        }
      };
    })
  ),
  /***/
  4972: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(8551), r = e(1767), a = e(4149), o = e(9590), l = e(9462), c = e(9539), d = e(4549), u = e(6395), f = !u && d("take", RangeError), g = l(function() {
        var p = this.iterator;
        if (!this.remaining--)
          return this.done = !0, c(p, "normal", void 0);
        var v = n(i(this.next, p)), m = this.done = !!v.done;
        if (!m) return v.value;
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: u || f }, {
        take: function(v) {
          n(this);
          var m;
          try {
            m = o(a(+v));
          } catch (b) {
            c(this, "throw", b);
          }
          return f ? i(f, this, m) : new g(r(this), {
            remaining: m
          });
        }
      });
    })
  ),
  /***/
  4979: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(7751), r = e(6980), a = e(4913).f, o = e(9297), l = e(679), c = e(3167), d = e(2603), u = e(5002), f = e(8574), g = e(3724), p = e(6395), v = "DOMException", m = n("Error"), b = n(v), y = function() {
        l(this, E);
        var M = arguments.length, I = d(M < 1 ? void 0 : arguments[0]), N = d(M < 2 ? void 0 : arguments[1], "Error"), X = new b(I, N), tt = new m(I);
        return tt.name = v, a(X, "stack", r(1, f(tt.stack, 1))), c(X, this, y), X;
      }, E = y.prototype = b.prototype, A = "stack" in new m(v), w = "stack" in new b(1, 2), S = b && g && Object.getOwnPropertyDescriptor(i, v), x = !!S && !(S.writable && S.configurable), T = A && !x && !w;
      s({ global: !0, constructor: !0, forced: p || T }, {
        // TODO: fix export logic
        DOMException: T ? y : b
      });
      var C = n(v), P = C.prototype;
      if (P.constructor !== C) {
        p || a(P, "constructor", r(1, C));
        for (var O in u) if (o(u, O)) {
          var D = u[O], k = D.s;
          o(C, k) || a(C, k, r(6, D.c));
        }
      }
    })
  ),
  /***/
  5002: (
    /***/
    ((h) => {
      h.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    })
  ),
  /***/
  5024: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(3650), n = e(9835), r = e(4916), a = !r("symmetricDifference") || !n("symmetricDifference");
      s({ target: "Set", proto: !0, real: !0, forced: a }, {
        symmetricDifference: i
      });
    })
  ),
  /***/
  5031: (
    /***/
    ((h, t, e) => {
      var s = e(7751), i = e(9504), n = e(8480), r = e(3717), a = e(8551), o = i([].concat);
      h.exports = s("Reflect", "ownKeys") || function(c) {
        var d = n.f(a(c)), u = r.f;
        return u ? o(d, u(c)) : d;
      };
    })
  ),
  /***/
  5169: (
    /***/
    ((h, t, e) => {
      var s = e(3238), i = TypeError;
      h.exports = function(n) {
        if (s(n)) throw new i("ArrayBuffer is detached");
        return n;
      };
    })
  ),
  /***/
  5170: (
    /***/
    ((h, t, e) => {
      var s = e(6706), i = e(4402);
      h.exports = s(i.proto, "size", "get") || function(n) {
        return n.size;
      };
    })
  ),
  /***/
  5213: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(5370), r = e(9143), a = i.Uint8Array, o = !a || !a.fromBase64 || !(function() {
        try {
          a.fromBase64("a");
          return;
        } catch {
        }
        try {
          a.fromBase64("", null);
        } catch {
          return !0;
        }
      })();
      a && s({ target: "Uint8Array", stat: !0, forced: o }, {
        fromBase64: function(c) {
          var d = r(c, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
          return n(a, d.bytes);
        }
      });
    })
  ),
  /***/
  5370: (
    /***/
    ((h, t, e) => {
      var s = e(6198);
      h.exports = function(i, n, r) {
        for (var a = 0, o = arguments.length > 2 ? r : s(n), l = new i(o); o > a; ) l[a] = n[a++];
        return l;
      };
    })
  ),
  /***/
  5397: (
    /***/
    ((h, t, e) => {
      var s = e(7055), i = e(7750);
      h.exports = function(n) {
        return s(i(n));
      };
    })
  ),
  /***/
  5610: (
    /***/
    ((h, t, e) => {
      var s = e(1291), i = Math.max, n = Math.min;
      h.exports = function(r, a) {
        var o = s(r);
        return o < 0 ? i(o + a, 0) : n(o, a);
      };
    })
  ),
  /***/
  5623: (
    /***/
    ((h, t, e) => {
      e(456);
    })
  ),
  /***/
  5636: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(9504), n = e(6706), r = e(7696), a = e(5169), o = e(7394), l = e(4483), c = e(1548), d = s.structuredClone, u = s.ArrayBuffer, f = s.DataView, g = Math.min, p = u.prototype, v = f.prototype, m = i(p.slice), b = n(p, "resizable", "get"), y = n(p, "maxByteLength", "get"), E = i(v.getInt8), A = i(v.setInt8);
      h.exports = (c || l) && function(w, S, x) {
        var T = o(w), C = S === void 0 ? T : r(S), P = !b || !b(w), O;
        if (a(w), c && (w = d(w, { transfer: [w] }), T === C && (x || P)))
          return w;
        if (T >= C && (!x || P))
          O = m(w, 0, C);
        else {
          var D = x && !P && y ? { maxByteLength: y(w) } : void 0;
          O = new u(C, D);
          for (var k = new f(w), H = new f(O), M = g(C, T), I = 0; I < M; I++) A(H, I, E(k, I));
        }
        return c || l(w), O;
      };
    })
  ),
  /***/
  5745: (
    /***/
    ((h, t, e) => {
      var s = e(7629);
      h.exports = function(i, n) {
        return s[i] || (s[i] = n || {});
      };
    })
  ),
  /***/
  5781: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(7751), n = e(2812), r = e(655), a = e(7416), o = i("URL");
      s({ target: "URL", stat: !0, forced: !a }, {
        parse: function(c) {
          var d = n(arguments.length, 1), u = r(c), f = d < 2 || arguments[1] === void 0 ? void 0 : r(arguments[1]);
          try {
            return new o(u, f);
          } catch {
            return null;
          }
        }
      });
    })
  ),
  /***/
  5854: (
    /***/
    ((h, t, e) => {
      var s = e(2777), i = TypeError;
      h.exports = function(n) {
        var r = s(n, "number");
        if (typeof r == "number") throw new i("Can't convert number to bigint");
        return BigInt(r);
      };
    })
  ),
  /***/
  5876: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(3838), n = e(4916), r = !n("isSubsetOf", function(a) {
        return a;
      });
      s({ target: "Set", proto: !0, real: !0, forced: r }, {
        isSubsetOf: i
      });
    })
  ),
  /***/
  5917: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(9039), n = e(4055);
      h.exports = !s && !i(function() {
        return Object.defineProperty(n("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    })
  ),
  /***/
  5966: (
    /***/
    ((h, t, e) => {
      var s = e(9306), i = e(4117);
      h.exports = function(n, r) {
        var a = n[r];
        return i(a) ? void 0 : s(a);
      };
    })
  ),
  /***/
  6043: (
    /***/
    ((h, t, e) => {
      var s = e(9306), i = TypeError, n = function(r) {
        var a, o;
        this.promise = new r(function(l, c) {
          if (a !== void 0 || o !== void 0) throw new i("Bad Promise constructor");
          a = l, o = c;
        }), this.resolve = s(a), this.reject = s(o);
      };
      h.exports.f = function(r) {
        return new n(r);
      };
    })
  ),
  /***/
  6080: (
    /***/
    ((h, t, e) => {
      var s = e(7476), i = e(9306), n = e(616), r = s(s.bind);
      h.exports = function(a, o) {
        return i(a), o === void 0 ? a : n ? r(a, o) : function() {
          return a.apply(o, arguments);
        };
      };
    })
  ),
  /***/
  6119: (
    /***/
    ((h, t, e) => {
      var s = e(5745), i = e(3392), n = s("keys");
      h.exports = function(r) {
        return n[r] || (n[r] = i(r));
      };
    })
  ),
  /***/
  6193: (
    /***/
    ((h, t, e) => {
      var s = e(4215);
      h.exports = s === "NODE";
    })
  ),
  /***/
  6198: (
    /***/
    ((h, t, e) => {
      var s = e(8014);
      h.exports = function(i) {
        return s(i.length);
      };
    })
  ),
  /***/
  6269: (
    /***/
    ((h) => {
      h.exports = {};
    })
  ),
  /***/
  6279: (
    /***/
    ((h, t, e) => {
      var s = e(6840);
      h.exports = function(i, n, r) {
        for (var a in n) s(i, a, n[a], r);
        return i;
      };
    })
  ),
  /***/
  6319: (
    /***/
    ((h, t, e) => {
      var s = e(8551), i = e(9539);
      h.exports = function(n, r, a, o) {
        try {
          return o ? r(s(a)[0], a[1]) : r(a);
        } catch (l) {
          i(n, "throw", l);
        }
      };
    })
  ),
  /***/
  6395: (
    /***/
    ((h) => {
      h.exports = !1;
    })
  ),
  /***/
  6518: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(7347).f, n = e(6699), r = e(6840), a = e(9433), o = e(7740), l = e(2796);
      h.exports = function(c, d) {
        var u = c.target, f = c.global, g = c.stat, p, v, m, b, y, E;
        if (f ? v = s : g ? v = s[u] || a(u, {}) : v = s[u] && s[u].prototype, v) for (m in d) {
          if (y = d[m], c.dontCallGetSet ? (E = i(v, m), b = E && E.value) : b = v[m], p = l(f ? m : u + (g ? "." : "#") + m, c.forced), !p && b !== void 0) {
            if (typeof y == typeof b) continue;
            o(y, b);
          }
          (c.sham || b && b.sham) && n(y, "sham", !0), r(v, m, y, c);
        }
      };
    })
  ),
  /***/
  6573: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(2106), n = e(3238), r = ArrayBuffer.prototype;
      s && !("detached" in r) && i(r, "detached", {
        configurable: !0,
        get: function() {
          return n(this);
        }
      });
    })
  ),
  /***/
  6632: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(9143), r = e(4154), a = i.Uint8Array, o = !a || !a.prototype.setFromBase64 || !(function() {
        var l = new a([255, 255, 255, 255, 255]);
        try {
          l.setFromBase64("", null);
          return;
        } catch {
        }
        try {
          l.setFromBase64("a");
          return;
        } catch {
        }
        try {
          l.setFromBase64("MjYyZg===");
        } catch {
          return l[0] === 50 && l[1] === 54 && l[2] === 50 && l[3] === 255 && l[4] === 255;
        }
      })();
      a && s({ target: "Uint8Array", proto: !0, forced: o }, {
        setFromBase64: function(c) {
          r(this);
          var d = n(c, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
          return { read: d.read, written: d.written };
        }
      });
    })
  ),
  /***/
  6699: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(4913), n = e(6980);
      h.exports = s ? function(r, a, o) {
        return i.f(r, a, n(1, o));
      } : function(r, a, o) {
        return r[a] = o, r;
      };
    })
  ),
  /***/
  6706: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(9306);
      h.exports = function(n, r, a) {
        try {
          return s(i(Object.getOwnPropertyDescriptor(n, r)[a]));
        } catch {
        }
      };
    })
  ),
  /***/
  6801: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(8686), n = e(4913), r = e(8551), a = e(5397), o = e(1072);
      t.f = s && !i ? Object.defineProperties : function(c, d) {
        r(c);
        for (var u = a(d), f = o(d), g = f.length, p = 0, v; g > p; ) n.f(c, v = f[p++], u[v]);
        return c;
      };
    })
  ),
  /***/
  6823: (
    /***/
    ((h) => {
      var t = String;
      h.exports = function(e) {
        try {
          return t(e);
        } catch {
          return "Object";
        }
      };
    })
  ),
  /***/
  6837: (
    /***/
    ((h) => {
      var t = TypeError, e = 9007199254740991;
      h.exports = function(s) {
        if (s > e) throw t("Maximum allowed index exceeded");
        return s;
      };
    })
  ),
  /***/
  6840: (
    /***/
    ((h, t, e) => {
      var s = e(4901), i = e(4913), n = e(283), r = e(9433);
      h.exports = function(a, o, l, c) {
        c || (c = {});
        var d = c.enumerable, u = c.name !== void 0 ? c.name : o;
        if (s(l) && n(l, u, c), c.global)
          d ? a[o] = l : r(o, l);
        else {
          try {
            c.unsafe ? a[o] && (d = !0) : delete a[o];
          } catch {
          }
          d ? a[o] = l : i.f(a, o, {
            value: l,
            enumerable: !1,
            configurable: !c.nonConfigurable,
            writable: !c.nonWritable
          });
        }
        return a;
      };
    })
  ),
  /***/
  6955: (
    /***/
    ((h, t, e) => {
      var s = e(2140), i = e(4901), n = e(2195), r = e(8227), a = r("toStringTag"), o = Object, l = n(/* @__PURE__ */ (function() {
        return arguments;
      })()) === "Arguments", c = function(d, u) {
        try {
          return d[u];
        } catch {
        }
      };
      h.exports = s ? n : function(d) {
        var u, f, g;
        return d === void 0 ? "Undefined" : d === null ? "Null" : typeof (f = c(u = o(d), a)) == "string" ? f : l ? n(u) : (g = n(u)) === "Object" && i(u.callee) ? "Arguments" : g;
      };
    })
  ),
  /***/
  6969: (
    /***/
    ((h, t, e) => {
      var s = e(2777), i = e(757);
      h.exports = function(n) {
        var r = s(n, "string");
        return i(r) ? r : r + "";
      };
    })
  ),
  /***/
  6980: (
    /***/
    ((h) => {
      h.exports = function(t, e) {
        return {
          enumerable: !(t & 1),
          configurable: !(t & 2),
          writable: !(t & 4),
          value: e
        };
      };
    })
  ),
  /***/
  7040: (
    /***/
    ((h, t, e) => {
      var s = e(4495);
      h.exports = s && !Symbol.sham && typeof Symbol.iterator == "symbol";
    })
  ),
  /***/
  7055: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(9039), n = e(2195), r = Object, a = s("".split);
      h.exports = i(function() {
        return !r("z").propertyIsEnumerable(0);
      }) ? function(o) {
        return n(o) === "String" ? a(o, "") : r(o);
      } : r;
    })
  ),
  /***/
  7080: (
    /***/
    ((h, t, e) => {
      var s = e(4402).has;
      h.exports = function(i) {
        return s(i), i;
      };
    })
  ),
  /***/
  7347: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(9565), n = e(8773), r = e(6980), a = e(5397), o = e(6969), l = e(9297), c = e(5917), d = Object.getOwnPropertyDescriptor;
      t.f = s ? d : function(f, g) {
        if (f = a(f), g = o(g), c) try {
          return d(f, g);
        } catch {
        }
        if (l(f, g)) return r(!i(n.f, f, g), f[g]);
      };
    })
  ),
  /***/
  7394: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(6706), n = e(2195), r = s.ArrayBuffer, a = s.TypeError;
      h.exports = r && i(r.prototype, "byteLength", "get") || function(o) {
        if (n(o) !== "ArrayBuffer") throw new a("ArrayBuffer expected");
        return o.byteLength;
      };
    })
  ),
  /***/
  7416: (
    /***/
    ((h, t, e) => {
      var s = e(9039), i = e(8227), n = e(3724), r = e(6395), a = i("iterator");
      h.exports = !s(function() {
        var o = new URL("b?a=1&b=2&c=3", "https://a"), l = o.searchParams, c = new URLSearchParams("a=1&a=2&b=3"), d = "";
        return o.pathname = "c%20d", l.forEach(function(u, f) {
          l.delete("b"), d += f + u;
        }), c.delete("a", 2), c.delete("b", void 0), r && (!o.toJSON || !c.has("a", 1) || c.has("a", 2) || !c.has("a", void 0) || c.has("b")) || !l.size && (r || !n) || !l.sort || o.href !== "https://a/c%20d?a=1&c=3" || l.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !l[a] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://тест").host !== "xn--e1aybc" || new URL("https://a#б").hash !== "#%D0%B1" || d !== "a1c3" || new URL("https://x", void 0).host !== "x";
      });
    })
  ),
  /***/
  7476: (
    /***/
    ((h, t, e) => {
      var s = e(2195), i = e(9504);
      h.exports = function(n) {
        if (s(n) === "Function") return i(n);
      };
    })
  ),
  /***/
  7566: (
    /***/
    ((h, t, e) => {
      var s = e(6840), i = e(9504), n = e(655), r = e(2812), a = URLSearchParams, o = a.prototype, l = i(o.getAll), c = i(o.has), d = new a("a=1");
      (d.has("a", 2) || !d.has("a", void 0)) && s(o, "has", function(f) {
        var g = arguments.length, p = g < 2 ? void 0 : arguments[1];
        if (g && p === void 0) return c(this, f);
        var v = l(this, f);
        r(g, 1);
        for (var m = n(p), b = 0; b < v.length; )
          if (v[b++] === m) return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    })
  ),
  /***/
  7588: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(2652), r = e(9306), a = e(8551), o = e(1767), l = e(9539), c = e(4549), d = c("forEach", TypeError);
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        forEach: function(f) {
          a(this);
          try {
            r(f);
          } catch (v) {
            l(this, "throw", v);
          }
          if (d) return i(d, this, f);
          var g = o(this), p = 0;
          n(g, function(v) {
            f(v, p++);
          }, { IS_RECORD: !0 });
        }
      });
    })
  ),
  /***/
  7629: (
    /***/
    ((h, t, e) => {
      var s = e(6395), i = e(4576), n = e(9433), r = "__core-js_shared__", a = h.exports = i[r] || n(r, {});
      (a.versions || (a.versions = [])).push({
        version: "3.45.1",
        mode: s ? "pure" : "global",
        copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    })
  ),
  /***/
  7642: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(3440), n = e(9039), r = e(4916), a = !r("difference", function(l) {
        return l.size === 0;
      }), o = a || n(function() {
        var l = {
          size: 1,
          has: function() {
            return !0;
          },
          keys: function() {
            var d = 0;
            return {
              next: function() {
                var u = d++ > 1;
                return c.has(1) && c.clear(), { done: u, value: 2 };
              }
            };
          }
        }, c = /* @__PURE__ */ new Set([1, 2, 3, 4]);
        return c.difference(l).size !== 3;
      });
      s({ target: "Set", proto: !0, real: !0, forced: o }, {
        difference: i
      });
    })
  ),
  /***/
  7657: (
    /***/
    ((h, t, e) => {
      var s = e(9039), i = e(4901), n = e(34), r = e(2360), a = e(2787), o = e(6840), l = e(8227), c = e(6395), d = l("iterator"), u = !1, f, g, p;
      [].keys && (p = [].keys(), "next" in p ? (g = a(a(p)), g !== Object.prototype && (f = g)) : u = !0);
      var v = !n(f) || s(function() {
        var m = {};
        return f[d].call(m) !== m;
      });
      v ? f = {} : c && (f = r(f)), i(f[d]) || o(f, d, function() {
        return this;
      }), h.exports = {
        IteratorPrototype: f,
        BUGGY_SAFARI_ITERATORS: u
      };
    })
  ),
  /***/
  7680: (
    /***/
    ((h, t, e) => {
      var s = e(9504);
      h.exports = s([].slice);
    })
  ),
  /***/
  7696: (
    /***/
    ((h, t, e) => {
      var s = e(1291), i = e(8014), n = RangeError;
      h.exports = function(r) {
        if (r === void 0) return 0;
        var a = s(r), o = i(a);
        if (a !== o) throw new n("Wrong length or index");
        return o;
      };
    })
  ),
  /***/
  7740: (
    /***/
    ((h, t, e) => {
      var s = e(9297), i = e(5031), n = e(7347), r = e(4913);
      h.exports = function(a, o, l) {
        for (var c = i(o), d = r.f, u = n.f, f = 0; f < c.length; f++) {
          var g = c[f];
          !s(a, g) && !(l && s(l, g)) && d(a, g, u(o, g));
        }
      };
    })
  ),
  /***/
  7750: (
    /***/
    ((h, t, e) => {
      var s = e(4117), i = TypeError;
      h.exports = function(n) {
        if (s(n)) throw new i("Can't call method on " + n);
        return n;
      };
    })
  ),
  /***/
  7751: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(4901), n = function(r) {
        return i(r) ? r : void 0;
      };
      h.exports = function(r, a) {
        return arguments.length < 2 ? n(s[r]) : s[r] && s[r][a];
      };
    })
  ),
  /***/
  7811: (
    /***/
    ((h) => {
      h.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    })
  ),
  /***/
  7936: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    })
  ),
  /***/
  8004: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9039), n = e(8750), r = e(4916), a = !r("intersection", function(o) {
        return o.size === 2 && o.has(1) && o.has(2);
      }) || i(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      s({ target: "Set", proto: !0, real: !0, forced: a }, {
        intersection: n
      });
    })
  ),
  /***/
  8014: (
    /***/
    ((h, t, e) => {
      var s = e(1291), i = Math.min;
      h.exports = function(n) {
        var r = s(n);
        return r > 0 ? i(r, 9007199254740991) : 0;
      };
    })
  ),
  /***/
  8100: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    })
  ),
  /***/
  8111: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(679), r = e(8551), a = e(4901), o = e(2787), l = e(2106), c = e(4659), d = e(9039), u = e(9297), f = e(8227), g = e(7657).IteratorPrototype, p = e(3724), v = e(6395), m = "constructor", b = "Iterator", y = f("toStringTag"), E = TypeError, A = i[b], w = v || !a(A) || A.prototype !== g || !d(function() {
        A({});
      }), S = function() {
        if (n(this, g), o(this) === g) throw new E("Abstract class Iterator not directly constructable");
      }, x = function(T, C) {
        p ? l(g, T, {
          configurable: !0,
          get: function() {
            return C;
          },
          set: function(P) {
            if (r(this), this === g) throw new E("You can't redefine this property");
            u(this, T) ? this[T] = P : c(this, T, P);
          }
        }) : g[T] = C;
      };
      u(g, y) || x(y, b), (w || !u(g, m) || g[m] === Object) && x(m, S), S.prototype = g, s({ global: !0, constructor: !0, forced: w }, {
        Iterator: S
      });
    })
  ),
  /***/
  8227: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(5745), n = e(9297), r = e(3392), a = e(4495), o = e(7040), l = s.Symbol, c = i("wks"), d = o ? l.for || l : l && l.withoutSetter || r;
      h.exports = function(u) {
        return n(c, u) || (c[u] = a && n(l, u) ? l[u] : d("Symbol." + u)), c[u];
      };
    })
  ),
  /***/
  8235: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(9297), n = SyntaxError, r = parseInt, a = String.fromCharCode, o = s("".charAt), l = s("".slice), c = s(/./.exec), d = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": `
`,
        "\\r": "\r",
        "\\t": "	"
      }, u = /^[\da-f]{4}$/i, f = /^[\u0000-\u001F]$/;
      h.exports = function(g, p) {
        for (var v = !0, m = ""; p < g.length; ) {
          var b = o(g, p);
          if (b === "\\") {
            var y = l(g, p, p + 2);
            if (i(d, y))
              m += d[y], p += 2;
            else if (y === "\\u") {
              p += 2;
              var E = l(g, p, p + 4);
              if (!c(u, E)) throw new n("Bad Unicode escape at: " + p);
              m += a(r(E, 16)), p += 4;
            } else throw new n('Unknown escape sequence: "' + y + '"');
          } else if (b === '"') {
            v = !1, p++;
            break;
          } else {
            if (c(f, b)) throw new n("Bad control character in string literal at: " + p);
            m += b, p++;
          }
        }
        if (v) throw new n("Unterminated string at: " + p);
        return { value: m, end: p };
      };
    })
  ),
  /***/
  8237: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(2652), n = e(9306), r = e(8551), a = e(1767), o = e(9539), l = e(4549), c = e(8745), d = e(9039), u = TypeError, f = d(function() {
        [].keys().reduce(function() {
        }, void 0);
      }), g = !f && l("reduce", u);
      s({ target: "Iterator", proto: !0, real: !0, forced: f || g }, {
        reduce: function(v) {
          r(this);
          try {
            n(v);
          } catch (A) {
            o(this, "throw", A);
          }
          var m = arguments.length < 2, b = m ? void 0 : arguments[1];
          if (g)
            return c(g, this, m ? [v] : [v, b]);
          var y = a(this), E = 0;
          if (i(y, function(A) {
            m ? (m = !1, b = A) : b = v(b, A, E), E++;
          }, { IS_RECORD: !0 }), m) throw new u("Reduce of empty iterator with no initial value");
          return b;
        }
      });
    })
  ),
  /***/
  8335: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(3724), n = e(4576), r = e(7751), a = e(9504), o = e(9565), l = e(4901), c = e(34), d = e(4376), u = e(9297), f = e(655), g = e(6198), p = e(4659), v = e(9039), m = e(8235), b = e(4495), y = n.JSON, E = n.Number, A = n.SyntaxError, w = y && y.parse, S = r("Object", "keys"), x = Object.getOwnPropertyDescriptor, T = a("".charAt), C = a("".slice), P = a(/./.exec), O = a([].push), D = /^\d$/, k = /^[1-9]$/, H = /^[\d-]$/, M = /^[\t\n\r ]$/, I = 0, N = 1, X = function(L, R) {
        L = f(L);
        var F = new Q(L, 0), V = F.parse(), st = V.value, $ = F.skip(M, V.end);
        if ($ < L.length)
          throw new A('Unexpected extra character: "' + T(L, $) + '" after the parsed data at: ' + $);
        return l(R) ? tt({ "": st }, "", R, V) : st;
      }, tt = function(L, R, F, V) {
        var st = L[R], $ = V && st === V.value, nt = $ && typeof V.source == "string" ? { source: V.source } : {}, at, _t, Pt, vt, ve;
        if (c(st)) {
          var Es = d(st), Ze = $ ? V.nodes : Es ? [] : {};
          if (Es)
            for (at = Ze.length, Pt = g(st), vt = 0; vt < Pt; vt++)
              ut(st, vt, tt(st, "" + vt, F, vt < at ? Ze[vt] : void 0));
          else
            for (_t = S(st), Pt = g(_t), vt = 0; vt < Pt; vt++)
              ve = _t[vt], ut(st, ve, tt(st, ve, F, u(Ze, ve) ? Ze[ve] : void 0));
        }
        return o(F, L, R, st, nt);
      }, ut = function(L, R, F) {
        if (i) {
          var V = x(L, R);
          if (V && !V.configurable) return;
        }
        F === void 0 ? delete L[R] : p(L, R, F);
      }, q = function(L, R, F, V) {
        this.value = L, this.end = R, this.source = F, this.nodes = V;
      }, Q = function(L, R) {
        this.source = L, this.index = R;
      };
      Q.prototype = {
        fork: function(L) {
          return new Q(this.source, L);
        },
        parse: function() {
          var L = this.source, R = this.skip(M, this.index), F = this.fork(R), V = T(L, R);
          if (P(H, V)) return F.number();
          switch (V) {
            case "{":
              return F.object();
            case "[":
              return F.array();
            case '"':
              return F.string();
            case "t":
              return F.keyword(!0);
            case "f":
              return F.keyword(!1);
            case "n":
              return F.keyword(null);
          }
          throw new A('Unexpected character: "' + V + '" at: ' + R);
        },
        node: function(L, R, F, V, st) {
          return new q(R, V, L ? null : C(this.source, F, V), st);
        },
        object: function() {
          for (var L = this.source, R = this.index + 1, F = !1, V = {}, st = {}; R < L.length; ) {
            if (R = this.until(['"', "}"], R), T(L, R) === "}" && !F) {
              R++;
              break;
            }
            var $ = this.fork(R).string(), nt = $.value;
            R = $.end, R = this.until([":"], R) + 1, R = this.skip(M, R), $ = this.fork(R).parse(), p(st, nt, $), p(V, nt, $.value), R = this.until([",", "}"], $.end);
            var at = T(L, R);
            if (at === ",")
              F = !0, R++;
            else if (at === "}") {
              R++;
              break;
            }
          }
          return this.node(N, V, this.index, R, st);
        },
        array: function() {
          for (var L = this.source, R = this.index + 1, F = !1, V = [], st = []; R < L.length; ) {
            if (R = this.skip(M, R), T(L, R) === "]" && !F) {
              R++;
              break;
            }
            var $ = this.fork(R).parse();
            if (O(st, $), O(V, $.value), R = this.until([",", "]"], $.end), T(L, R) === ",")
              F = !0, R++;
            else if (T(L, R) === "]") {
              R++;
              break;
            }
          }
          return this.node(N, V, this.index, R, st);
        },
        string: function() {
          var L = this.index, R = m(this.source, this.index + 1);
          return this.node(I, R.value, L, R.end);
        },
        number: function() {
          var L = this.source, R = this.index, F = R;
          if (T(L, F) === "-" && F++, T(L, F) === "0") F++;
          else if (P(k, T(L, F))) F = this.skip(D, F + 1);
          else throw new A("Failed to parse number at: " + F);
          if (T(L, F) === "." && (F = this.skip(D, F + 1)), T(L, F) === "e" || T(L, F) === "E") {
            F++, (T(L, F) === "+" || T(L, F) === "-") && F++;
            var V = F;
            if (F = this.skip(D, F), V === F) throw new A("Failed to parse number's exponent value at: " + F);
          }
          return this.node(I, E(C(L, R, F)), R, F);
        },
        keyword: function(L) {
          var R = "" + L, F = this.index, V = F + R.length;
          if (C(this.source, F, V) !== R) throw new A("Failed to parse value at: " + F);
          return this.node(I, L, F, V);
        },
        skip: function(L, R) {
          for (var F = this.source; R < F.length && P(L, T(F, R)); R++) ;
          return R;
        },
        until: function(L, R) {
          R = this.skip(M, R);
          for (var F = T(this.source, R), V = 0; V < L.length; V++) if (L[V] === F) return R;
          throw new A('Unexpected character: "' + F + '" at: ' + R);
        }
      };
      var rt = v(function() {
        var L = "9007199254740993", R;
        return w(L, function(F, V, st) {
          R = st.source;
        }), R !== L;
      }), Et = b && !v(function() {
        return 1 / w("-0 	") !== -1 / 0;
      });
      s({ target: "JSON", stat: !0, forced: rt }, {
        parse: function(R, F) {
          return Et && !l(F) ? w(R) : X(R, F);
        }
      });
    })
  ),
  /***/
  8469: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(507), n = e(4402), r = n.Set, a = n.proto, o = s(a.forEach), l = s(a.keys), c = l(new r()).next;
      h.exports = function(d, u, f) {
        return f ? i({ iterator: l(d), next: c }, u) : o(d, u);
      };
    })
  ),
  /***/
  8480: (
    /***/
    ((h, t, e) => {
      var s = e(1828), i = e(8727), n = i.concat("length", "prototype");
      t.f = Object.getOwnPropertyNames || function(a) {
        return s(a, n);
      };
    })
  ),
  /***/
  8527: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402).has, n = e(5170), r = e(3789), a = e(507), o = e(9539);
      h.exports = function(c) {
        var d = s(this), u = r(c);
        if (n(d) < u.size) return !1;
        var f = u.getIterator();
        return a(f, function(g) {
          if (!i(d, g)) return o(f, "normal", !1);
        }) !== !1;
      };
    })
  ),
  /***/
  8551: (
    /***/
    ((h, t, e) => {
      var s = e(34), i = String, n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not an object");
      };
    })
  ),
  /***/
  8574: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = Error, n = s("".replace), r = (function(l) {
        return String(new i(l).stack);
      })("zxcasd"), a = /\n\s*at [^:]*:[^\n]*/, o = a.test(r);
      h.exports = function(l, c) {
        if (o && typeof l == "string" && !i.prepareStackTrace)
          for (; c--; ) l = n(l, a, "");
        return l;
      };
    })
  ),
  /***/
  8622: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(4901), n = s.WeakMap;
      h.exports = i(n) && /native code/.test(String(n));
    })
  ),
  /***/
  8646: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(8551), n = e(1767), r = e(851);
      h.exports = function(a, o) {
        (!o || typeof a != "string") && i(a);
        var l = r(a);
        return n(i(l !== void 0 ? s(l, a) : a));
      };
    })
  ),
  /***/
  8686: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(9039);
      h.exports = s && i(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    })
  ),
  /***/
  8721: (
    /***/
    ((h, t, e) => {
      var s = e(3724), i = e(9504), n = e(2106), r = URLSearchParams.prototype, a = i(r.forEach);
      s && !("size" in r) && n(r, "size", {
        get: function() {
          var l = 0;
          return a(this, function() {
            l++;
          }), l;
        },
        configurable: !0,
        enumerable: !0
      });
    })
  ),
  /***/
  8727: (
    /***/
    ((h) => {
      h.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    })
  ),
  /***/
  8745: (
    /***/
    ((h, t, e) => {
      var s = e(616), i = Function.prototype, n = i.apply, r = i.call;
      h.exports = typeof Reflect == "object" && Reflect.apply || (s ? r.bind(n) : function() {
        return r.apply(n, arguments);
      });
    })
  ),
  /***/
  8750: (
    /***/
    ((h, t, e) => {
      var s = e(7080), i = e(4402), n = e(5170), r = e(3789), a = e(8469), o = e(507), l = i.Set, c = i.add, d = i.has;
      h.exports = function(f) {
        var g = s(this), p = r(f), v = new l();
        return n(g) > p.size ? o(p.getIterator(), function(m) {
          d(g, m) && c(v, m);
        }) : a(g, function(m) {
          p.includes(m) && c(v, m);
        }), v;
      };
    })
  ),
  /***/
  8773: (
    /***/
    ((h, t) => {
      var e = {}.propertyIsEnumerable, s = Object.getOwnPropertyDescriptor, i = s && !e.call({ 1: 2 }, 1);
      t.f = i ? function(r) {
        var a = s(this, r);
        return !!a && a.enumerable;
      } : e;
    })
  ),
  /***/
  8981: (
    /***/
    ((h, t, e) => {
      var s = e(7750), i = Object;
      h.exports = function(n) {
        return i(s(n));
      };
    })
  ),
  /***/
  9039: (
    /***/
    ((h) => {
      h.exports = function(t) {
        try {
          return !!t();
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  9143: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(9504), n = e(3972), r = e(3463), a = e(9297), o = e(2804), l = e(944), c = e(5169), d = o.c2i, u = o.c2iUrl, f = s.SyntaxError, g = s.TypeError, p = i("".charAt), v = function(y, E) {
        for (var A = y.length; E < A; E++) {
          var w = p(y, E);
          if (w !== " " && w !== "	" && w !== `
` && w !== "\f" && w !== "\r") break;
        }
        return E;
      }, m = function(y, E, A) {
        var w = y.length;
        w < 4 && (y += w === 2 ? "AA" : "A");
        var S = (E[p(y, 0)] << 18) + (E[p(y, 1)] << 12) + (E[p(y, 2)] << 6) + E[p(y, 3)], x = [
          S >> 16 & 255,
          S >> 8 & 255,
          S & 255
        ];
        if (w === 2) {
          if (A && x[1] !== 0)
            throw new f("Extra bits");
          return [x[0]];
        }
        if (w === 3) {
          if (A && x[2] !== 0)
            throw new f("Extra bits");
          return [x[0], x[1]];
        }
        return x;
      }, b = function(y, E, A) {
        for (var w = E.length, S = 0; S < w; S++)
          y[A + S] = E[S];
        return A + w;
      };
      h.exports = function(y, E, A, w) {
        r(y), n(E);
        var S = l(E) === "base64" ? d : u, x = E ? E.lastChunkHandling : void 0;
        if (x === void 0 && (x = "loose"), x !== "loose" && x !== "strict" && x !== "stop-before-partial")
          throw new g("Incorrect `lastChunkHandling` option");
        A && c(A.buffer);
        var T = y.length, C = A || [], P = 0, O = 0, D = "", k = 0;
        if (w) for (; ; ) {
          if (k = v(y, k), k === T) {
            if (D.length > 0) {
              if (x === "stop-before-partial")
                break;
              if (x === "loose") {
                if (D.length === 1)
                  throw new f("Malformed padding: exactly one additional character");
                P = b(C, m(D, S, !1), P);
              } else
                throw new f("Missing padding");
            }
            O = T;
            break;
          }
          var H = p(y, k);
          if (++k, H === "=") {
            if (D.length < 2)
              throw new f("Padding is too early");
            if (k = v(y, k), D.length === 2) {
              if (k === T) {
                if (x === "stop-before-partial")
                  break;
                throw new f("Malformed padding: only one =");
              }
              p(y, k) === "=" && (++k, k = v(y, k));
            }
            if (k < T)
              throw new f("Unexpected character after padding");
            P = b(C, m(D, S, x === "strict"), P), O = T;
            break;
          }
          if (!a(S, H))
            throw new f("Unexpected character");
          var M = w - P;
          if (M === 1 && D.length === 2 || M === 2 && D.length === 3 || (D += H, D.length === 4 && (P = b(C, m(D, S, !1), P), D = "", O = k, P === w)))
            break;
        }
        return { bytes: C, read: O, written: P };
      };
    })
  ),
  /***/
  9286: (
    /***/
    ((h, t, e) => {
      var s = e(4402), i = e(8469), n = s.Set, r = s.add;
      h.exports = function(a) {
        var o = new n();
        return i(a, function(l) {
          r(o, l);
        }), o;
      };
    })
  ),
  /***/
  9297: (
    /***/
    ((h, t, e) => {
      var s = e(9504), i = e(8981), n = s({}.hasOwnProperty);
      h.exports = Object.hasOwn || function(a, o) {
        return n(i(a), o);
      };
    })
  ),
  /***/
  9306: (
    /***/
    ((h, t, e) => {
      var s = e(4901), i = e(6823), n = TypeError;
      h.exports = function(r) {
        if (s(r)) return r;
        throw new n(i(r) + " is not a function");
      };
    })
  ),
  /***/
  9314: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(9565), n = e(8551), r = e(1767), a = e(4149), o = e(9590), l = e(9539), c = e(9462), d = e(684), u = e(4549), f = e(6395), g = !f && !d("drop", 0), p = !f && !g && u("drop", RangeError), v = f || g || p, m = c(function() {
        for (var b = this.iterator, y = this.next, E, A; this.remaining; )
          if (this.remaining--, E = n(i(y, b)), A = this.done = !!E.done, A) return;
        if (E = n(i(y, b)), A = this.done = !!E.done, !A) return E.value;
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: v }, {
        drop: function(y) {
          n(this);
          var E;
          try {
            E = o(a(+y));
          } catch (A) {
            l(this, "throw", A);
          }
          return p ? i(p, this, E) : new m(r(this), {
            remaining: E
          });
        }
      });
    })
  ),
  /***/
  9429: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(6193);
      h.exports = function(n) {
        if (i) {
          try {
            return s.process.getBuiltinModule(n);
          } catch {
          }
          try {
            return Function('return require("' + n + '")')();
          } catch {
          }
        }
      };
    })
  ),
  /***/
  9432: (
    /***/
    ((h, t, e) => {
      e(5213);
    })
  ),
  /***/
  9433: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = Object.defineProperty;
      h.exports = function(n, r) {
        try {
          i(s, n, { value: r, configurable: !0, writable: !0 });
        } catch {
          s[n] = r;
        }
        return r;
      };
    })
  ),
  /***/
  9462: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(2360), n = e(6699), r = e(6279), a = e(8227), o = e(1181), l = e(5966), c = e(7657).IteratorPrototype, d = e(2529), u = e(9539), f = e(1385), g = a("toStringTag"), p = "IteratorHelper", v = "WrapForValidIterator", m = "normal", b = "throw", y = o.set, E = function(S) {
        var x = o.getterFor(S ? v : p);
        return r(i(c), {
          next: function() {
            var C = x(this);
            if (S) return C.nextHandler();
            if (C.done) return d(void 0, !0);
            try {
              var P = C.nextHandler();
              return C.returnHandlerResult ? P : d(P, C.done);
            } catch (O) {
              throw C.done = !0, O;
            }
          },
          return: function() {
            var T = x(this), C = T.iterator;
            if (T.done = !0, S) {
              var P = l(C, "return");
              return P ? s(P, C) : d(void 0, !0);
            }
            if (T.inner) try {
              u(T.inner.iterator, m);
            } catch (O) {
              return u(C, b, O);
            }
            if (T.openIters) try {
              f(T.openIters, m);
            } catch (O) {
              return u(C, b, O);
            }
            return C && u(C, m), d(void 0, !0);
          }
        });
      }, A = E(!0), w = E(!1);
      n(w, g, "Iterator Helper"), h.exports = function(S, x, T) {
        var C = function(O, D) {
          D ? (D.iterator = O.iterator, D.next = O.next) : D = O, D.type = x ? v : p, D.returnHandlerResult = !!T, D.nextHandler = S, D.counter = 0, D.done = !1, y(this, D);
        };
        return C.prototype = x ? A : w, C;
      };
    })
  ),
  /***/
  9486: (
    /***/
    ((h, t, e) => {
      var s = e(6518), i = e(4576), n = e(9504), r = e(3972), a = e(4154), o = e(5169), l = e(2804), c = e(944), d = l.i2c, u = l.i2cUrl, f = n("".charAt), g = i.Uint8Array, p = !g || !g.prototype.toBase64 || !(function() {
        try {
          var v = new g();
          v.toBase64(null);
        } catch {
          return !0;
        }
      })();
      g && s({ target: "Uint8Array", proto: !0, forced: p }, {
        toBase64: function() {
          var m = a(this), b = arguments.length ? r(arguments[0]) : void 0, y = c(b) === "base64" ? d : u, E = !!b && !!b.omitPadding;
          o(this.buffer);
          for (var A = "", w = 0, S = m.length, x, T = function(C) {
            return f(y, x >> 6 * C & 63);
          }; w + 2 < S; w += 3)
            x = (m[w] << 16) + (m[w + 1] << 8) + m[w + 2], A += T(3) + T(2) + T(1) + T(0);
          return w + 2 === S ? (x = (m[w] << 16) + (m[w + 1] << 8), A += T(3) + T(2) + T(1) + (E ? "" : "=")) : w + 1 === S && (x = m[w] << 16, A += T(3) + T(2) + (E ? "" : "==")), A;
        }
      });
    })
  ),
  /***/
  9504: (
    /***/
    ((h, t, e) => {
      var s = e(616), i = Function.prototype, n = i.call, r = s && i.bind.bind(n, n);
      h.exports = s ? r : function(a) {
        return function() {
          return n.apply(a, arguments);
        };
      };
    })
  ),
  /***/
  9519: (
    /***/
    ((h, t, e) => {
      var s = e(4576), i = e(2839), n = s.process, r = s.Deno, a = n && n.versions || r && r.version, o = a && a.v8, l, c;
      o && (l = o.split("."), c = l[0] > 0 && l[0] < 4 ? 1 : +(l[0] + l[1])), !c && i && (l = i.match(/Edge\/(\d+)/), (!l || l[1] >= 74) && (l = i.match(/Chrome\/(\d+)/), l && (c = +l[1]))), h.exports = c;
    })
  ),
  /***/
  9539: (
    /***/
    ((h, t, e) => {
      var s = e(9565), i = e(8551), n = e(5966);
      h.exports = function(r, a, o) {
        var l, c;
        i(r);
        try {
          if (l = n(r, "return"), !l) {
            if (a === "throw") throw o;
            return o;
          }
          l = s(l, r);
        } catch (d) {
          c = !0, l = d;
        }
        if (a === "throw") throw o;
        if (c) throw l;
        return i(l), o;
      };
    })
  ),
  /***/
  9565: (
    /***/
    ((h, t, e) => {
      var s = e(616), i = Function.prototype.call;
      h.exports = s ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    })
  ),
  /***/
  9577: (
    /***/
    ((h, t, e) => {
      var s = e(9928), i = e(4644), n = e(1108), r = e(1291), a = e(5854), o = i.aTypedArray, l = i.getTypedArrayConstructor, c = i.exportTypedArrayMethod, d = (function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (f) {
          return f === 8;
        }
      })(), u = d && (function() {
        try {
          new Int8Array(1).with(-0.5, 1);
        } catch {
          return !0;
        }
      })();
      c("with", function(f, g) {
        var p = o(this), v = r(f), m = n(p) ? a(g) : +g;
        return s(p, l(p), v, m);
      }, !d || u);
    })
  ),
  /***/
  9590: (
    /***/
    ((h, t, e) => {
      var s = e(1291), i = RangeError;
      h.exports = function(n) {
        var r = s(n);
        if (r < 0) throw new i("The argument can't be less than 0");
        return r;
      };
    })
  ),
  /***/
  9617: (
    /***/
    ((h, t, e) => {
      var s = e(5397), i = e(5610), n = e(6198), r = function(a) {
        return function(o, l, c) {
          var d = s(o), u = n(d);
          if (u === 0) return !a && -1;
          var f = i(c, u), g;
          if (a && l !== l) {
            for (; u > f; )
              if (g = d[f++], g !== g) return !0;
          } else for (; u > f; f++)
            if ((a || f in d) && d[f] === l) return a || f || 0;
          return !a && -1;
        };
      };
      h.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: r(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: r(!1)
      };
    })
  ),
  /***/
  9631: (
    /***/
    ((h, t, e) => {
      e(9486);
    })
  ),
  /***/
  9797: (
    /***/
    ((h, t, e) => {
      e(4226);
    })
  ),
  /***/
  9835: (
    /***/
    ((h) => {
      h.exports = function(t) {
        try {
          var e = /* @__PURE__ */ new Set(), s = {
            size: 0,
            has: function() {
              return !0;
            },
            keys: function() {
              return Object.defineProperty({}, "next", {
                get: function() {
                  return e.clear(), e.add(4), function() {
                    return { done: !0 };
                  };
                }
              });
            }
          }, i = e[t](s);
          return i.size === 1 && i.values().next().value === 4;
        } catch {
          return !1;
        }
      };
    })
  ),
  /***/
  9928: (
    /***/
    ((h, t, e) => {
      var s = e(6198), i = e(1291), n = RangeError;
      h.exports = function(r, a, o, l) {
        var c = s(r), d = i(o), u = d < 0 ? c + d : d;
        if (u >= c || u < 0) throw new n("Incorrect index");
        for (var f = new a(c), g = 0; g < c; g++) f[g] = g === u ? l : r[g];
        return f;
      };
    })
  )
  /******/
}, ui = {};
function W(h) {
  var t = ui[h];
  if (t !== void 0)
    return t.exports;
  var e = ui[h] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return Cn[h].call(e.exports, e, e.exports, W), e.exports;
}
W.d = (h, t) => {
  for (var e in t)
    W.o(t, e) && !W.o(h, e) && Object.defineProperty(h, e, { enumerable: !0, get: t[e] });
};
W.o = (h, t) => Object.prototype.hasOwnProperty.call(h, t);
W(4114);
W(6573);
W(8100);
W(7936);
W(8111);
W(8237);
W(1689);
W(9577);
W(4235);
W(9432);
W(1549);
W(9797);
W(9631);
W(5623);
W(4979);
W(5781);
const Rt = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), Os = [1e-3, 0, 0, 1e-3, 0, 0], xs = 1.35, kt = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, se = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, He = "pdfjs_internal_editor_", G = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15,
  POPUP: 16,
  SIGNATURE: 101,
  COMMENT: 102
}, J = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_THICKNESS: 32,
  HIGHLIGHT_FREE: 33,
  HIGHLIGHT_SHOW_ALL: 34,
  DRAW_STEP: 41
}, $i = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, St = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, Vt = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, ft = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, be = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, Ie = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, It = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93,
  rawFillPath: 94
}, qe = {
  moveTo: 0,
  lineTo: 1,
  curveTo: 2,
  closePath: 3
}, ji = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let gs = Ie.WARNINGS;
function Pn(h) {
  Number.isInteger(h) && (gs = h);
}
function Rn() {
  return gs;
}
function ms(h) {
  gs >= Ie.INFOS && console.info(`Info: ${h}`);
}
function z(h) {
  gs >= Ie.WARNINGS && console.warn(`Warning: ${h}`);
}
function it(h) {
  throw new Error(h);
}
function Z(h, t) {
  h || it(t);
}
function In(h) {
  switch (h?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function zs(h, t = null, e = null) {
  if (!h)
    return null;
  if (e && typeof h == "string" && (e.addDefaultProtocol && h.startsWith("www.") && h.match(/\./g)?.length >= 2 && (h = `http://${h}`), e.tryConvertEncoding))
    try {
      h = kn(h);
    } catch {
    }
  const s = t ? URL.parse(h, t) : URL.parse(h);
  return In(s) ? s : null;
}
function Vs(h, t, e = !1) {
  const s = URL.parse(h);
  return s ? (s.hash = t, s.href) : e && zs(h, "http://example.com") ? h.split("#", 1)[0] + `${t ? `#${t}` : ""}` : "";
}
function K(h, t, e, s = !1) {
  return Object.defineProperty(h, t, {
    value: e,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), e;
}
const ge = (function() {
  function t(e, s) {
    this.message = e, this.name = s;
  }
  return t.prototype = new Error(), t.constructor = t, t;
})();
class fi extends ge {
  constructor(t, e) {
    super(t, "PasswordException"), this.code = e;
  }
}
class Ts extends ge {
  constructor(t, e) {
    super(t, "UnknownErrorException"), this.details = e;
  }
}
class ds extends ge {
  constructor(t) {
    super(t, "InvalidPDFException");
  }
}
class $e extends ge {
  constructor(t, e, s) {
    super(t, "ResponseException"), this.status = e, this.missing = s;
  }
}
class Mn extends ge {
  constructor(t) {
    super(t, "FormatError");
  }
}
class ie extends ge {
  constructor(t) {
    super(t, "AbortException");
  }
}
function zi(h) {
  (typeof h != "object" || h?.length === void 0) && it("Invalid argument for bytesToString");
  const t = h.length, e = 8192;
  if (t < e)
    return String.fromCharCode.apply(null, h);
  const s = [];
  for (let i = 0; i < t; i += e) {
    const n = Math.min(i + e, t), r = h.subarray(i, n);
    s.push(String.fromCharCode.apply(null, r));
  }
  return s.join("");
}
function Ge(h) {
  typeof h != "string" && it("Invalid argument for stringToBytes");
  const t = h.length, e = new Uint8Array(t);
  for (let s = 0; s < t; ++s)
    e[s] = h.charCodeAt(s) & 255;
  return e;
}
function Dn(h) {
  return String.fromCharCode(h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, h & 255);
}
function Ln() {
  const h = new Uint8Array(4);
  return h[0] = 1, new Uint32Array(h.buffer, 0, 1)[0] === 1;
}
function On() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class wt {
  static get isLittleEndian() {
    return K(this, "isLittleEndian", Ln());
  }
  static get isEvalSupported() {
    return K(this, "isEvalSupported", On());
  }
  static get isOffscreenCanvasSupported() {
    return K(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get isImageDecoderSupported() {
    return K(this, "isImageDecoderSupported", typeof ImageDecoder < "u");
  }
  static get platform() {
    const {
      platform: t,
      userAgent: e
    } = navigator;
    return K(this, "platform", {
      isAndroid: e.includes("Android"),
      isLinux: t.includes("Linux"),
      isMac: t.includes("Mac"),
      isWindows: t.includes("Win"),
      isFirefox: e.includes("Firefox")
    });
  }
  static get isCSSRoundSupported() {
    return K(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const Cs = Array.from(Array(256).keys(), (h) => h.toString(16).padStart(2, "0"));
class B {
  static makeHexColor(t, e, s) {
    return `#${Cs[t]}${Cs[e]}${Cs[s]}`;
  }
  static domMatrixToTransform(t) {
    return [t.a, t.b, t.c, t.d, t.e, t.f];
  }
  static scaleMinMax(t, e) {
    let s;
    t[0] ? (t[0] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[0], e[2] *= t[0], t[3] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[3], e[3] *= t[3]) : (s = e[0], e[0] = e[1], e[1] = s, s = e[2], e[2] = e[3], e[3] = s, t[1] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[1], e[3] *= t[1], t[2] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[2], e[2] *= t[2]), e[0] += t[4], e[1] += t[5], e[2] += t[4], e[3] += t[5];
  }
  static transform(t, e) {
    return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]];
  }
  static multiplyByDOMMatrix(t, e) {
    return [t[0] * e.a + t[2] * e.b, t[1] * e.a + t[3] * e.b, t[0] * e.c + t[2] * e.d, t[1] * e.c + t[3] * e.d, t[0] * e.e + t[2] * e.f + t[4], t[1] * e.e + t[3] * e.f + t[5]];
  }
  static applyTransform(t, e, s = 0) {
    const i = t[s], n = t[s + 1];
    t[s] = i * e[0] + n * e[2] + e[4], t[s + 1] = i * e[1] + n * e[3] + e[5];
  }
  static applyTransformToBezier(t, e, s = 0) {
    const i = e[0], n = e[1], r = e[2], a = e[3], o = e[4], l = e[5];
    for (let c = 0; c < 6; c += 2) {
      const d = t[s + c], u = t[s + c + 1];
      t[s + c] = d * i + u * r + o, t[s + c + 1] = d * n + u * a + l;
    }
  }
  static applyInverseTransform(t, e) {
    const s = t[0], i = t[1], n = e[0] * e[3] - e[1] * e[2];
    t[0] = (s * e[3] - i * e[2] + e[2] * e[5] - e[4] * e[3]) / n, t[1] = (-s * e[1] + i * e[0] + e[4] * e[1] - e[5] * e[0]) / n;
  }
  static axialAlignedBoundingBox(t, e, s) {
    const i = e[0], n = e[1], r = e[2], a = e[3], o = e[4], l = e[5], c = t[0], d = t[1], u = t[2], f = t[3];
    let g = i * c + o, p = g, v = i * u + o, m = v, b = a * d + l, y = b, E = a * f + l, A = E;
    if (n !== 0 || r !== 0) {
      const w = n * c, S = n * u, x = r * d, T = r * f;
      g += x, m += x, v += T, p += T, b += w, A += w, E += S, y += S;
    }
    s[0] = Math.min(s[0], g, v, p, m), s[1] = Math.min(s[1], b, E, y, A), s[2] = Math.max(s[2], g, v, p, m), s[3] = Math.max(s[3], b, E, y, A);
  }
  static inverseTransform(t) {
    const e = t[0] * t[3] - t[1] * t[2];
    return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e];
  }
  static singularValueDecompose2dScale(t, e) {
    const s = t[0], i = t[1], n = t[2], r = t[3], a = s ** 2 + i ** 2, o = s * n + i * r, l = n ** 2 + r ** 2, c = (a + l) / 2, d = Math.sqrt(c ** 2 - (a * l - o ** 2));
    e[0] = Math.sqrt(c + d || 1), e[1] = Math.sqrt(c - d || 1);
  }
  static normalizeRect(t) {
    const e = t.slice(0);
    return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e;
  }
  static intersect(t, e) {
    const s = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])), i = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]));
    if (s > i)
      return null;
    const n = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])), r = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]));
    return n > r ? null : [s, n, i, r];
  }
  static pointBoundingBox(t, e, s) {
    s[0] = Math.min(s[0], t), s[1] = Math.min(s[1], e), s[2] = Math.max(s[2], t), s[3] = Math.max(s[3], e);
  }
  static rectBoundingBox(t, e, s, i, n) {
    n[0] = Math.min(n[0], t, s), n[1] = Math.min(n[1], e, i), n[2] = Math.max(n[2], t, s), n[3] = Math.max(n[3], e, i);
  }
  static #t(t, e, s, i, n, r, a, o, l, c) {
    if (l <= 0 || l >= 1)
      return;
    const d = 1 - l, u = l * l, f = u * l, g = d * (d * (d * t + 3 * l * e) + 3 * u * s) + f * i, p = d * (d * (d * n + 3 * l * r) + 3 * u * a) + f * o;
    c[0] = Math.min(c[0], g), c[1] = Math.min(c[1], p), c[2] = Math.max(c[2], g), c[3] = Math.max(c[3], p);
  }
  static #e(t, e, s, i, n, r, a, o, l, c, d, u) {
    if (Math.abs(l) < 1e-12) {
      Math.abs(c) >= 1e-12 && this.#t(t, e, s, i, n, r, a, o, -d / c, u);
      return;
    }
    const f = c ** 2 - 4 * d * l;
    if (f < 0)
      return;
    const g = Math.sqrt(f), p = 2 * l;
    this.#t(t, e, s, i, n, r, a, o, (-c + g) / p, u), this.#t(t, e, s, i, n, r, a, o, (-c - g) / p, u);
  }
  static bezierBoundingBox(t, e, s, i, n, r, a, o, l) {
    l[0] = Math.min(l[0], t, a), l[1] = Math.min(l[1], e, o), l[2] = Math.max(l[2], t, a), l[3] = Math.max(l[3], e, o), this.#e(t, s, n, a, e, i, r, o, 3 * (-t + 3 * (s - n) + a), 6 * (t - 2 * s + n), 3 * (s - t), l), this.#e(t, s, n, a, e, i, r, o, 3 * (-e + 3 * (i - r) + o), 6 * (e - 2 * i + r), 3 * (i - e), l);
  }
}
function kn(h) {
  return decodeURIComponent(escape(h));
}
let Ps = null, pi = null;
function Vi(h) {
  return Ps || (Ps = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, pi = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), h.replaceAll(Ps, (t, e, s) => e ? e.normalize("NFKC") : pi.get(s));
}
function Gs() {
  if (typeof crypto.randomUUID == "function")
    return crypto.randomUUID();
  const h = new Uint8Array(32);
  return crypto.getRandomValues(h), zi(h);
}
const Ws = "pdfjs_internal_id_";
function Fn(h, t, e) {
  if (!Array.isArray(e) || e.length < 2)
    return !1;
  const [s, i, ...n] = e;
  if (!h(s) && !Number.isInteger(s) || !t(i))
    return !1;
  const r = n.length;
  let a = !0;
  switch (i.name) {
    case "XYZ":
      if (r < 2 || r > 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return r === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (r > 1)
        return !1;
      break;
    case "FitR":
      if (r !== 4)
        return !1;
      a = !1;
      break;
    default:
      return !1;
  }
  for (const o of n)
    if (!(typeof o == "number" || a && o === null))
      return !1;
  return !0;
}
function Ct(h, t, e) {
  return Math.min(Math.max(h, t), e);
}
function Gi(h) {
  return Uint8Array.prototype.toBase64 ? h.toBase64() : btoa(zi(h));
}
function Nn(h) {
  return Uint8Array.fromBase64 ? Uint8Array.fromBase64(h) : Ge(atob(h));
}
typeof Math.sumPrecise != "function" && (Math.sumPrecise = function(h) {
  return h.reduce((t, e) => t + e, 0);
});
typeof AbortSignal.any != "function" && (AbortSignal.any = function(h) {
  const t = new AbortController(), {
    signal: e
  } = t;
  for (const s of h)
    if (s.aborted)
      return t.abort(s.reason), e;
  for (const s of h)
    s.addEventListener("abort", () => {
      t.abort(s.reason);
    }, {
      signal: e
    });
  return e;
});
W(1701);
W(4603);
W(7566);
W(8721);
class je {
  static textContent(t) {
    const e = [], s = {
      items: e,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(n) {
      if (!n)
        return;
      let r = null;
      const a = n.name;
      if (a === "#text")
        r = n.value;
      else if (je.shouldBuildText(a))
        n?.attributes?.textContent ? r = n.attributes.textContent : n.value && (r = n.value);
      else return;
      if (r !== null && e.push({
        str: r
      }), !!n.children)
        for (const o of n.children)
          i(o);
    }
    return i(t), s;
  }
  static shouldBuildText(t) {
    return !(t === "textarea" || t === "input" || t === "option" || t === "select");
  }
}
class Xs {
  static setupStorage(t, e, s, i, n) {
    const r = i.getValue(e, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (r.value !== null && (t.textContent = r.value), n === "print")
          break;
        t.addEventListener("input", (a) => {
          i.setValue(e, {
            value: a.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (r.value === s.attributes.xfaOn ? t.setAttribute("checked", !0) : r.value === s.attributes.xfaOff && t.removeAttribute("checked"), n === "print")
            break;
          t.addEventListener("change", (a) => {
            i.setValue(e, {
              value: a.target.checked ? a.target.getAttribute("xfaOn") : a.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (r.value !== null && t.setAttribute("value", r.value), n === "print")
            break;
          t.addEventListener("input", (a) => {
            i.setValue(e, {
              value: a.target.value
            });
          });
        }
        break;
      case "select":
        if (r.value !== null) {
          t.setAttribute("value", r.value);
          for (const a of s.children)
            a.attributes.value === r.value ? a.attributes.selected = !0 : a.attributes.hasOwnProperty("selected") && delete a.attributes.selected;
        }
        t.addEventListener("input", (a) => {
          const o = a.target.options, l = o.selectedIndex === -1 ? "" : o[o.selectedIndex].value;
          i.setValue(e, {
            value: l
          });
        });
        break;
    }
  }
  static setAttributes({
    html: t,
    element: e,
    storage: s = null,
    intent: i,
    linkService: n
  }) {
    const {
      attributes: r
    } = e, a = t instanceof HTMLAnchorElement;
    r.type === "radio" && (r.name = `${r.name}-${i}`);
    for (const [o, l] of Object.entries(r))
      if (l != null)
        switch (o) {
          case "class":
            l.length && t.setAttribute(o, l.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            t.setAttribute("data-element-id", l);
            break;
          case "style":
            Object.assign(t.style, l);
            break;
          case "textContent":
            t.textContent = l;
            break;
          default:
            (!a || o !== "href" && o !== "newWindow") && t.setAttribute(o, l);
        }
    a && n.addLinkAttributes(t, r.href, r.newWindow), s && r.dataId && this.setupStorage(t, r.dataId, e, s);
  }
  static render(t) {
    const e = t.annotationStorage, s = t.linkService, i = t.xfaHtml, n = t.intent || "display", r = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: r,
      element: i,
      intent: n,
      linkService: s
    });
    const a = n !== "richText", o = t.div;
    if (o.append(r), t.viewport) {
      const d = `matrix(${t.viewport.transform.join(",")})`;
      o.style.transform = d;
    }
    a && o.setAttribute("class", "xfaLayer xfaFont");
    const l = [];
    if (i.children.length === 0) {
      if (i.value) {
        const d = document.createTextNode(i.value);
        r.append(d), a && je.shouldBuildText(i.name) && l.push(d);
      }
      return {
        textDivs: l
      };
    }
    const c = [[i, -1, r]];
    for (; c.length > 0; ) {
      const [d, u, f] = c.at(-1);
      if (u + 1 === d.children.length) {
        c.pop();
        continue;
      }
      const g = d.children[++c.at(-1)[1]];
      if (g === null)
        continue;
      const {
        name: p
      } = g;
      if (p === "#text") {
        const m = document.createTextNode(g.value);
        l.push(m), f.append(m);
        continue;
      }
      const v = g?.attributes?.xmlns ? document.createElementNS(g.attributes.xmlns, p) : document.createElement(p);
      if (f.append(v), g.attributes && this.setAttributes({
        html: v,
        element: g,
        storage: e,
        intent: n,
        linkService: s
      }), g.children?.length > 0)
        c.push([g, -1, v]);
      else if (g.value) {
        const m = document.createTextNode(g.value);
        a && je.shouldBuildText(p) && l.push(m), v.append(m);
      }
    }
    for (const d of o.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      d.setAttribute("readOnly", !0);
    return {
      textDivs: l
    };
  }
  static update(t) {
    const e = `matrix(${t.viewport.transform.join(",")})`;
    t.div.style.transform = e, t.div.hidden = !1;
  }
}
const qt = "http://www.w3.org/2000/svg";
class fe {
  static CSS = 96;
  static PDF = 72;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}
async function Me(h, t = "text") {
  if (Ne(h, document.baseURI)) {
    const e = await fetch(h);
    if (!e.ok)
      throw new Error(e.statusText);
    switch (t) {
      case "arraybuffer":
        return e.arrayBuffer();
      case "blob":
        return e.blob();
      case "json":
        return e.json();
    }
    return e.text();
  }
  return new Promise((e, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", h, !0), i.responseType = t, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (t) {
            case "arraybuffer":
            case "blob":
            case "json":
              e(i.response);
              return;
          }
          e(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class We {
  constructor({
    viewBox: t,
    userUnit: e,
    scale: s,
    rotation: i,
    offsetX: n = 0,
    offsetY: r = 0,
    dontFlip: a = !1
  }) {
    this.viewBox = t, this.userUnit = e, this.scale = s, this.rotation = i, this.offsetX = n, this.offsetY = r, s *= e;
    const o = (t[2] + t[0]) / 2, l = (t[3] + t[1]) / 2;
    let c, d, u, f;
    switch (i %= 360, i < 0 && (i += 360), i) {
      case 180:
        c = -1, d = 0, u = 0, f = 1;
        break;
      case 90:
        c = 0, d = 1, u = 1, f = 0;
        break;
      case 270:
        c = 0, d = -1, u = -1, f = 0;
        break;
      case 0:
        c = 1, d = 0, u = 0, f = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    a && (u = -u, f = -f);
    let g, p, v, m;
    c === 0 ? (g = Math.abs(l - t[1]) * s + n, p = Math.abs(o - t[0]) * s + r, v = (t[3] - t[1]) * s, m = (t[2] - t[0]) * s) : (g = Math.abs(o - t[0]) * s + n, p = Math.abs(l - t[1]) * s + r, v = (t[2] - t[0]) * s, m = (t[3] - t[1]) * s), this.transform = [c * s, d * s, u * s, f * s, g - c * s * o - u * s * l, p - d * s * o - f * s * l], this.width = v, this.height = m;
  }
  get rawDims() {
    const t = this.viewBox;
    return K(this, "rawDims", {
      pageWidth: t[2] - t[0],
      pageHeight: t[3] - t[1],
      pageX: t[0],
      pageY: t[1]
    });
  }
  clone({
    scale: t = this.scale,
    rotation: e = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: n = !1
  } = {}) {
    return new We({
      viewBox: this.viewBox.slice(),
      userUnit: this.userUnit,
      scale: t,
      rotation: e,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  convertToViewportPoint(t, e) {
    const s = [t, e];
    return B.applyTransform(s, this.transform), s;
  }
  convertToViewportRectangle(t) {
    const e = [t[0], t[1]];
    B.applyTransform(e, this.transform);
    const s = [t[2], t[3]];
    return B.applyTransform(s, this.transform), [e[0], e[1], s[0], s[1]];
  }
  convertToPdfPoint(t, e) {
    const s = [t, e];
    return B.applyInverseTransform(s, this.transform), s;
  }
}
class vs extends ge {
  constructor(t, e = 0) {
    super(t, "RenderingCancelledException"), this.extraDelay = e;
  }
}
function Xe(h) {
  const t = h.length;
  let e = 0;
  for (; e < t && h[e].trim() === ""; )
    e++;
  return h.substring(e, e + 5).toLowerCase() === "data:";
}
function ys(h) {
  return typeof h == "string" && /\.pdf$/i.test(h);
}
function Wi(h) {
  return [h] = h.split(/[#?]/, 1), h.substring(h.lastIndexOf("/") + 1);
}
function Xi(h, t = "document.pdf") {
  if (typeof h != "string")
    return t;
  if (Xe(h))
    return z('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t;
  const s = ((a) => {
    try {
      return new URL(a);
    } catch {
      try {
        return new URL(decodeURIComponent(a));
      } catch {
        try {
          return new URL(a, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(a), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  })(h);
  if (!s)
    return t;
  const i = (a) => {
    try {
      let o = decodeURIComponent(a);
      return o.includes("/") ? (o = o.split("/").at(-1), o.test(/^\.pdf$/i) ? o : a) : o;
    } catch {
      return a;
    }
  }, n = /\.pdf$/i, r = s.pathname.split("/").at(-1);
  if (n.test(r))
    return i(r);
  if (s.searchParams.size > 0) {
    const a = Array.from(s.searchParams.values()).reverse();
    for (const l of a)
      if (n.test(l))
        return i(l);
    const o = Array.from(s.searchParams.keys()).reverse();
    for (const l of o)
      if (n.test(l))
        return i(l);
  }
  if (s.hash) {
    const o = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i.exec(s.hash);
    if (o)
      return i(o[0]);
  }
  return t;
}
class gi {
  started = /* @__PURE__ */ Object.create(null);
  times = [];
  time(t) {
    t in this.started && z(`Timer is already running for ${t}`), this.started[t] = Date.now();
  }
  timeEnd(t) {
    t in this.started || z(`Timer has not been started for ${t}`), this.times.push({
      name: t,
      start: this.started[t],
      end: Date.now()
    }), delete this.started[t];
  }
  toString() {
    const t = [];
    let e = 0;
    for (const {
      name: s
    } of this.times)
      e = Math.max(s.length, e);
    for (const {
      name: s,
      start: i,
      end: n
    } of this.times)
      t.push(`${s.padEnd(e)} ${n - i}ms
`);
    return t.join("");
  }
}
function Ne(h, t) {
  const e = t ? URL.parse(h, t) : URL.parse(h);
  return e?.protocol === "http:" || e?.protocol === "https:";
}
function Bt(h) {
  h.preventDefault();
}
function ct(h) {
  h.preventDefault(), h.stopPropagation();
}
function Bn(h) {
  console.log("Deprecated API usage: " + h);
}
class Pe {
  static #t;
  static toDateObject(t) {
    if (t instanceof Date)
      return t;
    if (!t || typeof t != "string")
      return null;
    this.#t ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
    const e = this.#t.exec(t);
    if (!e)
      return null;
    const s = parseInt(e[1], 10);
    let i = parseInt(e[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let n = parseInt(e[3], 10);
    n = n >= 1 && n <= 31 ? n : 1;
    let r = parseInt(e[4], 10);
    r = r >= 0 && r <= 23 ? r : 0;
    let a = parseInt(e[5], 10);
    a = a >= 0 && a <= 59 ? a : 0;
    let o = parseInt(e[6], 10);
    o = o >= 0 && o <= 59 ? o : 0;
    const l = e[7] || "Z";
    let c = parseInt(e[8], 10);
    c = c >= 0 && c <= 23 ? c : 0;
    let d = parseInt(e[9], 10) || 0;
    return d = d >= 0 && d <= 59 ? d : 0, l === "-" ? (r += c, a += d) : l === "+" && (r -= c, a -= d), new Date(Date.UTC(s, i, n, r, a, o));
  }
}
function Yi(h, {
  scale: t = 1,
  rotation: e = 0
}) {
  const {
    width: s,
    height: i
  } = h.attributes.style, n = [0, 0, parseInt(s), parseInt(i)];
  return new We({
    viewBox: n,
    userUnit: 1,
    scale: t,
    rotation: e
  });
}
function De(h) {
  if (h.startsWith("#")) {
    const t = parseInt(h.slice(1), 16);
    return [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255];
  }
  return h.startsWith("rgb(") ? h.slice(4, -1).split(",").map((t) => parseInt(t)) : h.startsWith("rgba(") ? h.slice(5, -1).split(",").map((t) => parseInt(t)).slice(0, 3) : (z(`Not a valid color format: "${h}"`), [0, 0, 0]);
}
function _n(h) {
  const t = document.createElement("span");
  t.style.visibility = "hidden", t.style.colorScheme = "only light", document.body.append(t);
  for (const e of h.keys()) {
    t.style.color = e;
    const s = window.getComputedStyle(t).color;
    h.set(e, De(s));
  }
  t.remove();
}
function ht(h) {
  const {
    a: t,
    b: e,
    c: s,
    d: i,
    e: n,
    f: r
  } = h.getTransform();
  return [t, e, s, i, n, r];
}
function Yt(h) {
  const {
    a: t,
    b: e,
    c: s,
    d: i,
    e: n,
    f: r
  } = h.getTransform().invertSelf();
  return [t, e, s, i, n, r];
}
function ae(h, t, e = !1, s = !0) {
  if (t instanceof We) {
    const {
      pageWidth: i,
      pageHeight: n
    } = t.rawDims, {
      style: r
    } = h, a = wt.isCSSRoundSupported, o = `var(--total-scale-factor) * ${i}px`, l = `var(--total-scale-factor) * ${n}px`, c = a ? `round(down, ${o}, var(--scale-round-x))` : `calc(${o})`, d = a ? `round(down, ${l}, var(--scale-round-y))` : `calc(${l})`;
    !e || t.rotation % 180 === 0 ? (r.width = c, r.height = d) : (r.width = d, r.height = c);
  }
  s && h.setAttribute("data-main-rotation", t.rotation);
}
class Gt {
  constructor() {
    const {
      pixelRatio: t
    } = Gt;
    this.sx = t, this.sy = t;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(t, e, s, i, n = -1) {
    let r = 1 / 0, a = 1 / 0, o = 1 / 0;
    s = Gt.capPixels(s, n), s > 0 && (r = Math.sqrt(s / (t * e))), i !== -1 && (a = i / t, o = i / e);
    const l = Math.min(r, a, o);
    return this.sx > l || this.sy > l ? (this.sx = l, this.sy = l, !0) : !1;
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(t, e) {
    if (e >= 0) {
      const s = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + e / 100));
      return t > 0 ? Math.min(t, s) : s;
    }
    return t;
  }
}
const us = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
class Un {
  static get isDarkMode() {
    return K(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
  }
}
class Ki {
  static get commentForegroundColor() {
    const t = document.createElement("span");
    t.classList.add("comment", "sidebar");
    const {
      style: e
    } = t;
    e.width = e.height = "0", e.display = "none", e.color = "var(--comment-fg-color)", document.body.append(t);
    const {
      color: s
    } = window.getComputedStyle(t);
    return t.remove(), K(this, "commentForegroundColor", De(s));
  }
}
function Ji(h, t, e, s) {
  s = Math.min(Math.max(s ?? 1, 0), 1);
  const i = 255 * (1 - s);
  return h = Math.round(h * s + i), t = Math.round(t * s + i), e = Math.round(e * s + i), [h, t, e];
}
function mi(h, t) {
  const e = h[0] / 255, s = h[1] / 255, i = h[2] / 255, n = Math.max(e, s, i), r = Math.min(e, s, i), a = (n + r) / 2;
  if (n === r)
    t[0] = t[1] = 0;
  else {
    const o = n - r;
    switch (t[1] = a < 0.5 ? o / (n + r) : o / (2 - n - r), n) {
      case e:
        t[0] = ((s - i) / o + (s < i ? 6 : 0)) * 60;
        break;
      case s:
        t[0] = ((i - e) / o + 2) * 60;
        break;
      case i:
        t[0] = ((e - s) / o + 4) * 60;
        break;
    }
  }
  t[2] = a;
}
function ks(h, t) {
  const e = h[0], s = h[1], i = h[2], n = (1 - Math.abs(2 * i - 1)) * s, r = n * (1 - Math.abs(e / 60 % 2 - 1)), a = i - n / 2;
  switch (Math.floor(e / 60)) {
    case 0:
      t[0] = n + a, t[1] = r + a, t[2] = a;
      break;
    case 1:
      t[0] = r + a, t[1] = n + a, t[2] = a;
      break;
    case 2:
      t[0] = a, t[1] = n + a, t[2] = r + a;
      break;
    case 3:
      t[0] = a, t[1] = r + a, t[2] = n + a;
      break;
    case 4:
      t[0] = r + a, t[1] = a, t[2] = n + a;
      break;
    case 5:
    case 6:
      t[0] = n + a, t[1] = a, t[2] = r + a;
      break;
  }
}
function vi(h) {
  return h <= 0.03928 ? h / 12.92 : ((h + 0.055) / 1.055) ** 2.4;
}
function yi(h, t, e) {
  ks(h, e), e.map(vi);
  const s = 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
  ks(t, e), e.map(vi);
  const i = 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
  return s > i ? (s + 0.05) / (i + 0.05) : (i + 0.05) / (s + 0.05);
}
const bi = /* @__PURE__ */ new Map();
function Qi(h, t) {
  const e = h[0] + h[1] * 256 + h[2] * 65536 + t[0] * 16777216 + t[1] * 4294967296 + t[2] * 1099511627776;
  let s = bi.get(e);
  if (s)
    return s;
  const i = new Float32Array(9), n = i.subarray(0, 3), r = i.subarray(3, 6);
  mi(h, r);
  const a = i.subarray(6, 9);
  mi(t, a);
  const o = a[2] < 0.5, l = o ? 12 : 4.5;
  if (r[2] = o ? Math.sqrt(r[2]) : 1 - Math.sqrt(1 - r[2]), yi(r, a, n) < l) {
    let c, d;
    o ? (c = r[2], d = 1) : (c = 0, d = r[2]);
    const u = 5e-3;
    for (; d - c > u; ) {
      const f = r[2] = (c + d) / 2;
      o === yi(r, a, n) < l ? c = f : d = f;
    }
    r[2] = o ? d : c;
  }
  return ks(r, n), s = B.makeHexColor(Math.round(n[0] * 255), Math.round(n[1] * 255), Math.round(n[2] * 255)), bi.set(e, s), s;
}
function Ys({
  html: h,
  dir: t,
  className: e
}, s) {
  const i = document.createDocumentFragment();
  if (typeof h == "string") {
    const n = document.createElement("p");
    n.dir = t || "auto";
    const r = h.split(/(?:\r\n?|\n)/);
    for (let a = 0, o = r.length; a < o; ++a) {
      const l = r[a];
      n.append(document.createTextNode(l)), a < o - 1 && n.append(document.createElement("br"));
    }
    i.append(n);
  } else
    Xs.render({
      xfaHtml: h,
      div: i,
      intent: "richText"
    });
  i.firstChild.classList.add("richText", e), s.append(i);
}
W(4972);
W(4628);
W(7642);
W(8004);
W(3853);
W(5876);
W(2475);
W(5024);
W(1698);
W(9314);
W(1148);
W(3579);
W(8335);
class Ue {
  #t = null;
  #e = null;
  #i;
  #s = null;
  #a = null;
  #n = null;
  #r = null;
  #o = null;
  static #h = null;
  constructor(t) {
    this.#i = t, Ue.#h ||= Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button",
      signature: "pdfjs-editor-remove-signature-button"
    });
  }
  render() {
    const t = this.#t = document.createElement("div");
    t.classList.add("editToolbar", "hidden"), t.setAttribute("role", "toolbar");
    const e = this.#i._uiManager._signal;
    e instanceof AbortSignal && !e.aborted && (t.addEventListener("contextmenu", Bt, {
      signal: e
    }), t.addEventListener("pointerdown", Ue.#l, {
      signal: e
    }));
    const s = this.#s = document.createElement("div");
    s.className = "buttons", t.append(s);
    const i = this.#i.toolbarPosition;
    if (i) {
      const {
        style: n
      } = t, r = this.#i._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      n.insetInlineEnd = `${100 * r}%`, n.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return t;
  }
  get div() {
    return this.#t;
  }
  static #l(t) {
    t.stopPropagation();
  }
  #u(t) {
    this.#i._focusEventsAllowed = !1, ct(t);
  }
  #d(t) {
    this.#i._focusEventsAllowed = !0, ct(t);
  }
  #f(t) {
    const e = this.#i._uiManager._signal;
    return !(e instanceof AbortSignal) || e.aborted ? !1 : (t.addEventListener("focusin", this.#u.bind(this), {
      capture: !0,
      signal: e
    }), t.addEventListener("focusout", this.#d.bind(this), {
      capture: !0,
      signal: e
    }), t.addEventListener("contextmenu", Bt, {
      signal: e
    }), !0);
  }
  hide() {
    this.#t.classList.add("hidden"), this.#e?.hideDropdown();
  }
  show() {
    this.#t.classList.remove("hidden"), this.#a?.shown(), this.#n?.shown();
  }
  addDeleteButton() {
    const {
      editorType: t,
      _uiManager: e
    } = this.#i, s = document.createElement("button");
    s.classList.add("basic", "deleteButton"), s.tabIndex = 0, s.setAttribute("data-l10n-id", Ue.#h[t]), this.#f(s) && s.addEventListener("click", (i) => {
      e.delete();
    }, {
      signal: e._signal
    }), this.#s.append(s);
  }
  get #m() {
    const t = document.createElement("div");
    return t.className = "divider", t;
  }
  async addAltText(t) {
    const e = await t.render();
    this.#f(e), this.#s.append(e, this.#m), this.#a = t;
  }
  addComment(t, e = null) {
    if (this.#n)
      return;
    const s = t.renderForToolbar();
    if (!s)
      return;
    this.#f(s);
    const i = this.#r = this.#m;
    e ? (this.#s.insertBefore(s, e), this.#s.insertBefore(i, e)) : this.#s.append(s, i), this.#n = t, t.toolbar = this;
  }
  addColorPicker(t) {
    if (this.#e)
      return;
    this.#e = t;
    const e = t.renderButton();
    this.#f(e), this.#s.append(e, this.#m);
  }
  async addEditSignatureButton(t) {
    const e = this.#o = await t.renderEditButton(this.#i);
    this.#f(e), this.#s.append(e, this.#m);
  }
  removeButton(t) {
    switch (t) {
      case "comment":
        this.#n?.removeToolbarCommentButton(), this.#n = null, this.#r?.remove(), this.#r = null;
        break;
    }
  }
  async addButton(t, e) {
    switch (t) {
      case "colorPicker":
        this.addColorPicker(e);
        break;
      case "altText":
        await this.addAltText(e);
        break;
      case "editSignature":
        await this.addEditSignatureButton(e);
        break;
      case "delete":
        this.addDeleteButton();
        break;
      case "comment":
        this.addComment(e);
        break;
    }
  }
  async addButtonBefore(t, e, s) {
    const i = this.#s.querySelector(s);
    i && t === "comment" && this.addComment(e, i);
  }
  updateEditSignatureButton(t) {
    this.#o && (this.#o.title = t);
  }
  remove() {
    this.#t.remove(), this.#e?.destroy(), this.#e = null;
  }
}
class Hn {
  #t = null;
  #e = null;
  #i;
  constructor(t) {
    this.#i = t;
  }
  #s() {
    const t = this.#e = document.createElement("div");
    t.className = "editToolbar", t.setAttribute("role", "toolbar");
    const e = this.#i._signal;
    e instanceof AbortSignal && !e.aborted && t.addEventListener("contextmenu", Bt, {
      signal: e
    });
    const s = this.#t = document.createElement("div");
    return s.className = "buttons", t.append(s), this.#i.hasCommentManager() && this.#n("commentButton", "pdfjs-comment-floating-button", "pdfjs-comment-floating-button-label", () => {
      this.#i.commentSelection("floating_button");
    }), this.#n("highlightButton", "pdfjs-highlight-floating-button1", "pdfjs-highlight-floating-button-label", () => {
      this.#i.highlightSelection("floating_button");
    }), t;
  }
  #a(t, e) {
    let s = 0, i = 0;
    for (const n of t) {
      const r = n.y + n.height;
      if (r < s)
        continue;
      const a = n.x + (e ? n.width : 0);
      if (r > s) {
        i = a, s = r;
        continue;
      }
      e ? a > i && (i = a) : a < i && (i = a);
    }
    return [e ? 1 - i : i, s];
  }
  show(t, e, s) {
    const [i, n] = this.#a(e, s), {
      style: r
    } = this.#e ||= this.#s();
    t.append(this.#e), r.insetInlineEnd = `${100 * i}%`, r.top = `calc(${100 * n}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    this.#e.remove();
  }
  #n(t, e, s, i) {
    const n = document.createElement("button");
    n.classList.add("basic", t), n.tabIndex = 0, n.setAttribute("data-l10n-id", e);
    const r = document.createElement("span");
    n.append(r), r.className = "visuallyHidden", r.setAttribute("data-l10n-id", s);
    const a = this.#i._signal;
    a instanceof AbortSignal && !a.aborted && (n.addEventListener("contextmenu", Bt, {
      signal: a
    }), n.addEventListener("click", i, {
      signal: a
    })), this.#t.append(n);
  }
}
function Zi(h, t, e) {
  for (const s of e)
    t.addEventListener(s, h[s].bind(h));
}
class $n {
  #t = 0;
  get id() {
    return `${He}${this.#t++}`;
  }
}
class Ks {
  #t = Gs();
  #e = 0;
  #i = null;
  static get _isSVGFittingCanvas() {
    const t = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = t;
    const n = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return K(this, "_isSVGFittingCanvas", n);
  }
  async #s(t, e) {
    this.#i ||= /* @__PURE__ */ new Map();
    let s = this.#i.get(t);
    if (s === null)
      return null;
    if (s?.bitmap)
      return s.refCounter += 1, s;
    try {
      s ||= {
        bitmap: null,
        id: `image_${this.#t}_${this.#e++}`,
        refCounter: 0,
        isSvg: !1
      };
      let i;
      if (typeof e == "string" ? (s.url = e, i = await Me(e, "blob")) : e instanceof File ? i = s.file = e : e instanceof Blob && (i = e), i.type === "image/svg+xml") {
        const n = Ks._isSVGFittingCanvas, r = new FileReader(), a = new Image(), o = new Promise((l, c) => {
          a.onload = () => {
            s.bitmap = a, s.isSvg = !0, l();
          }, r.onload = async () => {
            const d = s.svgUrl = r.result;
            a.src = await n ? `${d}#svgView(preserveAspectRatio(none))` : d;
          }, a.onerror = r.onerror = c;
        });
        r.readAsDataURL(i), await o;
      } else
        s.bitmap = await createImageBitmap(i);
      s.refCounter = 1;
    } catch (i) {
      z(i), s = null;
    }
    return this.#i.set(t, s), s && this.#i.set(s.id, s), s;
  }
  async getFromFile(t) {
    const {
      lastModified: e,
      name: s,
      size: i,
      type: n
    } = t;
    return this.#s(`${e}_${s}_${i}_${n}`, t);
  }
  async getFromUrl(t) {
    return this.#s(t, t);
  }
  async getFromBlob(t, e) {
    const s = await e;
    return this.#s(t, s);
  }
  async getFromId(t) {
    this.#i ||= /* @__PURE__ */ new Map();
    const e = this.#i.get(t);
    if (!e)
      return null;
    if (e.bitmap)
      return e.refCounter += 1, e;
    if (e.file)
      return this.getFromFile(e.file);
    if (e.blobPromise) {
      const {
        blobPromise: s
      } = e;
      return delete e.blobPromise, this.getFromBlob(e.id, s);
    }
    return this.getFromUrl(e.url);
  }
  getFromCanvas(t, e) {
    this.#i ||= /* @__PURE__ */ new Map();
    let s = this.#i.get(t);
    if (s?.bitmap)
      return s.refCounter += 1, s;
    const i = new OffscreenCanvas(e.width, e.height);
    return i.getContext("2d").drawImage(e, 0, 0), s = {
      bitmap: i.transferToImageBitmap(),
      id: `image_${this.#t}_${this.#e++}`,
      refCounter: 1,
      isSvg: !1
    }, this.#i.set(t, s), this.#i.set(s.id, s), s;
  }
  getSvgUrl(t) {
    const e = this.#i.get(t);
    return e?.isSvg ? e.svgUrl : null;
  }
  deleteId(t) {
    this.#i ||= /* @__PURE__ */ new Map();
    const e = this.#i.get(t);
    if (!e || (e.refCounter -= 1, e.refCounter !== 0))
      return;
    const {
      bitmap: s
    } = e;
    if (!e.url && !e.file) {
      const i = new OffscreenCanvas(s.width, s.height);
      i.getContext("bitmaprenderer").transferFromImageBitmap(s), e.blobPromise = i.convertToBlob();
    }
    s.close?.(), e.bitmap = null;
  }
  isValidId(t) {
    return t.startsWith(`image_${this.#t}_`);
  }
}
class jn {
  #t = [];
  #e = !1;
  #i;
  #s = -1;
  constructor(t = 128) {
    this.#i = t;
  }
  add({
    cmd: t,
    undo: e,
    post: s,
    mustExec: i,
    type: n = NaN,
    overwriteIfSameType: r = !1,
    keepUndo: a = !1
  }) {
    if (i && t(), this.#e)
      return;
    const o = {
      cmd: t,
      undo: e,
      post: s,
      type: n
    };
    if (this.#s === -1) {
      this.#t.length > 0 && (this.#t.length = 0), this.#s = 0, this.#t.push(o);
      return;
    }
    if (r && this.#t[this.#s].type === n) {
      a && (o.undo = this.#t[this.#s].undo), this.#t[this.#s] = o;
      return;
    }
    const l = this.#s + 1;
    l === this.#i ? this.#t.splice(0, 1) : (this.#s = l, l < this.#t.length && this.#t.splice(l)), this.#t.push(o);
  }
  undo() {
    if (this.#s === -1)
      return;
    this.#e = !0;
    const {
      undo: t,
      post: e
    } = this.#t[this.#s];
    t(), e?.(), this.#e = !1, this.#s -= 1;
  }
  redo() {
    if (this.#s < this.#t.length - 1) {
      this.#s += 1, this.#e = !0;
      const {
        cmd: t,
        post: e
      } = this.#t[this.#s];
      t(), e?.(), this.#e = !1;
    }
  }
  hasSomethingToUndo() {
    return this.#s !== -1;
  }
  hasSomethingToRedo() {
    return this.#s < this.#t.length - 1;
  }
  cleanType(t) {
    if (this.#s !== -1) {
      for (let e = this.#s; e >= 0; e--)
        if (this.#t[e].type !== t) {
          this.#t.splice(e + 1, this.#s - e), this.#s = e;
          return;
        }
      this.#t.length = 0, this.#s = -1;
    }
  }
  destroy() {
    this.#t = null;
  }
}
class Ye {
  constructor(t) {
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: e
    } = wt.platform;
    for (const [s, i, n = {}] of t)
      for (const r of s) {
        const a = r.startsWith("mac+");
        e && a ? (this.callbacks.set(r.slice(4), {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1))) : !e && !a && (this.callbacks.set(r, {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1)));
      }
  }
  #t(t) {
    t.altKey && this.buffer.push("alt"), t.ctrlKey && this.buffer.push("ctrl"), t.metaKey && this.buffer.push("meta"), t.shiftKey && this.buffer.push("shift"), this.buffer.push(t.key);
    const e = this.buffer.join("+");
    return this.buffer.length = 0, e;
  }
  exec(t, e) {
    if (!this.allKeys.has(e.key))
      return;
    const s = this.callbacks.get(this.#t(e));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: n = !1,
        args: r = [],
        checker: a = null
      }
    } = s;
    a && !a(t, e) || (i.bind(t, ...r, e)(), n || ct(e));
  }
}
class Js {
  static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const t = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return _n(t), K(this, "_colors", t);
  }
  convert(t) {
    const e = De(t);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return e;
    for (const [s, i] of this._colors)
      if (i.every((n, r) => n === e[r]))
        return Js._colorsMapping.get(s);
    return e;
  }
  getHexCode(t) {
    const e = this._colors.get(t);
    return e ? B.makeHexColor(...e) : t;
  }
}
class ne {
  #t = new AbortController();
  #e = null;
  #i = null;
  #s = /* @__PURE__ */ new Map();
  #a = /* @__PURE__ */ new Map();
  #n = null;
  #r = null;
  #o = null;
  #h = new jn();
  #l = null;
  #u = null;
  #d = null;
  #f = 0;
  #m = /* @__PURE__ */ new Set();
  #p = null;
  #c = null;
  #g = /* @__PURE__ */ new Set();
  _editorUndoBar = null;
  #v = !1;
  #b = !1;
  #y = !1;
  #T = null;
  #S = null;
  #A = null;
  #P = null;
  #E = !1;
  #x = null;
  #M = new $n();
  #R = !1;
  #I = !1;
  #B = !1;
  #L = null;
  #k = null;
  #_ = null;
  #F = null;
  #V = null;
  #C = G.NONE;
  #w = /* @__PURE__ */ new Set();
  #O = null;
  #U = null;
  #$ = null;
  #X = null;
  #W = null;
  #Y = {
    isEditing: !1,
    isEmpty: !0,
    hasSomethingToUndo: !1,
    hasSomethingToRedo: !1,
    hasSelectedEditor: !1,
    hasSelectedText: !1
  };
  #j = [0, 0];
  #N = null;
  #G = null;
  #Z = null;
  #q = null;
  #H = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const t = ne.prototype, e = (r) => r.#G.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && r.hasSomethingToControl(), s = (r, {
      target: a
    }) => {
      if (a instanceof HTMLInputElement) {
        const {
          type: o
        } = a;
        return o !== "text" && o !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, n = this.TRANSLATE_BIG;
    return K(this, "_keyboardManager", new Ye([[["ctrl+a", "mac+meta+a"], t.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], t.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], t.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], t.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], t.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && r.#G.contains(a) && !r.isEnterHandled
    }], [[" ", "mac+ "], t.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && r.#G.contains(document.activeElement)
    }], [["Escape", "mac+Escape"], t.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], t.translateSelectedEditors, {
      args: [-i, 0],
      checker: e
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t.translateSelectedEditors, {
      args: [-n, 0],
      checker: e
    }], [["ArrowRight", "mac+ArrowRight"], t.translateSelectedEditors, {
      args: [i, 0],
      checker: e
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t.translateSelectedEditors, {
      args: [n, 0],
      checker: e
    }], [["ArrowUp", "mac+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -i],
      checker: e
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -n],
      checker: e
    }], [["ArrowDown", "mac+ArrowDown"], t.translateSelectedEditors, {
      args: [0, i],
      checker: e
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t.translateSelectedEditors, {
      args: [0, n],
      checker: e
    }]]));
  }
  constructor(t, e, s, i, n, r, a, o, l, c, d, u, f, g, p, v) {
    const m = this._signal = this.#t.signal;
    this.#G = t, this.#Z = e, this.#q = s, this.#n = i, this.#l = n, this.#U = r, this.#W = o, this._eventBus = a, a._on("editingaction", this.onEditingAction.bind(this), {
      signal: m
    }), a._on("pagechanging", this.onPageChanging.bind(this), {
      signal: m
    }), a._on("scalechanging", this.onScaleChanging.bind(this), {
      signal: m
    }), a._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal: m
    }), a._on("setpreference", this.onSetPreference.bind(this), {
      signal: m
    }), a._on("switchannotationeditorparams", (b) => this.updateParams(b.type, b.value), {
      signal: m
    }), window.addEventListener("pointerdown", () => {
      this.#I = !0;
    }, {
      capture: !0,
      signal: m
    }), window.addEventListener("pointerup", () => {
      this.#I = !1;
    }, {
      capture: !0,
      signal: m
    }), this.#lt(), this.#ut(), this.#et(), this.#r = o.annotationStorage, this.#T = o.filterFactory, this.#$ = l, this.#P = c || null, this.#v = d, this.#b = u, this.#y = f, this.#V = g || null, this.viewParameters = {
      realScale: fe.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1, this._editorUndoBar = p || null, this._supportsPinchToZoom = v !== !1, n?.setSidebarUiManager(this);
  }
  destroy() {
    this.#H?.resolve(), this.#H = null, this.#t?.abort(), this.#t = null, this._signal = null;
    for (const t of this.#a.values())
      t.destroy();
    this.#a.clear(), this.#s.clear(), this.#g.clear(), this.#F?.clear(), this.#e = null, this.#w.clear(), this.#h.destroy(), this.#n?.destroy(), this.#l?.destroy(), this.#U?.destroy(), this.#x?.hide(), this.#x = null, this.#_?.destroy(), this.#_ = null, this.#i = null, this.#S && (clearTimeout(this.#S), this.#S = null), this.#N && (clearTimeout(this.#N), this.#N = null), this._editorUndoBar?.destroy(), this.#W = null;
  }
  combinedSignal(t) {
    return AbortSignal.any([this._signal, t.signal]);
  }
  get mlManager() {
    return this.#V;
  }
  get useNewAltTextFlow() {
    return this.#b;
  }
  get useNewAltTextWhenAddingImage() {
    return this.#y;
  }
  get hcmFilter() {
    return K(this, "hcmFilter", this.#$ ? this.#T.addHCMFilter(this.#$.foreground, this.#$.background) : "none");
  }
  get direction() {
    return K(this, "direction", getComputedStyle(this.#G).direction);
  }
  get _highlightColors() {
    return K(this, "_highlightColors", this.#P ? new Map(this.#P.split(",").map((t) => (t = t.split("=").map((e) => e.trim()), t[1] = t[1].toUpperCase(), t))) : null);
  }
  get highlightColors() {
    const {
      _highlightColors: t
    } = this;
    if (!t)
      return K(this, "highlightColors", null);
    const e = /* @__PURE__ */ new Map(), s = !!this.#$;
    for (const [i, n] of t) {
      const r = i.endsWith("_HCM");
      if (s && r) {
        e.set(i.replace("_HCM", ""), n);
        continue;
      }
      !s && !r && e.set(i, n);
    }
    return K(this, "highlightColors", e);
  }
  get highlightColorNames() {
    return K(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t) => t.reverse())) : null);
  }
  getNonHCMColor(t) {
    if (!this._highlightColors)
      return t;
    const e = this.highlightColorNames.get(t);
    return this._highlightColors.get(e) || t;
  }
  getNonHCMColorName(t) {
    return this.highlightColorNames.get(t) || t;
  }
  setCurrentDrawingSession(t) {
    t ? (this.unselectAll(), this.disableUserSelect(!0)) : this.disableUserSelect(!1), this.#d = t;
  }
  setMainHighlightColorPicker(t) {
    this.#_ = t;
  }
  editAltText(t, e = !1) {
    this.#n?.editAltText(this, t, e);
  }
  hasCommentManager() {
    return !!this.#l;
  }
  editComment(t, e, s, i) {
    this.#l?.showDialog(this, t, e, s, i);
  }
  selectComment(t, e) {
    this.#a.get(t)?.getEditorByUID(e)?.toggleComment(!0, !0);
  }
  updateComment(t) {
    this.#l?.updateComment(t.getData());
  }
  updatePopupColor(t) {
    this.#l?.updatePopupColor(t);
  }
  removeComment(t) {
    this.#l?.removeComments([t.uid]);
  }
  toggleComment(t, e, s = void 0) {
    this.#l?.toggleCommentPopup(t, e, s);
  }
  makeCommentColor(t, e) {
    return t && this.#l?.makeCommentColor(t, e) || null;
  }
  getCommentDialogElement() {
    return this.#l?.dialogElement || null;
  }
  async waitForEditorsRendered(t) {
    if (this.#a.has(t - 1))
      return;
    const {
      resolve: e,
      promise: s
    } = Promise.withResolvers(), i = (n) => {
      n.pageNumber === t && (this._eventBus._off("editorsrendered", i), e());
    };
    this._eventBus.on("editorsrendered", i), await s;
  }
  getSignature(t) {
    this.#U?.getSignature({
      uiManager: this,
      editor: t
    });
  }
  get signatureManager() {
    return this.#U;
  }
  switchToMode(t, e) {
    this._eventBus.on("annotationeditormodechanged", e, {
      once: !0,
      signal: this._signal
    }), this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode: t
    });
  }
  setPreference(t, e) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: t,
      value: e
    });
  }
  onSetPreference({
    name: t,
    value: e
  }) {
    switch (t) {
      case "enableNewAltTextWhenAddingImage":
        this.#y = e;
        break;
    }
  }
  onPageChanging({
    pageNumber: t
  }) {
    this.#f = t - 1;
  }
  focusMainContainer() {
    this.#G.focus();
  }
  findParent(t, e) {
    for (const s of this.#a.values()) {
      const {
        x: i,
        y: n,
        width: r,
        height: a
      } = s.div.getBoundingClientRect();
      if (t >= i && t <= i + r && e >= n && e <= n + a)
        return s;
    }
    return null;
  }
  disableUserSelect(t = !1) {
    this.#Z.classList.toggle("noUserSelect", t);
  }
  addShouldRescale(t) {
    this.#g.add(t);
  }
  removeShouldRescale(t) {
    this.#g.delete(t);
  }
  onScaleChanging({
    scale: t
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = t * fe.PDF_TO_CSS_UNITS;
    for (const e of this.#g)
      e.onScaleChanging();
    this.#d?.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: t
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = t;
  }
  #Q({
    anchorNode: t
  }) {
    return t.nodeType === Node.TEXT_NODE ? t.parentElement : t;
  }
  #tt(t) {
    const {
      currentLayer: e
    } = this;
    if (e.hasTextLayer(t))
      return e;
    for (const s of this.#a.values())
      if (s.hasTextLayer(t))
        return s;
    return null;
  }
  highlightSelection(t = "", e = !1) {
    const s = document.getSelection();
    if (!s || s.isCollapsed)
      return;
    const {
      anchorNode: i,
      anchorOffset: n,
      focusNode: r,
      focusOffset: a
    } = s, o = s.toString(), c = this.#Q(s).closest(".textLayer"), d = this.getSelectionBoxes(c);
    if (!d)
      return;
    s.empty();
    const u = this.#tt(c), f = this.#C === G.NONE, g = () => {
      const p = u?.createAndAddNewEditor({
        x: 0,
        y: 0
      }, !1, {
        methodOfCreation: t,
        boxes: d,
        anchorNode: i,
        anchorOffset: n,
        focusNode: r,
        focusOffset: a,
        text: o
      });
      f && this.showAllEditors("highlight", !0, !0), e && p?.editComment();
    };
    if (f) {
      this.switchToMode(G.HIGHLIGHT, g);
      return;
    }
    g();
  }
  commentSelection(t = "") {
    this.highlightSelection(t, !0);
  }
  #at() {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const s = this.#Q(t).closest(".textLayer"), i = this.getSelectionBoxes(s);
    i && (this.#x ||= new Hn(this), this.#x.show(s, i, this.direction === "ltr"));
  }
  getAndRemoveDataFromAnnotationStorage(t) {
    if (!this.#r)
      return null;
    const e = `${He}${t}`, s = this.#r.getRawValue(e);
    return s && this.#r.remove(e), s;
  }
  addToAnnotationStorage(t) {
    !t.isEmpty() && this.#r && !this.#r.has(t.id) && this.#r.setValue(t.id, t);
  }
  a11yAlert(t, e = null) {
    const s = this.#q;
    s && (s.setAttribute("data-l10n-id", t), e ? s.setAttribute("data-l10n-args", JSON.stringify(e)) : s.removeAttribute("data-l10n-args"));
  }
  #ot() {
    const t = document.getSelection();
    if (!t || t.isCollapsed) {
      this.#O && (this.#x?.hide(), this.#O = null, this.#D({
        hasSelectedText: !1
      }));
      return;
    }
    const {
      anchorNode: e
    } = t;
    if (e === this.#O)
      return;
    const i = this.#Q(t).closest(".textLayer");
    if (!i) {
      this.#O && (this.#x?.hide(), this.#O = null, this.#D({
        hasSelectedText: !1
      }));
      return;
    }
    if (this.#x?.hide(), this.#O = e, this.#D({
      hasSelectedText: !0
    }), !(this.#C !== G.HIGHLIGHT && this.#C !== G.NONE) && (this.#C === G.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), this.#E = this.isShiftKeyDown, !this.isShiftKeyDown)) {
      const n = this.#C === G.HIGHLIGHT ? this.#tt(i) : null;
      if (n?.toggleDrawing(), this.#I) {
        const r = new AbortController(), a = this.combinedSignal(r), o = (l) => {
          l.type === "pointerup" && l.button !== 0 || (r.abort(), n?.toggleDrawing(!0), l.type === "pointerup" && this.#K("main_toolbar"));
        };
        window.addEventListener("pointerup", o, {
          signal: a
        }), window.addEventListener("blur", o, {
          signal: a
        });
      } else
        n?.toggleDrawing(!0), this.#K("main_toolbar");
    }
  }
  #K(t = "") {
    this.#C === G.HIGHLIGHT ? this.highlightSelection(t) : this.#v && this.#at();
  }
  #lt() {
    document.addEventListener("selectionchange", this.#ot.bind(this), {
      signal: this._signal
    });
  }
  #ht() {
    if (this.#A)
      return;
    this.#A = new AbortController();
    const t = this.combinedSignal(this.#A);
    window.addEventListener("focus", this.focus.bind(this), {
      signal: t
    }), window.addEventListener("blur", this.blur.bind(this), {
      signal: t
    });
  }
  #ct() {
    this.#A?.abort(), this.#A = null;
  }
  blur() {
    if (this.isShiftKeyDown = !1, this.#E && (this.#E = !1, this.#K("main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: t
    } = document;
    for (const e of this.#w)
      if (e.div.contains(t)) {
        this.#k = [e, t], e._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!this.#k)
      return;
    const [t, e] = this.#k;
    this.#k = null, e.addEventListener("focusin", () => {
      t._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), e.focus();
  }
  #et() {
    if (this.#L)
      return;
    this.#L = new AbortController();
    const t = this.combinedSignal(this.#L);
    window.addEventListener("keydown", this.keydown.bind(this), {
      signal: t
    }), window.addEventListener("keyup", this.keyup.bind(this), {
      signal: t
    });
  }
  #dt() {
    this.#L?.abort(), this.#L = null;
  }
  #st() {
    if (this.#u)
      return;
    this.#u = new AbortController();
    const t = this.combinedSignal(this.#u);
    document.addEventListener("copy", this.copy.bind(this), {
      signal: t
    }), document.addEventListener("cut", this.cut.bind(this), {
      signal: t
    }), document.addEventListener("paste", this.paste.bind(this), {
      signal: t
    });
  }
  #it() {
    this.#u?.abort(), this.#u = null;
  }
  #ut() {
    const t = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), {
      signal: t
    }), document.addEventListener("drop", this.drop.bind(this), {
      signal: t
    });
  }
  addEditListeners() {
    this.#et(), this.#st();
  }
  removeEditListeners() {
    this.#dt(), this.#it();
  }
  dragOver(t) {
    for (const {
      type: e
    } of t.dataTransfer.items)
      for (const s of this.#c)
        if (s.isHandlingMimeForPasting(e)) {
          t.dataTransfer.dropEffect = "copy", t.preventDefault();
          return;
        }
  }
  drop(t) {
    for (const e of t.dataTransfer.items)
      for (const s of this.#c)
        if (s.isHandlingMimeForPasting(e.type)) {
          s.paste(e, this.currentLayer), t.preventDefault();
          return;
        }
  }
  copy(t) {
    if (t.preventDefault(), this.#e?.commitOrRemove(), !this.hasSelection)
      return;
    const e = [];
    for (const s of this.#w) {
      const i = s.serialize(!0);
      i && e.push(i);
    }
    e.length !== 0 && t.clipboardData.setData("application/pdfjs", JSON.stringify(e));
  }
  cut(t) {
    this.copy(t), this.delete();
  }
  async paste(t) {
    t.preventDefault();
    const {
      clipboardData: e
    } = t;
    for (const n of e.items)
      for (const r of this.#c)
        if (r.isHandlingMimeForPasting(n.type)) {
          r.paste(n, this.currentLayer);
          return;
        }
    let s = e.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (n) {
      z(`paste: "${n.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const n = [];
      for (const o of s) {
        const l = await i.deserialize(o);
        if (!l)
          return;
        n.push(l);
      }
      const r = () => {
        for (const o of n)
          this.#nt(o);
        this.#rt(n);
      }, a = () => {
        for (const o of n)
          o.remove();
      };
      this.addCommands({
        cmd: r,
        undo: a,
        mustExec: !0
      });
    } catch (n) {
      z(`paste: "${n.message}".`);
    }
  }
  keydown(t) {
    !this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !0), this.#C !== G.NONE && !this.isEditorHandlingKeyboard && ne._keyboardManager.exec(this, t);
  }
  keyup(t) {
    this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !1, this.#E && (this.#E = !1, this.#K("main_toolbar")));
  }
  onEditingAction({
    name: t
  }) {
    switch (t) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[t]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
      case "commentSelection":
        this.commentSelection("context_menu");
        break;
    }
  }
  #D(t) {
    Object.entries(t).some(([s, i]) => this.#Y[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
      source: this,
      details: Object.assign(this.#Y, t)
    }), this.#C === G.HIGHLIGHT && t.hasSelectedEditor === !1 && this.#z([[J.HIGHLIGHT_FREE, !0]]));
  }
  #z(t) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details: t
    });
  }
  setEditingState(t) {
    t ? (this.#ht(), this.#st(), this.#D({
      isEditing: this.#C !== G.NONE,
      isEmpty: this.#J(),
      hasSomethingToUndo: this.#h.hasSomethingToUndo(),
      hasSomethingToRedo: this.#h.hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (this.#ct(), this.#it(), this.#D({
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(t) {
    if (!this.#c) {
      this.#c = t;
      for (const e of this.#c)
        this.#z(e.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#M.id;
  }
  get currentLayer() {
    return this.#a.get(this.#f);
  }
  getLayer(t) {
    return this.#a.get(t);
  }
  get currentPageIndex() {
    return this.#f;
  }
  addLayer(t) {
    this.#a.set(t.pageIndex, t), this.#R ? t.enable() : t.disable();
  }
  removeLayer(t) {
    this.#a.delete(t.pageIndex);
  }
  async updateMode(t, e = null, s = !1, i = !1, n = !1) {
    if (this.#C !== t && !(this.#H && (await this.#H.promise, !this.#H))) {
      if (this.#H = Promise.withResolvers(), this.#d?.commitOrRemove(), this.#C === G.POPUP && this.#l?.hideSidebar(), this.#l?.destroyPopup(), this.#C = t, t === G.NONE) {
        this.setEditingState(!1), this.#pt();
        for (const r of this.#s.values())
          r.hideStandaloneCommentButton();
        this._editorUndoBar?.hide(), this.toggleComment(null), this.#H.resolve();
        return;
      }
      for (const r of this.#s.values())
        r.addStandaloneCommentButton();
      t === G.SIGNATURE && await this.#U?.loadSignatures(), this.setEditingState(!0), await this.#ft(), this.unselectAll();
      for (const r of this.#a.values())
        r.updateMode(t);
      if (t === G.POPUP) {
        this.#i ||= await this.#W.getAnnotationsByType(new Set(this.#c.map((o) => o._editorType)));
        const r = /* @__PURE__ */ new Set(), a = [];
        for (const o of this.#s.values()) {
          const {
            annotationElementId: l,
            hasComment: c,
            deleted: d
          } = o;
          l && r.add(l), c && !d && a.push(o.getData());
        }
        for (const o of this.#i) {
          const {
            id: l,
            popupRef: c,
            contentsObj: d
          } = o;
          c && d?.str && !r.has(l) && !this.#m.has(l) && a.push(o);
        }
        this.#l?.showSidebar(a);
      }
      if (!e) {
        s && this.addNewEditorFromKeyboard(), this.#H.resolve();
        return;
      }
      for (const r of this.#s.values())
        r.uid === e ? (this.setSelected(r), n ? r.editComment() : i ? r.enterInEditMode() : r.focus()) : r.unselect();
      this.#H.resolve();
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(t) {
    t.mode !== this.#C && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      ...t
    });
  }
  updateParams(t, e) {
    if (this.#c) {
      switch (t) {
        case J.CREATE:
          this.currentLayer.addNewEditor(e);
          return;
        case J.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (this.#X ||= /* @__PURE__ */ new Map()).set(t, e), this.showAllEditors("highlight", e);
          break;
      }
      if (this.hasSelection)
        for (const s of this.#w)
          s.updateParams(t, e);
      else
        for (const s of this.#c)
          s.updateDefaultParams(t, e);
    }
  }
  showAllEditors(t, e, s = !1) {
    for (const n of this.#s.values())
      n.editorType === t && n.show(e);
    (this.#X?.get(J.HIGHLIGHT_SHOW_ALL) ?? !0) !== e && this.#z([[J.HIGHLIGHT_SHOW_ALL, e]]);
  }
  enableWaiting(t = !1) {
    if (this.#B !== t) {
      this.#B = t;
      for (const e of this.#a.values())
        t ? e.disableClick() : e.enableClick(), e.div.classList.toggle("waiting", t);
    }
  }
  async #ft() {
    if (!this.#R) {
      this.#R = !0;
      const t = [];
      for (const e of this.#a.values())
        t.push(e.enable());
      await Promise.all(t);
      for (const e of this.#s.values())
        e.enable();
    }
  }
  #pt() {
    if (this.unselectAll(), this.#R) {
      this.#R = !1;
      for (const t of this.#a.values())
        t.disable();
      for (const t of this.#s.values())
        t.disable();
    }
  }
  *getEditors(t) {
    for (const e of this.#s.values())
      e.pageIndex === t && (yield e);
  }
  getEditor(t) {
    return this.#s.get(t);
  }
  addEditor(t) {
    this.#s.set(t.id, t);
  }
  removeEditor(t) {
    t.div.contains(document.activeElement) && (this.#S && clearTimeout(this.#S), this.#S = setTimeout(() => {
      this.focusMainContainer(), this.#S = null;
    }, 0)), this.#s.delete(t.id), t.annotationElementId && this.#F?.delete(t.annotationElementId), this.unselect(t), (!t.annotationElementId || !this.#m.has(t.annotationElementId)) && this.#r?.remove(t.id);
  }
  addDeletedAnnotationElement(t) {
    this.#m.add(t.annotationElementId), this.addChangedExistingAnnotation(t), t.deleted = !0;
  }
  isDeletedAnnotationElement(t) {
    return this.#m.has(t);
  }
  removeDeletedAnnotationElement(t) {
    this.#m.delete(t.annotationElementId), this.removeChangedExistingAnnotation(t), t.deleted = !1;
  }
  #nt(t) {
    const e = this.#a.get(t.pageIndex);
    e ? e.addOrRebuild(t) : (this.addEditor(t), this.addToAnnotationStorage(t));
  }
  setActiveEditor(t) {
    this.#e !== t && (this.#e = t, t && this.#z(t.propertiesToUpdate));
  }
  get #gt() {
    let t = null;
    for (t of this.#w)
      ;
    return t;
  }
  updateUI(t) {
    this.#gt === t && this.#z(t.propertiesToUpdate);
  }
  updateUIForDefaultProperties(t) {
    this.#z(t.defaultPropertiesToUpdate);
  }
  toggleSelected(t) {
    if (this.#w.has(t)) {
      this.#w.delete(t), t.unselect(), this.#D({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    this.#w.add(t), t.select(), this.#z(t.propertiesToUpdate), this.#D({
      hasSelectedEditor: !0
    });
  }
  setSelected(t) {
    this.updateToolbar({
      mode: t.mode,
      editId: t.id
    }), this.#d?.commitOrRemove();
    for (const e of this.#w)
      e !== t && e.unselect();
    this.#w.clear(), this.#w.add(t), t.select(), this.#z(t.propertiesToUpdate), this.#D({
      hasSelectedEditor: !0
    });
  }
  isSelected(t) {
    return this.#w.has(t);
  }
  get firstSelectedEditor() {
    return this.#w.values().next().value;
  }
  unselect(t) {
    t.unselect(), this.#w.delete(t), this.#D({
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return this.#w.size !== 0;
  }
  get isEnterHandled() {
    return this.#w.size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    this.#h.undo(), this.#D({
      hasSomethingToUndo: this.#h.hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: this.#J()
    }), this._editorUndoBar?.hide();
  }
  redo() {
    this.#h.redo(), this.#D({
      hasSomethingToUndo: !0,
      hasSomethingToRedo: this.#h.hasSomethingToRedo(),
      isEmpty: this.#J()
    });
  }
  addCommands(t) {
    this.#h.add(t), this.#D({
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: this.#J()
    });
  }
  cleanUndoStack(t) {
    this.#h.cleanType(t);
  }
  #J() {
    if (this.#s.size === 0)
      return !0;
    if (this.#s.size === 1)
      for (const t of this.#s.values())
        return t.isEmpty();
    return !1;
  }
  delete() {
    this.commitOrRemove();
    const t = this.currentLayer?.endDrawingSession(!0);
    if (!this.hasSelection && !t)
      return;
    const e = t ? [t] : [...this.#w], s = () => {
      this._editorUndoBar?.show(i, e.length === 1 ? e[0].editorType : e.length);
      for (const n of e)
        n.remove();
    }, i = () => {
      for (const n of e)
        this.#nt(n);
    };
    this.addCommands({
      cmd: s,
      undo: i,
      mustExec: !0
    });
  }
  commitOrRemove() {
    this.#e?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#e || this.hasSelection;
  }
  #rt(t) {
    for (const e of this.#w)
      e.unselect();
    this.#w.clear();
    for (const e of t)
      e.isEmpty() || (this.#w.add(e), e.select());
    this.#D({
      hasSelectedEditor: this.hasSelection
    });
  }
  selectAll() {
    for (const t of this.#w)
      t.commit();
    this.#rt(this.#s.values());
  }
  unselectAll() {
    if (!(this.#e && (this.#e.commitOrRemove(), this.#C !== G.NONE)) && !this.#d?.commitOrRemove() && this.hasSelection) {
      for (const t of this.#w)
        t.unselect();
      this.#w.clear(), this.#D({
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(t, e, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    this.#j[0] += t, this.#j[1] += e;
    const [i, n] = this.#j, r = [...this.#w], a = 1e3;
    this.#N && clearTimeout(this.#N), this.#N = setTimeout(() => {
      this.#N = null, this.#j[0] = this.#j[1] = 0, this.addCommands({
        cmd: () => {
          for (const o of r)
            this.#s.has(o.id) && (o.translateInPage(i, n), o.translationDone());
        },
        undo: () => {
          for (const o of r)
            this.#s.has(o.id) && (o.translateInPage(-i, -n), o.translationDone());
        },
        mustExec: !1
      });
    }, a);
    for (const o of r)
      o.translateInPage(t, e), o.translationDone();
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), this.#p = /* @__PURE__ */ new Map();
      for (const t of this.#w)
        this.#p.set(t, {
          savedX: t.x,
          savedY: t.y,
          savedPageIndex: t.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!this.#p)
      return !1;
    this.disableUserSelect(!1);
    const t = this.#p;
    this.#p = null;
    let e = !1;
    for (const [{
      x: i,
      y: n,
      pageIndex: r
    }, a] of t)
      a.newX = i, a.newY = n, a.newPageIndex = r, e ||= i !== a.savedX || n !== a.savedY || r !== a.savedPageIndex;
    if (!e)
      return !1;
    const s = (i, n, r, a) => {
      if (this.#s.has(i.id)) {
        const o = this.#a.get(a);
        o ? i._setParentAndPosition(o, n, r) : (i.pageIndex = a, i.x = n, i.y = r);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: n,
          newY: r,
          newPageIndex: a
        }] of t)
          s(i, n, r, a);
      },
      undo: () => {
        for (const [i, {
          savedX: n,
          savedY: r,
          savedPageIndex: a
        }] of t)
          s(i, n, r, a);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(t, e) {
    if (this.#p)
      for (const s of this.#p.keys())
        s.drag(t, e);
  }
  rebuild(t) {
    if (t.parent === null) {
      const e = this.getLayer(t.pageIndex);
      e ? (e.changeParent(t), e.addOrRebuild(t)) : (this.addEditor(t), this.addToAnnotationStorage(t), t.rebuild());
    } else
      t.parent.addOrRebuild(t);
  }
  get isEditorHandlingKeyboard() {
    return this.getActive()?.shouldGetKeyboardEvents() || this.#w.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(t) {
    return this.#e === t;
  }
  getActive() {
    return this.#e;
  }
  getMode() {
    return this.#C;
  }
  isEditingMode() {
    return this.#C !== G.NONE;
  }
  get imageManager() {
    return K(this, "imageManager", new Ks());
  }
  getSelectionBoxes(t) {
    if (!t)
      return null;
    const e = document.getSelection();
    for (let l = 0, c = e.rangeCount; l < c; l++)
      if (!t.contains(e.getRangeAt(l).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: n,
      height: r
    } = t.getBoundingClientRect();
    let a;
    switch (t.getAttribute("data-main-rotation")) {
      case "90":
        a = (l, c, d, u) => ({
          x: (c - i) / r,
          y: 1 - (l + d - s) / n,
          width: u / r,
          height: d / n
        });
        break;
      case "180":
        a = (l, c, d, u) => ({
          x: 1 - (l + d - s) / n,
          y: 1 - (c + u - i) / r,
          width: d / n,
          height: u / r
        });
        break;
      case "270":
        a = (l, c, d, u) => ({
          x: 1 - (c + u - i) / r,
          y: (l - s) / n,
          width: u / r,
          height: d / n
        });
        break;
      default:
        a = (l, c, d, u) => ({
          x: (l - s) / n,
          y: (c - i) / r,
          width: d / n,
          height: u / r
        });
        break;
    }
    const o = [];
    for (let l = 0, c = e.rangeCount; l < c; l++) {
      const d = e.getRangeAt(l);
      if (!d.collapsed)
        for (const {
          x: u,
          y: f,
          width: g,
          height: p
        } of d.getClientRects())
          g === 0 || p === 0 || o.push(a(u, f, g, p));
    }
    return o.length === 0 ? null : o;
  }
  addChangedExistingAnnotation({
    annotationElementId: t,
    id: e
  }) {
    (this.#o ||= /* @__PURE__ */ new Map()).set(t, e);
  }
  removeChangedExistingAnnotation({
    annotationElementId: t
  }) {
    this.#o?.delete(t);
  }
  renderAnnotationElement(t) {
    const e = this.#o?.get(t.data.id);
    if (!e)
      return;
    const s = this.#r.getRawValue(e);
    s && (this.#C === G.NONE && !s.hasBeenModified || s.renderAnnotationElement(t));
  }
  setMissingCanvas(t, e, s) {
    const i = this.#F?.get(t);
    i && (i.setCanvas(e, s), this.#F.delete(t));
  }
  addMissingCanvas(t, e) {
    (this.#F ||= /* @__PURE__ */ new Map()).set(t, e);
  }
}
class Qt {
  #t = null;
  #e = !1;
  #i = null;
  #s = null;
  #a = null;
  #n = null;
  #r = !1;
  #o = null;
  #h = null;
  #l = null;
  #u = null;
  #d = !1;
  static #f = null;
  static _l10n = null;
  constructor(t) {
    this.#h = t, this.#d = t._uiManager.useNewAltTextFlow, Qt.#f ||= Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    });
  }
  static initialize(t) {
    Qt._l10n ??= t;
  }
  async render() {
    const t = this.#i = document.createElement("button");
    t.className = "altText", t.tabIndex = "0";
    const e = this.#s = document.createElement("span");
    t.append(e), this.#d ? (t.classList.add("new"), t.setAttribute("data-l10n-id", Qt.#f.missing), e.setAttribute("data-l10n-id", Qt.#f["missing-label"])) : (t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
    const s = this.#h._uiManager._signal;
    t.addEventListener("contextmenu", Bt, {
      signal: s
    }), t.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = (n) => {
      n.preventDefault(), this.#h._uiManager.editAltText(this.#h), this.#d && this.#h._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_clicked",
        data: {
          label: this.#m
        }
      });
    };
    return t.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), t.addEventListener("keydown", (n) => {
      n.target === t && n.key === "Enter" && (this.#r = !0, i(n));
    }, {
      signal: s
    }), await this.#p(), t;
  }
  get #m() {
    return this.#t && "added" || this.#t === null && this.guessedText && "review" || "missing";
  }
  finish() {
    this.#i && (this.#i.focus({
      focusVisible: this.#r
    }), this.#r = !1);
  }
  isEmpty() {
    return this.#d ? this.#t === null : !this.#t && !this.#e;
  }
  hasData() {
    return this.#d ? this.#t !== null || !!this.#l : this.isEmpty();
  }
  get guessedText() {
    return this.#l;
  }
  async setGuessedText(t) {
    this.#t === null && (this.#l = t, this.#u = await Qt._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: t
    }), this.#p());
  }
  toggleAltTextBadge(t = !1) {
    if (!this.#d || this.#t) {
      this.#o?.remove(), this.#o = null;
      return;
    }
    if (!this.#o) {
      const e = this.#o = document.createElement("div");
      e.className = "noAltTextBadge", this.#h.div.append(e);
    }
    this.#o.classList.toggle("hidden", !t);
  }
  serialize(t) {
    let e = this.#t;
    return !t && this.#l === e && (e = this.#u), {
      altText: e,
      decorative: this.#e,
      guessedText: this.#l,
      textWithDisclaimer: this.#u
    };
  }
  get data() {
    return {
      altText: this.#t,
      decorative: this.#e
    };
  }
  set data({
    altText: t,
    decorative: e,
    guessedText: s,
    textWithDisclaimer: i,
    cancel: n = !1
  }) {
    s && (this.#l = s, this.#u = i), !(this.#t === t && this.#e === e) && (n || (this.#t = t, this.#e = e), this.#p());
  }
  toggle(t = !1) {
    this.#i && (!t && this.#n && (clearTimeout(this.#n), this.#n = null), this.#i.disabled = !t);
  }
  shown() {
    this.#h._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: this.#m
      }
    });
  }
  destroy() {
    this.#i?.remove(), this.#i = null, this.#s = null, this.#a = null, this.#o?.remove(), this.#o = null;
  }
  async #p() {
    const t = this.#i;
    if (!t)
      return;
    if (this.#d) {
      if (t.classList.toggle("done", !!this.#t), t.setAttribute("data-l10n-id", Qt.#f[this.#m]), this.#s?.setAttribute("data-l10n-id", Qt.#f[`${this.#m}-label`]), !this.#t) {
        this.#a?.remove();
        return;
      }
    } else {
      if (!this.#t && !this.#e) {
        t.classList.remove("done"), this.#a?.remove();
        return;
      }
      t.classList.add("done"), t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
    }
    let e = this.#a;
    if (!e) {
      this.#a = e = document.createElement("span"), e.className = "tooltip", e.setAttribute("role", "tooltip"), e.id = `alt-text-tooltip-${this.#h.id}`;
      const i = 100, n = this.#h._uiManager._signal;
      n.addEventListener("abort", () => {
        clearTimeout(this.#n), this.#n = null;
      }, {
        once: !0
      }), t.addEventListener("mouseenter", () => {
        this.#n = setTimeout(() => {
          this.#n = null, this.#a.classList.add("show"), this.#h._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, i);
      }, {
        signal: n
      }), t.addEventListener("mouseleave", () => {
        this.#n && (clearTimeout(this.#n), this.#n = null), this.#a?.classList.remove("show");
      }, {
        signal: n
      });
    }
    this.#e ? e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (e.removeAttribute("data-l10n-id"), e.textContent = this.#t), e.parentNode || t.append(e), this.#h.getElementForAltText()?.setAttribute("aria-describedby", e.id);
  }
}
class ts {
  #t = null;
  #e = null;
  #i = !1;
  #s = null;
  #a = null;
  #n = null;
  #r = null;
  #o = null;
  #h = !1;
  #l = null;
  constructor(t) {
    this.#s = t;
  }
  renderForToolbar() {
    const t = this.#e = document.createElement("button");
    return t.className = "comment", this.#u(t, !1);
  }
  renderForStandalone() {
    const t = this.#t = document.createElement("button");
    t.className = "annotationCommentButton";
    const e = this.#s.commentButtonPosition;
    if (e) {
      const {
        style: s
      } = t;
      s.insetInlineEnd = `calc(${100 * (this.#s._uiManager.direction === "ltr" ? 1 - e[0] : e[0])}% - var(--comment-button-dim))`, s.top = `calc(${100 * e[1]}% - var(--comment-button-dim))`;
      const i = this.#s.commentButtonColor;
      i && (s.backgroundColor = i);
    }
    return this.#u(t, !0);
  }
  focusButton() {
    setTimeout(() => {
      (this.#t ?? this.#e)?.focus();
    }, 0);
  }
  onUpdatedColor() {
    if (!this.#t)
      return;
    const t = this.#s.commentButtonColor;
    t && (this.#t.style.backgroundColor = t), this.#s._uiManager.updatePopupColor(this.#s);
  }
  get commentButtonWidth() {
    return (this.#t?.getBoundingClientRect().width ?? 0) / this.#s.parent.boundingClientRect.width;
  }
  get commentPopupPositionInLayer() {
    if (this.#l)
      return this.#l;
    if (!this.#t)
      return null;
    const {
      x: t,
      y: e,
      height: s
    } = this.#t.getBoundingClientRect(), {
      x: i,
      y: n,
      width: r,
      height: a
    } = this.#s.parent.boundingClientRect;
    return [(t - i) / r, (e + s - n) / a];
  }
  set commentPopupPositionInLayer(t) {
    this.#l = t;
  }
  hasDefaultPopupPosition() {
    return this.#l === null;
  }
  removeStandaloneCommentButton() {
    this.#t?.remove(), this.#t = null;
  }
  removeToolbarCommentButton() {
    this.#e?.remove(), this.#e = null;
  }
  setCommentButtonStates({
    selected: t,
    hasPopup: e
  }) {
    this.#t && (this.#t.classList.toggle("selected", t), this.#t.ariaExpanded = e);
  }
  #u(t, e) {
    if (!this.#s._uiManager.hasCommentManager())
      return null;
    t.tabIndex = "0", t.ariaHasPopup = "dialog", e ? (t.ariaControls = "commentPopup", t.setAttribute("data-l10n-id", "pdfjs-show-comment-button")) : (t.ariaControlsElements = [this.#s._uiManager.getCommentDialogElement()], t.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button"));
    const s = this.#s._uiManager._signal;
    if (!(s instanceof AbortSignal) || s.aborted)
      return t;
    t.addEventListener("contextmenu", Bt, {
      signal: s
    }), e && (t.addEventListener("focusin", (n) => {
      this.#s._focusEventsAllowed = !1, ct(n);
    }, {
      capture: !0,
      signal: s
    }), t.addEventListener("focusout", (n) => {
      this.#s._focusEventsAllowed = !0, ct(n);
    }, {
      capture: !0,
      signal: s
    })), t.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = (n) => {
      n.preventDefault(), t === this.#e ? this.edit() : this.#s.toggleComment(!0);
    };
    return t.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), t.addEventListener("keydown", (n) => {
      n.target === t && n.key === "Enter" && (this.#i = !0, i(n));
    }, {
      signal: s
    }), t.addEventListener("pointerenter", () => {
      this.#s.toggleComment(!1, !0);
    }, {
      signal: s
    }), t.addEventListener("pointerleave", () => {
      this.#s.toggleComment(!1, !1);
    }, {
      signal: s
    }), t;
  }
  edit(t) {
    const e = this.commentPopupPositionInLayer;
    let s, i;
    if (e)
      [s, i] = e;
    else {
      [s, i] = this.#s.commentButtonPosition;
      const {
        width: c,
        height: d,
        x: u,
        y: f
      } = this.#s;
      s = u + s * c, i = f + i * d;
    }
    const n = this.#s.parent.boundingClientRect, {
      x: r,
      y: a,
      width: o,
      height: l
    } = n;
    this.#s._uiManager.editComment(this.#s, r + s * o, a + i * l, {
      ...t,
      parentDimensions: n
    });
  }
  finish() {
    this.#e && (this.#e.focus({
      focusVisible: this.#i
    }), this.#i = !1);
  }
  isDeleted() {
    return this.#h || this.#r === "";
  }
  isEmpty() {
    return this.#r === null;
  }
  hasBeenEdited() {
    return this.isDeleted() || this.#r !== this.#a;
  }
  serialize() {
    return this.data;
  }
  get data() {
    return {
      text: this.#r,
      richText: this.#n,
      date: this.#o,
      deleted: this.isDeleted()
    };
  }
  set data(t) {
    if (t !== this.#r && (this.#n = null), t === null) {
      this.#r = "", this.#h = !0;
      return;
    }
    this.#r = t, this.#o = /* @__PURE__ */ new Date(), this.#h = !1;
  }
  setInitialText(t, e = null) {
    this.#a = t, this.data = t, this.#o = null, this.#n = e;
  }
  shown() {
  }
  destroy() {
    this.#e?.remove(), this.#e = null, this.#t?.remove(), this.#t = null, this.#r = "", this.#n = null, this.#o = null, this.#s = null, this.#i = !1, this.#h = !1;
  }
}
class Ke {
  #t;
  #e = !1;
  #i = null;
  #s;
  #a;
  #n;
  #r;
  #o = null;
  #h;
  #l = null;
  #u;
  #d = null;
  constructor({
    container: t,
    isPinchingDisabled: e = null,
    isPinchingStopped: s = null,
    onPinchStart: i = null,
    onPinching: n = null,
    onPinchEnd: r = null,
    signal: a
  }) {
    this.#t = t, this.#i = s, this.#s = e, this.#a = i, this.#n = n, this.#r = r, this.#u = new AbortController(), this.#h = AbortSignal.any([a, this.#u.signal]), t.addEventListener("touchstart", this.#f.bind(this), {
      passive: !1,
      signal: this.#h
    });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / Gt.pixelRatio;
  }
  #f(t) {
    if (this.#s?.())
      return;
    if (t.touches.length === 1) {
      if (this.#o)
        return;
      const i = this.#o = new AbortController(), n = AbortSignal.any([this.#h, i.signal]), r = this.#t, a = {
        capture: !0,
        signal: n,
        passive: !1
      }, o = (l) => {
        l.pointerType === "touch" && (this.#o?.abort(), this.#o = null);
      };
      r.addEventListener("pointerdown", (l) => {
        l.pointerType === "touch" && (ct(l), o(l));
      }, a), r.addEventListener("pointerup", o, a), r.addEventListener("pointercancel", o, a);
      return;
    }
    if (!this.#d) {
      this.#d = new AbortController();
      const i = AbortSignal.any([this.#h, this.#d.signal]), n = this.#t, r = {
        signal: i,
        capture: !1,
        passive: !1
      };
      n.addEventListener("touchmove", this.#m.bind(this), r);
      const a = this.#p.bind(this);
      n.addEventListener("touchend", a, r), n.addEventListener("touchcancel", a, r), r.capture = !0, n.addEventListener("pointerdown", ct, r), n.addEventListener("pointermove", ct, r), n.addEventListener("pointercancel", ct, r), n.addEventListener("pointerup", ct, r), this.#a?.();
    }
    if (ct(t), t.touches.length !== 2 || this.#i?.()) {
      this.#l = null;
      return;
    }
    let [e, s] = t.touches;
    e.identifier > s.identifier && ([e, s] = [s, e]), this.#l = {
      touch0X: e.screenX,
      touch0Y: e.screenY,
      touch1X: s.screenX,
      touch1Y: s.screenY
    };
  }
  #m(t) {
    if (!this.#l || t.touches.length !== 2)
      return;
    ct(t);
    let [e, s] = t.touches;
    e.identifier > s.identifier && ([e, s] = [s, e]);
    const {
      screenX: i,
      screenY: n
    } = e, {
      screenX: r,
      screenY: a
    } = s, o = this.#l, {
      touch0X: l,
      touch0Y: c,
      touch1X: d,
      touch1Y: u
    } = o, f = d - l, g = u - c, p = r - i, v = a - n, m = Math.hypot(p, v) || 1, b = Math.hypot(f, g) || 1;
    if (!this.#e && Math.abs(b - m) <= Ke.MIN_TOUCH_DISTANCE_TO_PINCH)
      return;
    if (o.touch0X = i, o.touch0Y = n, o.touch1X = r, o.touch1Y = a, !this.#e) {
      this.#e = !0;
      return;
    }
    const y = [(i + r) / 2, (n + a) / 2];
    this.#n?.(y, b, m);
  }
  #p(t) {
    t.touches.length >= 2 || (this.#d && (this.#d.abort(), this.#d = null, this.#r?.()), this.#l && (ct(t), this.#l = null, this.#e = !1));
  }
  destroy() {
    this.#u?.abort(), this.#u = null, this.#o?.abort(), this.#o = null;
  }
}
class U {
  #t = null;
  #e = null;
  #i = null;
  #s = null;
  #a = null;
  #n = !1;
  #r = null;
  #o = "";
  #h = null;
  #l = null;
  #u = null;
  #d = null;
  #f = null;
  #m = "";
  #p = !1;
  #c = null;
  #g = !1;
  #v = !1;
  #b = !1;
  #y = null;
  #T = 0;
  #S = 0;
  #A = null;
  #P = null;
  isSelected = !1;
  _isCopy = !1;
  _editToolbar = null;
  _initialOptions = /* @__PURE__ */ Object.create(null);
  _initialData = null;
  _isVisible = !0;
  _uiManager = null;
  _focusEventsAllowed = !0;
  static _l10n = null;
  static _l10nResizer = null;
  #E = !1;
  #x = U._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new Js();
  static _zIndex = 1;
  static _telemetryTimeout = 1e3;
  static get _resizerKeyboardManager() {
    const t = U.prototype._resizeWithKeyboard, e = ne.TRANSLATE_SMALL, s = ne.TRANSLATE_BIG;
    return K(this, "_resizerKeyboardManager", new Ye([[["ArrowLeft", "mac+ArrowLeft"], t, {
      args: [-e, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], t, {
      args: [e, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], t, {
      args: [0, -e]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], t, {
      args: [0, e]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], U.prototype._stopResizingWithKeyboard]]));
  }
  constructor(t) {
    this.parent = t.parent, this.id = t.id, this.width = this.height = null, this.pageIndex = t.parent.pageIndex, this.name = t.name, this.div = null, this._uiManager = t.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = t.isCentered, this._structTreeParentId = null, this.annotationElementId = t.annotationElementId || null, this.creationDate = t.creationDate || /* @__PURE__ */ new Date(), this.modificationDate = t.modificationDate || null;
    const {
      rotation: e,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: n,
        pageY: r
      }
    } = this.parent.viewport;
    this.rotation = e, this.pageRotation = (360 + e - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [n, r];
    const [a, o] = this.parentDimensions;
    this.x = t.x / a, this.y = t.y / o, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  get mode() {
    return Object.getPrototypeOf(this).constructor._editorType;
  }
  static get isDrawer() {
    return !1;
  }
  static get _defaultLineColor() {
    return K(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(t) {
    const e = new zn({
      id: t.parent.getNextId(),
      parent: t.parent,
      uiManager: t._uiManager
    });
    e.annotationElementId = t.annotationElementId, e.deleted = !0, e._uiManager.addToAnnotationStorage(e);
  }
  static initialize(t, e) {
    if (U._l10n ??= t, U._l10nResizer ||= Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    }), U._borderLineWidth !== -1)
      return;
    const s = getComputedStyle(document.documentElement);
    U._borderLineWidth = parseFloat(s.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(t, e) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(t) {
    return !1;
  }
  static paste(t, e) {
    it("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#E;
  }
  set _isDraggable(t) {
    this.#E = t, this.div?.classList.toggle("draggable", t);
  }
  get uid() {
    return this.annotationElementId || this.id;
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [t, e] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * e / (t * 2), this.y += this.width * t / (e * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * e / (t * 2), this.y -= this.width * t / (e * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(t) {
    this._uiManager.addCommands(t);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#x;
  }
  setParent(t) {
    t !== null ? (this.pageIndex = t.pageIndex, this.pageDimensions = t.pageDimensions) : (this.#N(), this.#d?.remove(), this.#d = null), this.parent = t;
  }
  focusin(t) {
    this._focusEventsAllowed && (this.#p ? this.#p = !1 : this.parent.setSelected(this));
  }
  focusout(t) {
    !this._focusEventsAllowed || !this.isAttachedToDOM || t.relatedTarget?.closest(`#${this.id}`) || (t.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.isInEditMode() && this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(t, e, s, i) {
    const [n, r] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (t + s) / n, this.y = (e + i) / r, this.fixAndSetPosition();
  }
  _moveAfterPaste(t, e) {
    const [s, i] = this.parentDimensions;
    this.setAt(t * s, e * i, this.width * s, this.height * i), this._onTranslated();
  }
  #M([t, e], s, i) {
    [s, i] = this.screenToPageTranslation(s, i), this.x += s / t, this.y += i / e, this._onTranslating(this.x, this.y), this.fixAndSetPosition();
  }
  translate(t, e) {
    this.#M(this.parentDimensions, t, e);
  }
  translateInPage(t, e) {
    this.#c ||= [this.x, this.y, this.width, this.height], this.#M(this.pageDimensions, t, e), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(t, e) {
    this.#c ||= [this.x, this.y, this.width, this.height];
    const {
      div: s,
      parentDimensions: [i, n]
    } = this;
    if (this.x += t / i, this.y += e / n, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: d,
        y: u
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, d, u) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: r,
      y: a
    } = this;
    const [o, l] = this.getBaseTranslation();
    r += o, a += l;
    const {
      style: c
    } = s;
    c.left = `${(100 * r).toFixed(2)}%`, c.top = `${(100 * a).toFixed(2)}%`, this._onTranslating(r, a), s.scrollIntoView({
      block: "nearest"
    });
  }
  _onTranslating(t, e) {
  }
  _onTranslated(t, e) {
  }
  get _hasBeenMoved() {
    return !!this.#c && (this.#c[0] !== this.x || this.#c[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!this.#c && (this.#c[2] !== this.width || this.#c[3] !== this.height);
  }
  getBaseTranslation() {
    const [t, e] = this.parentDimensions, {
      _borderLineWidth: s
    } = U, i = s / t, n = s / e;
    switch (this.rotation) {
      case 90:
        return [-i, n];
      case 180:
        return [i, n];
      case 270:
        return [i, -n];
      default:
        return [-i, -n];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(t = this.rotation) {
    const {
      div: {
        style: e
      },
      pageDimensions: [s, i]
    } = this;
    let {
      x: n,
      y: r,
      width: a,
      height: o
    } = this;
    if (a *= s, o *= i, n *= s, r *= i, this._mustFixPosition)
      switch (t) {
        case 0:
          n = Ct(n, 0, s - a), r = Ct(r, 0, i - o);
          break;
        case 90:
          n = Ct(n, 0, s - o), r = Ct(r, a, i);
          break;
        case 180:
          n = Ct(n, a, s), r = Ct(r, o, i);
          break;
        case 270:
          n = Ct(n, o, s), r = Ct(r, 0, i - a);
          break;
      }
    this.x = n /= s, this.y = r /= i;
    const [l, c] = this.getBaseTranslation();
    n += l, r += c, e.left = `${(100 * n).toFixed(2)}%`, e.top = `${(100 * r).toFixed(2)}%`, this.moveInDOM();
  }
  static #R(t, e, s) {
    switch (s) {
      case 90:
        return [e, -t];
      case 180:
        return [-t, -e];
      case 270:
        return [-e, t];
      default:
        return [t, e];
    }
  }
  screenToPageTranslation(t, e) {
    return U.#R(t, e, this.parentRotation);
  }
  pageTranslationToScreen(t, e) {
    return U.#R(t, e, 360 - this.parentRotation);
  }
  #I(t) {
    switch (t) {
      case 90: {
        const [e, s] = this.pageDimensions;
        return [0, -e / s, s / e, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [e, s] = this.pageDimensions;
        return [0, e / s, -s / e, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: t,
      pageDimensions: [e, s]
    } = this;
    return [e * t, s * t];
  }
  setDims() {
    const {
      div: {
        style: t
      },
      width: e,
      height: s
    } = this;
    t.width = `${(100 * e).toFixed(2)}%`, t.height = `${(100 * s).toFixed(2)}%`;
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #B() {
    if (this.#h)
      return;
    this.#h = document.createElement("div"), this.#h.classList.add("resizers");
    const t = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], e = this._uiManager._signal;
    for (const s of t) {
      const i = document.createElement("div");
      this.#h.append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", this.#L.bind(this, s), {
        signal: e
      }), i.addEventListener("contextmenu", Bt, {
        signal: e
      }), i.tabIndex = -1;
    }
    this.div.prepend(this.#h);
  }
  #L(t, e) {
    e.preventDefault();
    const {
      isMac: s
    } = wt.platform;
    if (e.button !== 0 || e.ctrlKey && s)
      return;
    this.#i?.toggle(!1);
    const i = this._isDraggable;
    this._isDraggable = !1, this.#l = [e.screenX, e.screenY];
    const n = new AbortController(), r = this._uiManager.combinedSignal(n);
    this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", this.#F.bind(this, t), {
      passive: !0,
      capture: !0,
      signal: r
    }), window.addEventListener("touchmove", ct, {
      passive: !1,
      signal: r
    }), window.addEventListener("contextmenu", Bt, {
      signal: r
    }), this.#u = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const a = this.parent.div.style.cursor, o = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e.target).cursor;
    const l = () => {
      n.abort(), this.parent.togglePointerEvents(!0), this.#i?.toggle(!0), this._isDraggable = i, this.parent.div.style.cursor = a, this.div.style.cursor = o, this.#_();
    };
    window.addEventListener("pointerup", l, {
      signal: r
    }), window.addEventListener("blur", l, {
      signal: r
    });
  }
  #k(t, e, s, i) {
    this.width = s, this.height = i, this.x = t, this.y = e, this.setDims(), this.fixAndSetPosition(), this._onResized();
  }
  _onResized() {
  }
  #_() {
    if (!this.#u)
      return;
    const {
      savedX: t,
      savedY: e,
      savedWidth: s,
      savedHeight: i
    } = this.#u;
    this.#u = null;
    const n = this.x, r = this.y, a = this.width, o = this.height;
    n === t && r === e && a === s && o === i || this.addCommands({
      cmd: this.#k.bind(this, n, r, a, o),
      undo: this.#k.bind(this, t, e, s, i),
      mustExec: !0
    });
  }
  static _round(t) {
    return Math.round(t * 1e4) / 1e4;
  }
  #F(t, e) {
    const [s, i] = this.parentDimensions, n = this.x, r = this.y, a = this.width, o = this.height, l = U.MIN_SIZE / s, c = U.MIN_SIZE / i, d = this.#I(this.rotation), u = (M, I) => [d[0] * M + d[2] * I, d[1] * M + d[3] * I], f = this.#I(360 - this.rotation), g = (M, I) => [f[0] * M + f[2] * I, f[1] * M + f[3] * I];
    let p, v, m = !1, b = !1;
    switch (t) {
      case "topLeft":
        m = !0, p = (M, I) => [0, 0], v = (M, I) => [M, I];
        break;
      case "topMiddle":
        p = (M, I) => [M / 2, 0], v = (M, I) => [M / 2, I];
        break;
      case "topRight":
        m = !0, p = (M, I) => [M, 0], v = (M, I) => [0, I];
        break;
      case "middleRight":
        b = !0, p = (M, I) => [M, I / 2], v = (M, I) => [0, I / 2];
        break;
      case "bottomRight":
        m = !0, p = (M, I) => [M, I], v = (M, I) => [0, 0];
        break;
      case "bottomMiddle":
        p = (M, I) => [M / 2, I], v = (M, I) => [M / 2, 0];
        break;
      case "bottomLeft":
        m = !0, p = (M, I) => [0, I], v = (M, I) => [M, 0];
        break;
      case "middleLeft":
        b = !0, p = (M, I) => [0, I / 2], v = (M, I) => [M, I / 2];
        break;
    }
    const y = p(a, o), E = v(a, o);
    let A = u(...E);
    const w = U._round(n + A[0]), S = U._round(r + A[1]);
    let x = 1, T = 1, C, P;
    if (e.fromKeyboard)
      ({
        deltaX: C,
        deltaY: P
      } = e);
    else {
      const {
        screenX: M,
        screenY: I
      } = e, [N, X] = this.#l;
      [C, P] = this.screenToPageTranslation(M - N, I - X), this.#l[0] = M, this.#l[1] = I;
    }
    if ([C, P] = g(C / s, P / i), m) {
      const M = Math.hypot(a, o);
      x = T = Math.max(Math.min(Math.hypot(E[0] - y[0] - C, E[1] - y[1] - P) / M, 1 / a, 1 / o), l / a, c / o);
    } else b ? x = Ct(Math.abs(E[0] - y[0] - C), l, 1) / a : T = Ct(Math.abs(E[1] - y[1] - P), c, 1) / o;
    const O = U._round(a * x), D = U._round(o * T);
    A = u(...v(O, D));
    const k = w - A[0], H = S - A[1];
    this.#c ||= [this.x, this.y, this.width, this.height], this.width = O, this.height = D, this.x = k, this.y = H, this.setDims(), this.fixAndSetPosition(), this._onResizing();
  }
  _onResizing() {
  }
  altTextFinish() {
    this.#i?.finish();
  }
  get toolbarButtons() {
    return null;
  }
  async addEditToolbar() {
    if (this._editToolbar || this.#v)
      return this._editToolbar;
    this._editToolbar = new Ue(this), this.div.append(this._editToolbar.render());
    const {
      toolbarButtons: t
    } = this;
    if (t)
      for (const [e, s] of t)
        await this._editToolbar.addButton(e, s);
    return this.hasComment || this._editToolbar.addButton("comment", this.addCommentButton()), this._editToolbar.addButton("delete"), this._editToolbar;
  }
  addCommentButtonInToolbar() {
    this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
  }
  removeCommentButtonFromToolbar() {
    this._editToolbar?.removeButton("comment");
  }
  removeEditToolbar() {
    this._editToolbar?.remove(), this._editToolbar = null, this.#i?.destroy();
  }
  addContainer(t) {
    const e = this._editToolbar?.div;
    e ? e.before(t) : this.div.append(t);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  createAltText() {
    return this.#i || (Qt.initialize(U._l10n), this.#i = new Qt(this), this.#t && (this.#i.data = this.#t, this.#t = null)), this.#i;
  }
  get altTextData() {
    return this.#i?.data;
  }
  set altTextData(t) {
    this.#i && (this.#i.data = t);
  }
  get guessedAltText() {
    return this.#i?.guessedText;
  }
  async setGuessedAltText(t) {
    await this.#i?.setGuessedText(t);
  }
  serializeAltText(t) {
    return this.#i?.serialize(t);
  }
  hasAltText() {
    return !!this.#i && !this.#i.isEmpty();
  }
  hasAltTextData() {
    return this.#i?.hasData() ?? !1;
  }
  focusCommentButton() {
    this.#s?.focusButton();
  }
  addCommentButton() {
    return this.#s ||= new ts(this);
  }
  addStandaloneCommentButton() {
    if (this.#a) {
      this._uiManager.isEditingMode() && this.#a.classList.remove("hidden");
      return;
    }
    this.hasComment && (this.#a = this.#s.renderForStandalone(), this.div.append(this.#a));
  }
  removeStandaloneCommentButton() {
    this.#s.removeStandaloneCommentButton(), this.#a = null;
  }
  hideStandaloneCommentButton() {
    this.#a?.classList.add("hidden");
  }
  get comment() {
    const {
      data: {
        richText: t,
        text: e,
        date: s,
        deleted: i
      }
    } = this.#s;
    return {
      text: e,
      richText: t,
      date: s,
      deleted: i,
      color: this.getNonHCMColor(),
      opacity: this.opacity ?? 1
    };
  }
  set comment(t) {
    this.#s ||= new ts(this), this.#s.data = t, this.hasComment ? (this.removeCommentButtonFromToolbar(), this.addStandaloneCommentButton(), this._uiManager.updateComment(this)) : (this.addCommentButtonInToolbar(), this.removeStandaloneCommentButton(), this._uiManager.removeComment(this));
  }
  setCommentData({
    comment: t,
    popupRef: e,
    richText: s
  }) {
    if (!e || (this.#s ||= new ts(this), this.#s.setInitialText(t, s), !this.annotationElementId))
      return;
    const i = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
    i && this.updateFromAnnotationLayer(i);
  }
  get hasEditedComment() {
    return this.#s?.hasBeenEdited();
  }
  get hasDeletedComment() {
    return this.#s?.isDeleted();
  }
  get hasComment() {
    return !!this.#s && !this.#s.isEmpty() && !this.#s.isDeleted();
  }
  async editComment(t) {
    this.#s ||= new ts(this), this.#s.edit(t);
  }
  toggleComment(t, e = void 0) {
    this.hasComment && this._uiManager.toggleComment(this, t, e);
  }
  setSelectedCommentButton(t) {
    this.#s.setSelectedButton(t);
  }
  addComment(t) {
    if (this.hasEditedComment) {
      const [, , , i] = t.rect, [n] = this.pageDimensions, [r] = this.pageTranslation, a = r + n + 1, o = i - 100, l = a + 180;
      t.popup = {
        contents: this.comment.text,
        deleted: this.comment.deleted,
        rect: [a, o, l, i]
      };
    }
  }
  updateFromAnnotationLayer({
    popup: {
      contents: t,
      deleted: e
    }
  }) {
    this.#s.data = e ? null : t;
  }
  get parentBoundingClientRect() {
    return this.parent.boundingClientRect;
  }
  render() {
    const t = this.div = document.createElement("div");
    t.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), t.className = this.name, t.setAttribute("id", this.id), t.tabIndex = this.#n ? -1 : 0, t.setAttribute("role", "application"), this.defaultL10nId && t.setAttribute("data-l10n-id", this.defaultL10nId), this._isVisible || t.classList.add("hidden"), this.setInForeground(), this.#$();
    const [e, s] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (t.style.maxWidth = `${(100 * s / e).toFixed(2)}%`, t.style.maxHeight = `${(100 * e / s).toFixed(2)}%`);
    const [i, n] = this.getInitialTranslation();
    return this.translate(i, n), Zi(this, t, ["keydown", "pointerdown", "dblclick"]), this.isResizable && this._uiManager._supportsPinchToZoom && (this.#P ||= new Ke({
      container: t,
      isPinchingDisabled: () => !this.isSelected,
      onPinchStart: this.#V.bind(this),
      onPinching: this.#C.bind(this),
      onPinchEnd: this.#w.bind(this),
      signal: this._uiManager._signal
    })), this.addStandaloneCommentButton(), this._uiManager._editorUndoBar?.hide(), t;
  }
  #V() {
    this.#u = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    }, this.#i?.toggle(!1), this.parent.togglePointerEvents(!1);
  }
  #C(t, e, s) {
    let n = 0.7 * (s / e) + 1 - 0.7;
    if (n === 1)
      return;
    const r = this.#I(this.rotation), a = (w, S) => [r[0] * w + r[2] * S, r[1] * w + r[3] * S], [o, l] = this.parentDimensions, c = this.x, d = this.y, u = this.width, f = this.height, g = U.MIN_SIZE / o, p = U.MIN_SIZE / l;
    n = Math.max(Math.min(n, 1 / u, 1 / f), g / u, p / f);
    const v = U._round(u * n), m = U._round(f * n);
    if (v === u && m === f)
      return;
    this.#c ||= [c, d, u, f];
    const b = a(u / 2, f / 2), y = U._round(c + b[0]), E = U._round(d + b[1]), A = a(v / 2, m / 2);
    this.x = y - A[0], this.y = E - A[1], this.width = v, this.height = m, this.setDims(), this.fixAndSetPosition(), this._onResizing();
  }
  #w() {
    this.#i?.toggle(!0), this.parent.togglePointerEvents(!0), this.#_();
  }
  pointerdown(t) {
    const {
      isMac: e
    } = wt.platform;
    if (t.button !== 0 || t.ctrlKey && e) {
      t.preventDefault();
      return;
    }
    if (this.#p = !0, this._isDraggable) {
      this.#U(t);
      return;
    }
    this.#O(t);
  }
  #O(t) {
    const {
      isMac: e
    } = wt.platform;
    t.ctrlKey && !e || t.shiftKey || t.metaKey && e ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
  }
  #U(t) {
    const {
      isSelected: e
    } = this;
    this._uiManager.setUpDragSession();
    let s = !1;
    const i = new AbortController(), n = this._uiManager.combinedSignal(i), r = {
      capture: !0,
      passive: !1,
      signal: n
    }, a = (l) => {
      i.abort(), this.#r = null, this.#p = !1, this._uiManager.endDragSession() || this.#O(l), s && this._onStopDragging();
    };
    e && (this.#T = t.clientX, this.#S = t.clientY, this.#r = t.pointerId, this.#o = t.pointerType, window.addEventListener("pointermove", (l) => {
      s || (s = !0, this._uiManager.toggleComment(this, !0, !1), this._onStartDragging());
      const {
        clientX: c,
        clientY: d,
        pointerId: u
      } = l;
      if (u !== this.#r) {
        ct(l);
        return;
      }
      const [f, g] = this.screenToPageTranslation(c - this.#T, d - this.#S);
      this.#T = c, this.#S = d, this._uiManager.dragSelectedEditors(f, g);
    }, r), window.addEventListener("touchmove", ct, r), window.addEventListener("pointerdown", (l) => {
      l.pointerType === this.#o && (this.#P || l.isPrimary) && a(l), ct(l);
    }, r));
    const o = (l) => {
      if (!this.#r || this.#r === l.pointerId) {
        a(l);
        return;
      }
      ct(l);
    };
    window.addEventListener("pointerup", o, {
      signal: n
    }), window.addEventListener("blur", o, {
      signal: n
    });
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    this.#y && clearTimeout(this.#y), this.#y = setTimeout(() => {
      this.#y = null, this.parent?.moveEditorInDOM(this);
    }, 0);
  }
  _setParentAndPosition(t, e, s) {
    t.changeParent(this), this.x = e, this.y = s, this.fixAndSetPosition(), this._onTranslated();
  }
  getRect(t, e, s = this.rotation) {
    const i = this.parentScale, [n, r] = this.pageDimensions, [a, o] = this.pageTranslation, l = t / i, c = e / i, d = this.x * n, u = this.y * r, f = this.width * n, g = this.height * r;
    switch (s) {
      case 0:
        return [d + l + a, r - u - c - g + o, d + l + f + a, r - u - c + o];
      case 90:
        return [d + c + a, r - u + l + o, d + c + g + a, r - u + l + f + o];
      case 180:
        return [d - l - f + a, r - u + c + o, d - l + a, r - u + c + g + o];
      case 270:
        return [d - c - g + a, r - u - l - f + o, d - c + a, r - u - l + o];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(t, e) {
    const [s, i, n, r] = t, a = n - s, o = r - i;
    switch (this.rotation) {
      case 0:
        return [s, e - r, a, o];
      case 90:
        return [s, e - i, o, a];
      case 180:
        return [n, e - i, a, o];
      case 270:
        return [n, e - r, o, a];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getPDFRect() {
    return this.getRect(0, 0);
  }
  getNonHCMColor() {
    return this.color && U._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
  }
  onUpdatedColor() {
    this.#s?.onUpdatedColor();
  }
  getData() {
    const {
      comment: {
        text: t,
        color: e,
        date: s,
        opacity: i,
        deleted: n,
        richText: r
      },
      uid: a,
      pageIndex: o,
      creationDate: l,
      modificationDate: c
    } = this;
    return {
      id: a,
      pageIndex: o,
      rect: this.getPDFRect(),
      richText: r,
      contentsObj: {
        str: t
      },
      creationDate: l,
      modificationDate: s || c,
      popupRef: !n,
      color: e,
      opacity: i
    };
  }
  onceAdded(t) {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    return this.isInEditMode() ? !1 : (this.parent.setEditingState(!1), this.#v = !0, !0);
  }
  disableEditMode() {
    return this.isInEditMode() ? (this.parent.setEditingState(!0), this.#v = !1, !0) : !1;
  }
  isInEditMode() {
    return this.#v;
  }
  shouldGetKeyboardEvents() {
    return this.#b;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const {
      top: t,
      left: e,
      bottom: s,
      right: i
    } = this.getClientDimensions(), {
      innerHeight: n,
      innerWidth: r
    } = window;
    return e < r && i > 0 && t < n && s > 0;
  }
  #$() {
    if (this.#f || !this.div)
      return;
    this.#f = new AbortController();
    const t = this._uiManager.combinedSignal(this.#f);
    this.div.addEventListener("focusin", this.focusin.bind(this), {
      signal: t
    }), this.div.addEventListener("focusout", this.focusout.bind(this), {
      signal: t
    });
  }
  rebuild() {
    this.#$();
  }
  rotate(t) {
  }
  resize() {
  }
  serializeDeleted() {
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex,
      popupRef: this._initialData?.popupRef || ""
    };
  }
  serialize(t = !1, e = null) {
    return {
      annotationType: this.mode,
      pageIndex: this.pageIndex,
      rect: this.getPDFRect(),
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId,
      popupRef: this._initialData?.popupRef || ""
    };
  }
  static async deserialize(t, e, s) {
    const i = new this.prototype.constructor({
      parent: e,
      id: e.getNextId(),
      uiManager: s,
      annotationElementId: t.annotationElementId,
      creationDate: t.creationDate,
      modificationDate: t.modificationDate
    });
    i.rotation = t.rotation, i.#t = t.accessibilityData, i._isCopy = t.isCopy || !1;
    const [n, r] = i.pageDimensions, [a, o, l, c] = i.getRectInCurrentCoords(t.rect, r);
    return i.x = a / n, i.y = o / r, i.width = l / n, i.height = c / r, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    if (this.#f?.abort(), this.#f = null, this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#y && (clearTimeout(this.#y), this.#y = null), this.#N(), this.removeEditToolbar(), this.#A) {
      for (const t of this.#A.values())
        clearTimeout(t);
      this.#A = null;
    }
    this.parent = null, this.#P?.destroy(), this.#P = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (this.#B(), this.#h.classList.remove("hidden"));
  }
  get toolbarPosition() {
    return null;
  }
  get commentButtonPosition() {
    return this._uiManager.direction === "ltr" ? [1, 0] : [0, 0];
  }
  get commentButtonPositionInPage() {
    const {
      commentButtonPosition: [t, e]
    } = this, [s, i, n, r] = this.getPDFRect();
    return [U._round(s + (n - s) * t), U._round(i + (r - i) * (1 - e))];
  }
  get commentButtonColor() {
    return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
  }
  get commentPopupPosition() {
    return this.#s.commentPopupPositionInLayer;
  }
  set commentPopupPosition(t) {
    this.#s.commentPopupPositionInLayer = t;
  }
  hasDefaultPopupPosition() {
    return this.#s.hasDefaultPopupPosition();
  }
  get commentButtonWidth() {
    return this.#s.commentButtonWidth;
  }
  get elementBeforePopup() {
    return this.div;
  }
  setCommentButtonStates(t) {
    this.#s.setCommentButtonStates(t);
  }
  keydown(t) {
    if (!this.isResizable || t.target !== this.div || t.key !== "Enter")
      return;
    this._uiManager.setSelected(this), this.#u = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const e = this.#h.children;
    if (!this.#e) {
      this.#e = Array.from(e);
      const r = this.#X.bind(this), a = this.#W.bind(this), o = this._uiManager._signal;
      for (const l of this.#e) {
        const c = l.getAttribute("data-resizer-name");
        l.setAttribute("role", "spinbutton"), l.addEventListener("keydown", r, {
          signal: o
        }), l.addEventListener("blur", a, {
          signal: o
        }), l.addEventListener("focus", this.#Y.bind(this, c), {
          signal: o
        }), l.setAttribute("data-l10n-id", U._l10nResizer[c]);
      }
    }
    const s = this.#e[0];
    let i = 0;
    for (const r of e) {
      if (r === s)
        break;
      i++;
    }
    const n = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#e.length / 4);
    if (n !== i) {
      if (n < i)
        for (let a = 0; a < i - n; a++)
          this.#h.append(this.#h.firstChild);
      else if (n > i)
        for (let a = 0; a < n - i; a++)
          this.#h.firstChild.before(this.#h.lastChild);
      let r = 0;
      for (const a of e) {
        const l = this.#e[r++].getAttribute("data-resizer-name");
        a.setAttribute("data-l10n-id", U._l10nResizer[l]);
      }
    }
    this.#j(0), this.#b = !0, this.#h.firstChild.focus({
      focusVisible: !0
    }), t.preventDefault(), t.stopImmediatePropagation();
  }
  #X(t) {
    U._resizerKeyboardManager.exec(this, t);
  }
  #W(t) {
    this.#b && t.relatedTarget?.parentNode !== this.#h && this.#N();
  }
  #Y(t) {
    this.#m = this.#b ? t : "";
  }
  #j(t) {
    if (this.#e)
      for (const e of this.#e)
        e.tabIndex = t;
  }
  _resizeWithKeyboard(t, e) {
    this.#b && this.#F(this.#m, {
      deltaX: t,
      deltaY: e,
      fromKeyboard: !0
    });
  }
  #N() {
    this.#b = !1, this.#j(-1), this.#_();
  }
  _stopResizingWithKeyboard() {
    this.#N(), this.div.focus();
  }
  select() {
    if (this.isSelected && this._editToolbar) {
      this._editToolbar.show();
      return;
    }
    if (this.isSelected = !0, this.makeResizable(), this.div?.classList.add("selectedEditor"), !this._editToolbar) {
      this.addEditToolbar().then(() => {
        this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
      });
      return;
    }
    this._editToolbar?.show(), this.#i?.toggleAltTextBadge(!1);
  }
  focus() {
    this.div && !this.div.contains(document.activeElement) && setTimeout(() => this.div?.focus({
      preventScroll: !0
    }), 0);
  }
  unselect() {
    this.isSelected && (this.isSelected = !1, this.#h?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), this._editToolbar?.hide(), this.#i?.toggleAltTextBadge(!0), this.hasComment && this._uiManager.toggleComment(this, !1, !1));
  }
  updateParams(t, e) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return !1;
  }
  enterInEditMode() {
    this.canChangeContent && (this.enableEditMode(), this.div.focus());
  }
  dblclick(t) {
    t.target.nodeName !== "BUTTON" && (this.enterInEditMode(), this.parent.updateToolbar({
      mode: this.constructor._editorType,
      editId: this.id
    }));
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#g;
  }
  set isEditing(t) {
    this.#g = t, this.parent && (t ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(t, e = !1) {
    if (e) {
      this.#A ||= /* @__PURE__ */ new Map();
      const {
        action: s
      } = t;
      let i = this.#A.get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(t), this.#A.delete(s), this.#A.size === 0 && (this.#A = null);
      }, U._telemetryTimeout), this.#A.set(s, i);
      return;
    }
    t.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: t
      }
    });
  }
  show(t = this._isVisible) {
    this.div.classList.toggle("hidden", !t), this._isVisible = t;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), this.#n = !1;
  }
  disable() {
    this.div && (this.div.tabIndex = -1), this.#n = !0;
  }
  updateFakeAnnotationElement(t) {
    if (!this.#d && !this.deleted) {
      this.#d = t.addFakeAnnotation(this);
      return;
    }
    if (this.deleted) {
      this.#d.remove(), this.#d = null;
      return;
    }
    (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) && this.#d.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    });
  }
  renderAnnotationElement(t) {
    if (this.deleted)
      return t.hide(), null;
    let e = t.container.querySelector(".annotationContent");
    if (!e)
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), t.container.prepend(e);
    else if (e.nodeName === "CANVAS") {
      const s = e;
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), s.before(e);
    }
    return e;
  }
  resetAnnotationElement(t) {
    const {
      firstChild: e
    } = t.container;
    e?.nodeName === "DIV" && e.classList.contains("annotationContent") && e.remove();
  }
}
class zn extends U {
  constructor(t) {
    super(t), this.annotationElementId = t.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return this.serializeDeleted();
  }
}
const Ai = 3285377520, Ut = 4294901760, Kt = 65535;
class qi {
  constructor(t) {
    this.h1 = t ? t & 4294967295 : Ai, this.h2 = t ? t & 4294967295 : Ai;
  }
  update(t) {
    let e, s;
    if (typeof t == "string") {
      e = new Uint8Array(t.length * 2), s = 0;
      for (let p = 0, v = t.length; p < v; p++) {
        const m = t.charCodeAt(p);
        m <= 255 ? e[s++] = m : (e[s++] = m >>> 8, e[s++] = m & 255);
      }
    } else if (ArrayBuffer.isView(t))
      e = t.slice(), s = e.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, n = s - i * 4, r = new Uint32Array(e.buffer, 0, i);
    let a = 0, o = 0, l = this.h1, c = this.h2;
    const d = 3432918353, u = 461845907, f = d & Kt, g = u & Kt;
    for (let p = 0; p < i; p++)
      p & 1 ? (a = r[p], a = a * d & Ut | a * f & Kt, a = a << 15 | a >>> 17, a = a * u & Ut | a * g & Kt, l ^= a, l = l << 13 | l >>> 19, l = l * 5 + 3864292196) : (o = r[p], o = o * d & Ut | o * f & Kt, o = o << 15 | o >>> 17, o = o * u & Ut | o * g & Kt, c ^= o, c = c << 13 | c >>> 19, c = c * 5 + 3864292196);
    switch (a = 0, n) {
      case 3:
        a ^= e[i * 4 + 2] << 16;
      case 2:
        a ^= e[i * 4 + 1] << 8;
      case 1:
        a ^= e[i * 4], a = a * d & Ut | a * f & Kt, a = a << 15 | a >>> 17, a = a * u & Ut | a * g & Kt, i & 1 ? l ^= a : c ^= a;
    }
    this.h1 = l, this.h2 = c;
  }
  hexdigest() {
    let t = this.h1, e = this.h2;
    return t ^= e >>> 1, t = t * 3981806797 & Ut | t * 36045 & Kt, e = e * 4283543511 & Ut | ((e << 16 | t >>> 16) * 2950163797 & Ut) >>> 16, t ^= e >>> 1, t = t * 444984403 & Ut | t * 60499 & Kt, e = e * 3301882366 & Ut | ((e << 16 | t >>> 16) * 3120437893 & Ut) >>> 16, t ^= e >>> 1, (t >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
  }
}
const Fs = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
class Qs {
  #t = !1;
  #e = null;
  #i = null;
  #s = /* @__PURE__ */ new Map();
  constructor() {
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(t, e) {
    const s = this.#s.get(t);
    return s === void 0 ? e : Object.assign(e, s);
  }
  getRawValue(t) {
    return this.#s.get(t);
  }
  remove(t) {
    const e = this.#s.get(t);
    if (e !== void 0 && (e instanceof U && this.#i.delete(e.annotationElementId), this.#s.delete(t), this.#s.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function")) {
      for (const s of this.#s.values())
        if (s instanceof U)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(t, e) {
    const s = this.#s.get(t);
    let i = !1;
    if (s !== void 0)
      for (const [n, r] of Object.entries(e))
        s[n] !== r && (i = !0, s[n] = r);
    else
      i = !0, this.#s.set(t, e);
    i && this.#a(), e instanceof U && ((this.#i ||= /* @__PURE__ */ new Map()).set(e.annotationElementId, e), typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type));
  }
  has(t) {
    return this.#s.has(t);
  }
  get size() {
    return this.#s.size;
  }
  #a() {
    this.#t || (this.#t = !0, typeof this.onSetModified == "function" && this.onSetModified());
  }
  resetModified() {
    this.#t && (this.#t = !1, typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new tn(this);
  }
  get serializable() {
    if (this.#s.size === 0)
      return Fs;
    const t = /* @__PURE__ */ new Map(), e = new qi(), s = [], i = /* @__PURE__ */ Object.create(null);
    let n = !1;
    for (const [r, a] of this.#s) {
      const o = a instanceof U ? a.serialize(!1, i) : a;
      o && (t.set(r, o), e.update(`${r}:${JSON.stringify(o)}`), n ||= !!o.bitmap);
    }
    if (n)
      for (const r of t.values())
        r.bitmap && s.push(r.bitmap);
    return t.size > 0 ? {
      map: t,
      hash: e.hexdigest(),
      transfer: s
    } : Fs;
  }
  get editorStats() {
    let t = null;
    const e = /* @__PURE__ */ new Map();
    let s = 0, i = 0;
    for (const n of this.#s.values()) {
      if (!(n instanceof U)) {
        n.popup && (n.popup.deleted ? i += 1 : s += 1);
        continue;
      }
      n.isCommentDeleted ? i += 1 : n.hasEditedComment && (s += 1);
      const r = n.telemetryFinalData;
      if (!r)
        continue;
      const {
        type: a
      } = r;
      e.has(a) || e.set(a, Object.getPrototypeOf(n).constructor), t ||= /* @__PURE__ */ Object.create(null);
      const o = t[a] ||= /* @__PURE__ */ new Map();
      for (const [l, c] of Object.entries(r)) {
        if (l === "type")
          continue;
        let d = o.get(l);
        d || (d = /* @__PURE__ */ new Map(), o.set(l, d));
        const u = d.get(c) ?? 0;
        d.set(c, u + 1);
      }
    }
    if ((i > 0 || s > 0) && (t ||= /* @__PURE__ */ Object.create(null), t.comments = {
      deleted: i,
      edited: s
    }), !t)
      return null;
    for (const [n, r] of e)
      t[n] = r.computeTelemetryFinalData(t[n]);
    return t;
  }
  resetModifiedIds() {
    this.#e = null;
  }
  updateEditor(t, e) {
    const s = this.#i?.get(t);
    return s ? (s.updateFromAnnotationLayer(e), !0) : !1;
  }
  getEditor(t) {
    return this.#i?.get(t) || null;
  }
  get modifiedIds() {
    if (this.#e)
      return this.#e;
    const t = [];
    if (this.#i)
      for (const e of this.#i.values())
        e.serialize() && t.push(e.annotationElementId);
    return this.#e = {
      ids: new Set(t),
      hash: t.join(",")
    };
  }
  [Symbol.iterator]() {
    return this.#s.entries();
  }
}
class tn extends Qs {
  #t;
  constructor(t) {
    super();
    const {
      map: e,
      hash: s,
      transfer: i
    } = t.serializable, n = structuredClone(e, i ? {
      transfer: i
    } : null);
    this.#t = {
      map: n,
      hash: s,
      transfer: i
    };
  }
  get print() {
    it("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#t;
  }
  get modifiedIds() {
    return K(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
}
class Vn {
  #t = /* @__PURE__ */ new Set();
  constructor({
    ownerDocument: t = globalThis.document,
    styleElement: e = null
  }) {
    this._document = t, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(t) {
    this.nativeFontFaces.add(t), this._document.fonts.add(t);
  }
  removeNativeFontFace(t) {
    this.nativeFontFaces.delete(t), this._document.fonts.delete(t);
  }
  insertRule(t) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const e = this.styleElement.sheet;
    e.insertRule(t, e.cssRules.length);
  }
  clear() {
    for (const t of this.nativeFontFaces)
      this._document.fonts.delete(t);
    this.nativeFontFaces.clear(), this.#t.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: t,
    disableFontFace: e,
    _inspectFont: s
  }) {
    if (!(!t || this.#t.has(t.loadedName))) {
      if (Z(!e, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: i,
          src: n,
          style: r
        } = t, a = new FontFace(i, n, r);
        this.addNativeFontFace(a);
        try {
          await a.load(), this.#t.add(i), s?.(t);
        } catch {
          z(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(a);
        }
        return;
      }
      it("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(t) {
    if (t.attached || t.missingFile && !t.systemFontInfo)
      return;
    if (t.attached = !0, t.systemFontInfo) {
      await this.loadSystemFont(t);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = t.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw z(`Failed to load font '${s.family}': '${i}'.`), t.disableFontFace = !0, i;
        }
      }
      return;
    }
    const e = t.createFontFaceRule();
    if (e) {
      if (this.insertRule(e), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(t, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    const t = !!this._document?.fonts;
    return K(this, "isFontLoadingAPISupported", t);
  }
  get isSyncFontLoadingSupported() {
    return K(this, "isSyncFontLoadingSupported", Rt || wt.platform.isFirefox);
  }
  _queueLoadingCallback(t) {
    function e() {
      for (Z(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const n = s.shift();
        setTimeout(n.callback, 0);
      }
    }
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: e,
      callback: t
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const t = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return K(this, "_loadTestFont", t);
  }
  _prepareFontLoadEvent(t, e) {
    function s(E, A) {
      return E.charCodeAt(A) << 24 | E.charCodeAt(A + 1) << 16 | E.charCodeAt(A + 2) << 8 | E.charCodeAt(A + 3) & 255;
    }
    function i(E, A, w, S) {
      const x = E.substring(0, A), T = E.substring(A + w);
      return x + S + T;
    }
    let n, r;
    const a = this._document.createElement("canvas");
    a.width = 1, a.height = 1;
    const o = a.getContext("2d");
    let l = 0;
    function c(E, A) {
      if (++l > 30) {
        z("Load test font never loaded."), A();
        return;
      }
      if (o.font = "30px " + E, o.fillText(".", 0, 20), o.getImageData(0, 0, 1, 1).data[3] > 0) {
        A();
        return;
      }
      setTimeout(c.bind(null, E, A));
    }
    const d = `lt${Date.now()}${this.loadTestFontId++}`;
    let u = this._loadTestFont;
    u = i(u, 976, d.length, d);
    const g = 16, p = 1482184792;
    let v = s(u, g);
    for (n = 0, r = d.length - 3; n < r; n += 4)
      v = v - p + s(d, n) | 0;
    n < d.length && (v = v - p + s(d + "XXX", n) | 0), u = i(u, g, 4, Dn(v));
    const m = `url(data:font/opentype;base64,${btoa(u)});`, b = `@font-face {font-family:"${d}";src:${m}}`;
    this.insertRule(b);
    const y = this._document.createElement("div");
    y.style.visibility = "hidden", y.style.width = y.style.height = "10px", y.style.position = "absolute", y.style.top = y.style.left = "0px";
    for (const E of [t.loadedName, d]) {
      const A = this._document.createElement("span");
      A.textContent = "Hi", A.style.fontFamily = E, y.append(A);
    }
    this._document.body.append(y), c(d, () => {
      y.remove(), e.complete();
    });
  }
}
class Gn {
  #t;
  constructor(t, e = null, s, i) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.#t = t, this._inspectFont = e, s && Object.assign(this, s), i && (this.charProcOperatorList = i);
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace)
      return null;
    let t;
    if (!this.cssFontInfo)
      t = new FontFace(this.loadedName, this.data, {});
    else {
      const e = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (e.style = `oblique ${this.cssFontInfo.italicAngle}deg`), t = new FontFace(this.cssFontInfo.fontFamily, this.data, e);
    }
    return this._inspectFont?.(this), t;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace)
      return null;
    const t = `url(data:${this.mimetype};base64,${Gi(this.data)});`;
    let e;
    if (!this.cssFontInfo)
      e = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
    else {
      let s = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (s += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), e = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${s}src:${t}}`;
    }
    return this._inspectFont?.(this, t), e;
  }
  getPathGenerator(t, e) {
    if (this.compiledGlyphs[e] !== void 0)
      return this.compiledGlyphs[e];
    const s = this.loadedName + "_path_" + e;
    let i;
    try {
      i = t.get(s);
    } catch (r) {
      z(`getPathGenerator - ignoring character: "${r}".`);
    }
    const n = new Path2D(i || "");
    return this.fontExtraProperties || t.delete(s), this.compiledGlyphs[e] = n;
  }
  get black() {
    return this.#t.black;
  }
  get bold() {
    return this.#t.bold;
  }
  get disableFontFace() {
    return this.#t.disableFontFace ?? !1;
  }
  get fontExtraProperties() {
    return this.#t.fontExtraProperties ?? !1;
  }
  get isInvalidPDFjsFont() {
    return this.#t.isInvalidPDFjsFont;
  }
  get isType3Font() {
    return this.#t.isType3Font;
  }
  get italic() {
    return this.#t.italic;
  }
  get missingFile() {
    return this.#t.missingFile;
  }
  get remeasure() {
    return this.#t.remeasure;
  }
  get vertical() {
    return this.#t.vertical;
  }
  get ascent() {
    return this.#t.ascent;
  }
  get defaultWidth() {
    return this.#t.defaultWidth;
  }
  get descent() {
    return this.#t.descent;
  }
  get bbox() {
    return this.#t.bbox;
  }
  get fontMatrix() {
    return this.#t.fontMatrix;
  }
  get fallbackName() {
    return this.#t.fallbackName;
  }
  get loadedName() {
    return this.#t.loadedName;
  }
  get mimetype() {
    return this.#t.mimetype;
  }
  get name() {
    return this.#t.name;
  }
  get data() {
    return this.#t.data;
  }
  clearData() {
    this.#t.clearData();
  }
  get cssFontInfo() {
    return this.#t.cssFontInfo;
  }
  get systemFontInfo() {
    return this.#t.systemFontInfo;
  }
  get defaultVMetrics() {
    return this.#t.defaultVMetrics;
  }
}
function Wn(h) {
  if (h instanceof URL)
    return h.href;
  if (typeof h == "string") {
    if (Rt)
      return h;
    const t = URL.parse(h, window.location);
    if (t)
      return t.href;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function Xn(h) {
  if (Rt && typeof Buffer < "u" && h instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (h instanceof Uint8Array && h.byteLength === h.buffer.byteLength)
    return h;
  if (typeof h == "string")
    return Ge(h);
  if (h instanceof ArrayBuffer || ArrayBuffer.isView(h) || typeof h == "object" && !isNaN(h?.length))
    return new Uint8Array(h);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function es(h) {
  if (typeof h != "string")
    return null;
  if (h.endsWith("/"))
    return h;
  throw new Error(`Invalid factory url: "${h}" must include trailing slash.`);
}
const Ns = (h) => typeof h == "object" && Number.isInteger(h?.num) && h.num >= 0 && Number.isInteger(h?.gen) && h.gen >= 0, Yn = (h) => typeof h == "object" && typeof h?.name == "string", en = Fn.bind(null, Ns, Yn);
class Kn {
  #t = /* @__PURE__ */ new Map();
  #e = Promise.resolve();
  postMessage(t, e) {
    const s = {
      data: structuredClone(t, e ? {
        transfer: e
      } : null)
    };
    this.#e.then(() => {
      for (const [i] of this.#t)
        i.call(this, s);
    });
  }
  addEventListener(t, e, s = null) {
    let i = null;
    if (s?.signal instanceof AbortSignal) {
      const {
        signal: n
      } = s;
      if (n.aborted) {
        z("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const r = () => this.removeEventListener(t, e);
      i = () => n.removeEventListener("abort", r), n.addEventListener("abort", r);
    }
    this.#t.set(e, i);
  }
  removeEventListener(t, e) {
    this.#t.get(e)?.(), this.#t.delete(e);
  }
  terminate() {
    for (const [, t] of this.#t)
      t?.();
    this.#t.clear();
  }
}
const ss = {
  DATA: 1,
  ERROR: 2
}, gt = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wi() {
}
function Lt(h) {
  if (h instanceof ie || h instanceof ds || h instanceof fi || h instanceof $e || h instanceof Ts)
    return h;
  switch (h instanceof Error || typeof h == "object" && h !== null || it('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), h.name) {
    case "AbortException":
      return new ie(h.message);
    case "InvalidPDFException":
      return new ds(h.message);
    case "PasswordException":
      return new fi(h.message, h.code);
    case "ResponseException":
      return new $e(h.message, h.status, h.missing);
    case "UnknownErrorException":
      return new Ts(h.message, h.details);
  }
  return new Ts(h.message, h.toString());
}
class Be {
  #t = new AbortController();
  constructor(t, e, s) {
    this.sourceName = t, this.targetName = e, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), s.addEventListener("message", this.#e.bind(this), {
      signal: this.#t.signal
    });
  }
  #e({
    data: t
  }) {
    if (t.targetName !== this.sourceName)
      return;
    if (t.stream) {
      this.#s(t);
      return;
    }
    if (t.callback) {
      const s = t.callbackId, i = this.callbackCapabilities[s];
      if (!i)
        throw new Error(`Cannot resolve callback ${s}`);
      if (delete this.callbackCapabilities[s], t.callback === ss.DATA)
        i.resolve(t.data);
      else if (t.callback === ss.ERROR)
        i.reject(Lt(t.reason));
      else
        throw new Error("Unexpected callback case");
      return;
    }
    const e = this.actionHandler[t.action];
    if (!e)
      throw new Error(`Unknown action from worker: ${t.action}`);
    if (t.callbackId) {
      const s = this.sourceName, i = t.sourceName, n = this.comObj;
      Promise.try(e, t.data).then(function(r) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          callback: ss.DATA,
          callbackId: t.callbackId,
          data: r
        });
      }, function(r) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          callback: ss.ERROR,
          callbackId: t.callbackId,
          reason: Lt(r)
        });
      });
      return;
    }
    if (t.streamId) {
      this.#i(t);
      return;
    }
    e(t.data);
  }
  on(t, e) {
    const s = this.actionHandler;
    if (s[t])
      throw new Error(`There is already an actionName called "${t}"`);
    s[t] = e;
  }
  send(t, e, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: t,
      data: e
    }, s);
  }
  sendWithPromise(t, e, s) {
    const i = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[i] = n;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: t,
        callbackId: i,
        data: e
      }, s);
    } catch (r) {
      n.reject(r);
    }
    return n.promise;
  }
  sendWithStream(t, e, s, i) {
    const n = this.streamId++, r = this.sourceName, a = this.targetName, o = this.comObj;
    return new ReadableStream({
      start: (l) => {
        const c = Promise.withResolvers();
        return this.streamControllers[n] = {
          controller: l,
          startCall: c,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, o.postMessage({
          sourceName: r,
          targetName: a,
          action: t,
          streamId: n,
          data: e,
          desiredSize: l.desiredSize
        }, i), c.promise;
      },
      pull: (l) => {
        const c = Promise.withResolvers();
        return this.streamControllers[n].pullCall = c, o.postMessage({
          sourceName: r,
          targetName: a,
          stream: gt.PULL,
          streamId: n,
          desiredSize: l.desiredSize
        }), c.promise;
      },
      cancel: (l) => {
        Z(l instanceof Error, "cancel must have a valid reason");
        const c = Promise.withResolvers();
        return this.streamControllers[n].cancelCall = c, this.streamControllers[n].isClosed = !0, o.postMessage({
          sourceName: r,
          targetName: a,
          stream: gt.CANCEL,
          streamId: n,
          reason: Lt(l)
        }), c.promise;
      }
    }, s);
  }
  #i(t) {
    const e = t.streamId, s = this.sourceName, i = t.sourceName, n = this.comObj, r = this, a = this.actionHandler[t.action], o = {
      enqueue(l, c = 1, d) {
        if (this.isCancelled)
          return;
        const u = this.desiredSize;
        this.desiredSize -= c, u > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({
          sourceName: s,
          targetName: i,
          stream: gt.ENQUEUE,
          streamId: e,
          chunk: l
        }, d);
      },
      close() {
        this.isCancelled || (this.isCancelled = !0, n.postMessage({
          sourceName: s,
          targetName: i,
          stream: gt.CLOSE,
          streamId: e
        }), delete r.streamSinks[e]);
      },
      error(l) {
        Z(l instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, n.postMessage({
          sourceName: s,
          targetName: i,
          stream: gt.ERROR,
          streamId: e,
          reason: Lt(l)
        }));
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: !1,
      desiredSize: t.desiredSize,
      ready: null
    };
    o.sinkCapability.resolve(), o.ready = o.sinkCapability.promise, this.streamSinks[e] = o, Promise.try(a, t.data, o).then(function() {
      n.postMessage({
        sourceName: s,
        targetName: i,
        stream: gt.START_COMPLETE,
        streamId: e,
        success: !0
      });
    }, function(l) {
      n.postMessage({
        sourceName: s,
        targetName: i,
        stream: gt.START_COMPLETE,
        streamId: e,
        reason: Lt(l)
      });
    });
  }
  #s(t) {
    const e = t.streamId, s = this.sourceName, i = t.sourceName, n = this.comObj, r = this.streamControllers[e], a = this.streamSinks[e];
    switch (t.stream) {
      case gt.START_COMPLETE:
        t.success ? r.startCall.resolve() : r.startCall.reject(Lt(t.reason));
        break;
      case gt.PULL_COMPLETE:
        t.success ? r.pullCall.resolve() : r.pullCall.reject(Lt(t.reason));
        break;
      case gt.PULL:
        if (!a) {
          n.postMessage({
            sourceName: s,
            targetName: i,
            stream: gt.PULL_COMPLETE,
            streamId: e,
            success: !0
          });
          break;
        }
        a.desiredSize <= 0 && t.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = t.desiredSize, Promise.try(a.onPull || wi).then(function() {
          n.postMessage({
            sourceName: s,
            targetName: i,
            stream: gt.PULL_COMPLETE,
            streamId: e,
            success: !0
          });
        }, function(l) {
          n.postMessage({
            sourceName: s,
            targetName: i,
            stream: gt.PULL_COMPLETE,
            streamId: e,
            reason: Lt(l)
          });
        });
        break;
      case gt.ENQUEUE:
        if (Z(r, "enqueue should have stream controller"), r.isClosed)
          break;
        r.controller.enqueue(t.chunk);
        break;
      case gt.CLOSE:
        if (Z(r, "close should have stream controller"), r.isClosed)
          break;
        r.isClosed = !0, r.controller.close(), this.#a(r, e);
        break;
      case gt.ERROR:
        Z(r, "error should have stream controller"), r.controller.error(Lt(t.reason)), this.#a(r, e);
        break;
      case gt.CANCEL_COMPLETE:
        t.success ? r.cancelCall.resolve() : r.cancelCall.reject(Lt(t.reason)), this.#a(r, e);
        break;
      case gt.CANCEL:
        if (!a)
          break;
        const o = Lt(t.reason);
        Promise.try(a.onCancel || wi, o).then(function() {
          n.postMessage({
            sourceName: s,
            targetName: i,
            stream: gt.CANCEL_COMPLETE,
            streamId: e,
            success: !0
          });
        }, function(l) {
          n.postMessage({
            sourceName: s,
            targetName: i,
            stream: gt.CANCEL_COMPLETE,
            streamId: e,
            reason: Lt(l)
          });
        }), a.sinkCapability.reject(o), a.isCancelled = !0, delete this.streamSinks[e];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #a(t, e) {
    await Promise.allSettled([t.startCall?.promise, t.pullCall?.promise, t.cancelCall?.promise]), delete this.streamControllers[e];
  }
  destroy() {
    this.#t?.abort(), this.#t = null;
  }
}
class sn {
  #t = !1;
  constructor({
    enableHWA: t = !1
  }) {
    this.#t = t;
  }
  create(t, e) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(t, e);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !this.#t
      })
    };
  }
  reset(t, e, s) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    if (e <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    t.canvas.width = e, t.canvas.height = s;
  }
  destroy(t) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
  }
  _createCanvas(t, e) {
    it("Abstract method `_createCanvas` called.");
  }
}
class Jn extends sn {
  constructor({
    ownerDocument: t = globalThis.document,
    enableHWA: e = !1
  }) {
    super({
      enableHWA: e
    }), this._document = t;
  }
  _createCanvas(t, e) {
    const s = this._document.createElement("canvas");
    return s.width = t, s.height = e, s;
  }
}
class nn {
  constructor({
    baseUrl: t = null,
    isCompressed: e = !0
  }) {
    this.baseUrl = t, this.isCompressed = e;
  }
  async fetch({
    name: t
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!t)
      throw new Error("CMap name must be specified.");
    const e = this.baseUrl + t + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(e).then((s) => ({
      cMapData: s,
      isCompressed: this.isCompressed
    })).catch((s) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e}`);
    });
  }
  async _fetch(t) {
    it("Abstract method `_fetch` called.");
  }
}
class Ei extends nn {
  async _fetch(t) {
    const e = await Me(t, this.isCompressed ? "arraybuffer" : "text");
    return e instanceof ArrayBuffer ? new Uint8Array(e) : Ge(e);
  }
}
W(2489);
class rn {
  addFilter(t) {
    return "none";
  }
  addHCMFilter(t, e) {
    return "none";
  }
  addAlphaFilter(t) {
    return "none";
  }
  addLuminosityFilter(t) {
    return "none";
  }
  addHighlightHCMFilter(t, e, s, i, n) {
    return "none";
  }
  destroy(t = !1) {
  }
}
class Qn extends rn {
  #t;
  #e;
  #i;
  #s;
  #a;
  #n;
  #r = 0;
  constructor({
    docId: t,
    ownerDocument: e = globalThis.document
  }) {
    super(), this.#s = t, this.#a = e;
  }
  get #o() {
    return this.#e ||= /* @__PURE__ */ new Map();
  }
  get #h() {
    return this.#n ||= /* @__PURE__ */ new Map();
  }
  get #l() {
    if (!this.#i) {
      const t = this.#a.createElement("div"), {
        style: e
      } = t;
      e.visibility = "hidden", e.contain = "strict", e.width = e.height = 0, e.position = "absolute", e.top = e.left = 0, e.zIndex = -1;
      const s = this.#a.createElementNS(qt, "svg");
      s.setAttribute("width", 0), s.setAttribute("height", 0), this.#i = this.#a.createElementNS(qt, "defs"), t.append(s), s.append(this.#i), this.#a.body.append(t);
    }
    return this.#i;
  }
  #u(t) {
    if (t.length === 1) {
      const o = t[0], l = new Array(256);
      for (let d = 0; d < 256; d++)
        l[d] = o[d] / 255;
      const c = l.join(",");
      return [c, c, c];
    }
    const [e, s, i] = t, n = new Array(256), r = new Array(256), a = new Array(256);
    for (let o = 0; o < 256; o++)
      n[o] = e[o] / 255, r[o] = s[o] / 255, a[o] = i[o] / 255;
    return [n.join(","), r.join(","), a.join(",")];
  }
  #d(t) {
    if (this.#t === void 0) {
      this.#t = "";
      const e = this.#a.URL;
      e !== this.#a.baseURI && (Xe(e) ? z('#createUrl: ignore "data:"-URL for performance reasons.') : this.#t = Vs(e, ""));
    }
    return `url(${this.#t}#${t})`;
  }
  addFilter(t) {
    if (!t)
      return "none";
    let e = this.#o.get(t);
    if (e)
      return e;
    const [s, i, n] = this.#u(t), r = t.length === 1 ? s : `${s}${i}${n}`;
    if (e = this.#o.get(r), e)
      return this.#o.set(t, e), e;
    const a = `g_${this.#s}_transfer_map_${this.#r++}`, o = this.#d(a);
    this.#o.set(t, o), this.#o.set(r, o);
    const l = this.#p(a);
    return this.#g(s, i, n, l), o;
  }
  addHCMFilter(t, e) {
    const s = `${t}-${e}`, i = "base";
    let n = this.#h.get(i);
    if (n?.key === s || (n ? (n.filter?.remove(), n.key = s, n.url = "none", n.filter = null) : (n = {
      key: s,
      url: "none",
      filter: null
    }, this.#h.set(i, n)), !t || !e))
      return n.url;
    const r = this.#b(t);
    t = B.makeHexColor(...r);
    const a = this.#b(e);
    if (e = B.makeHexColor(...a), this.#l.style.color = "", t === "#000000" && e === "#ffffff" || t === e)
      return n.url;
    const o = new Array(256);
    for (let f = 0; f <= 255; f++) {
      const g = f / 255;
      o[f] = g <= 0.03928 ? g / 12.92 : ((g + 0.055) / 1.055) ** 2.4;
    }
    const l = o.join(","), c = `g_${this.#s}_hcm_filter`, d = n.filter = this.#p(c);
    this.#g(l, l, l, d), this.#m(d);
    const u = (f, g) => {
      const p = r[f] / 255, v = a[f] / 255, m = new Array(g + 1);
      for (let b = 0; b <= g; b++)
        m[b] = p + b / g * (v - p);
      return m.join(",");
    };
    return this.#g(u(0, 5), u(1, 5), u(2, 5), d), n.url = this.#d(c), n.url;
  }
  addAlphaFilter(t) {
    let e = this.#o.get(t);
    if (e)
      return e;
    const [s] = this.#u([t]), i = `alpha_${s}`;
    if (e = this.#o.get(i), e)
      return this.#o.set(t, e), e;
    const n = `g_${this.#s}_alpha_map_${this.#r++}`, r = this.#d(n);
    this.#o.set(t, r), this.#o.set(i, r);
    const a = this.#p(n);
    return this.#v(s, a), r;
  }
  addLuminosityFilter(t) {
    let e = this.#o.get(t || "luminosity");
    if (e)
      return e;
    let s, i;
    if (t ? ([s] = this.#u([t]), i = `luminosity_${s}`) : i = "luminosity", e = this.#o.get(i), e)
      return this.#o.set(t, e), e;
    const n = `g_${this.#s}_luminosity_map_${this.#r++}`, r = this.#d(n);
    this.#o.set(t, r), this.#o.set(i, r);
    const a = this.#p(n);
    return this.#f(a), t && this.#v(s, a), r;
  }
  addHighlightHCMFilter(t, e, s, i, n) {
    const r = `${e}-${s}-${i}-${n}`;
    let a = this.#h.get(t);
    if (a?.key === r || (a ? (a.filter?.remove(), a.key = r, a.url = "none", a.filter = null) : (a = {
      key: r,
      url: "none",
      filter: null
    }, this.#h.set(t, a)), !e || !s))
      return a.url;
    const [o, l] = [e, s].map(this.#b.bind(this));
    let c = Math.round(0.2126 * o[0] + 0.7152 * o[1] + 0.0722 * o[2]), d = Math.round(0.2126 * l[0] + 0.7152 * l[1] + 0.0722 * l[2]), [u, f] = [i, n].map(this.#b.bind(this));
    d < c && ([c, d, u, f] = [d, c, f, u]), this.#l.style.color = "";
    const g = (m, b, y) => {
      const E = new Array(256), A = (d - c) / y, w = m / 255, S = (b - m) / (255 * y);
      let x = 0;
      for (let T = 0; T <= y; T++) {
        const C = Math.round(c + T * A), P = w + T * S;
        for (let O = x; O <= C; O++)
          E[O] = P;
        x = C + 1;
      }
      for (let T = x; T < 256; T++)
        E[T] = E[x - 1];
      return E.join(",");
    }, p = `g_${this.#s}_hcm_${t}_filter`, v = a.filter = this.#p(p);
    return this.#m(v), this.#g(g(u[0], f[0], 5), g(u[1], f[1], 5), g(u[2], f[2], 5), v), a.url = this.#d(p), a.url;
  }
  destroy(t = !1) {
    t && this.#n?.size || (this.#i?.parentNode.parentNode.remove(), this.#i = null, this.#e?.clear(), this.#e = null, this.#n?.clear(), this.#n = null, this.#r = 0);
  }
  #f(t) {
    const e = this.#a.createElementNS(qt, "feColorMatrix");
    e.setAttribute("type", "matrix"), e.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), t.append(e);
  }
  #m(t) {
    const e = this.#a.createElementNS(qt, "feColorMatrix");
    e.setAttribute("type", "matrix"), e.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), t.append(e);
  }
  #p(t) {
    const e = this.#a.createElementNS(qt, "filter");
    return e.setAttribute("color-interpolation-filters", "sRGB"), e.setAttribute("id", t), this.#l.append(e), e;
  }
  #c(t, e, s) {
    const i = this.#a.createElementNS(qt, e);
    i.setAttribute("type", "discrete"), i.setAttribute("tableValues", s), t.append(i);
  }
  #g(t, e, s, i) {
    const n = this.#a.createElementNS(qt, "feComponentTransfer");
    i.append(n), this.#c(n, "feFuncR", t), this.#c(n, "feFuncG", e), this.#c(n, "feFuncB", s);
  }
  #v(t, e) {
    const s = this.#a.createElementNS(qt, "feComponentTransfer");
    e.append(s), this.#c(s, "feFuncA", t);
  }
  #b(t) {
    return this.#l.style.color = t, De(getComputedStyle(this.#l).getPropertyValue("color"));
  }
}
class an {
  constructor({
    baseUrl: t = null
  }) {
    this.baseUrl = t;
  }
  async fetch({
    filename: t
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!t)
      throw new Error("Font filename must be specified.");
    const e = `${this.baseUrl}${t}`;
    return this._fetch(e).catch((s) => {
      throw new Error(`Unable to load font data at: ${e}`);
    });
  }
  async _fetch(t) {
    it("Abstract method `_fetch` called.");
  }
}
class Si extends an {
  async _fetch(t) {
    const e = await Me(t, "arraybuffer");
    return new Uint8Array(e);
  }
}
class on {
  constructor({
    baseUrl: t = null
  }) {
    this.baseUrl = t;
  }
  async fetch({
    filename: t
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    if (!t)
      throw new Error("Wasm filename must be specified.");
    const e = `${this.baseUrl}${t}`;
    return this._fetch(e).catch((s) => {
      throw new Error(`Unable to load wasm data at: ${e}`);
    });
  }
  async _fetch(t) {
    it("Abstract method `_fetch` called.");
  }
}
class xi extends on {
  async _fetch(t) {
    const e = await Me(t, "arraybuffer");
    return new Uint8Array(e);
  }
}
if (Rt) {
  let h;
  try {
    const t = process.getBuiltinModule("module").createRequire(import.meta.url);
    try {
      h = t("@napi-rs/canvas");
    } catch (e) {
      z(`Cannot load "@napi-rs/canvas" package: "${e}".`);
    }
  } catch (t) {
    z(`Cannot access the \`require\` function: "${t}".`);
  }
  globalThis.DOMMatrix || (h?.DOMMatrix ? globalThis.DOMMatrix = h.DOMMatrix : z("Cannot polyfill `DOMMatrix`, rendering may be broken.")), globalThis.ImageData || (h?.ImageData ? globalThis.ImageData = h.ImageData : z("Cannot polyfill `ImageData`, rendering may be broken.")), globalThis.Path2D || (h?.Path2D ? globalThis.Path2D = h.Path2D : z("Cannot polyfill `Path2D`, rendering may be broken.")), globalThis.navigator?.language || (globalThis.navigator = {
    language: "en-US",
    platform: "",
    userAgent: ""
  });
}
async function Zs(h) {
  const e = await process.getBuiltinModule("fs").promises.readFile(h);
  return new Uint8Array(e);
}
class Zn extends rn {
}
class qn extends sn {
  _createCanvas(t, e) {
    return process.getBuiltinModule("module").createRequire(import.meta.url)("@napi-rs/canvas").createCanvas(t, e);
  }
}
class tr extends nn {
  async _fetch(t) {
    return Zs(t);
  }
}
class er extends an {
  async _fetch(t) {
    return Zs(t);
  }
}
class sr extends on {
  async _fetch(t) {
    return Zs(t);
  }
}
W(7588);
const ye = "__forcedDependency", {
  floor: Ti,
  ceil: Ci
} = Math;
function is(h, t, e, s, i, n) {
  h[t * 4 + 0] = Math.min(h[t * 4 + 0], e), h[t * 4 + 1] = Math.min(h[t * 4 + 1], s), h[t * 4 + 2] = Math.max(h[t * 4 + 2], i), h[t * 4 + 3] = Math.max(h[t * 4 + 3], n);
}
const Bs = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
class ir {
  #t;
  #e;
  constructor(t, e) {
    this.#t = t, this.#e = e;
  }
  get length() {
    return this.#t.length;
  }
  isEmpty(t) {
    return this.#t[t] === Bs;
  }
  minX(t) {
    return this.#e[t * 4 + 0] / 256;
  }
  minY(t) {
    return this.#e[t * 4 + 1] / 256;
  }
  maxX(t) {
    return (this.#e[t * 4 + 2] + 1) / 256;
  }
  maxY(t) {
    return (this.#e[t * 4 + 3] + 1) / 256;
  }
}
const ns = (h, t) => {
  if (!h)
    return;
  let e = h.get(t);
  return e || (e = {
    dependencies: /* @__PURE__ */ new Set(),
    isRenderingOperation: !1
  }, h.set(t, e)), e;
};
class nr {
  #t = {
    __proto__: null
  };
  #e = {
    __proto__: null,
    transform: [],
    moveText: [],
    sameLineText: [],
    [ye]: []
  };
  #i = /* @__PURE__ */ new Map();
  #s = [];
  #a = [];
  #n = [[1, 0, 0, 1, 0, 0]];
  #r = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
  #o = new Float64Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  #h = -1;
  #l = /* @__PURE__ */ new Set();
  #u = /* @__PURE__ */ new Map();
  #d = /* @__PURE__ */ new Map();
  #f;
  #m;
  #p;
  #c;
  #g;
  constructor(t, e, s = !1) {
    this.#f = t.width, this.#m = t.height, this.#v(e), s && (this.#g = /* @__PURE__ */ new Map());
  }
  growOperationsCount(t) {
    t >= this.#c.length && this.#v(t, this.#c);
  }
  #v(t, e) {
    const s = new ArrayBuffer(t * 4);
    this.#p = new Uint8ClampedArray(s), this.#c = new Uint32Array(s), e && e.length > 0 ? (this.#c.set(e), this.#c.fill(Bs, e.length)) : this.#c.fill(Bs);
  }
  save(t) {
    return this.#t = {
      __proto__: this.#t
    }, this.#e = {
      __proto__: this.#e,
      transform: {
        __proto__: this.#e.transform
      },
      moveText: {
        __proto__: this.#e.moveText
      },
      sameLineText: {
        __proto__: this.#e.sameLineText
      },
      [ye]: {
        __proto__: this.#e[ye]
      }
    }, this.#r = {
      __proto__: this.#r
    }, this.#s.push(t), this;
  }
  restore(t) {
    const e = Object.getPrototypeOf(this.#t);
    if (e === null)
      return this;
    this.#t = e, this.#e = Object.getPrototypeOf(this.#e), this.#r = Object.getPrototypeOf(this.#r);
    const s = this.#s.pop();
    return s !== void 0 && (ns(this.#g, t)?.dependencies.add(s), this.#c[t] = this.#c[s]), this;
  }
  recordOpenMarker(t) {
    return this.#s.push(t), this;
  }
  getOpenMarker() {
    return this.#s.length === 0 ? null : this.#s.at(-1);
  }
  recordCloseMarker(t) {
    const e = this.#s.pop();
    return e !== void 0 && (ns(this.#g, t)?.dependencies.add(e), this.#c[t] = this.#c[e]), this;
  }
  beginMarkedContent(t) {
    return this.#a.push(t), this;
  }
  endMarkedContent(t) {
    const e = this.#a.pop();
    return e !== void 0 && (ns(this.#g, t)?.dependencies.add(e), this.#c[t] = this.#c[e]), this;
  }
  pushBaseTransform(t) {
    return this.#n.push(B.multiplyByDOMMatrix(this.#n.at(-1), t.getTransform())), this;
  }
  popBaseTransform() {
    return this.#n.length > 1 && this.#n.pop(), this;
  }
  recordSimpleData(t, e) {
    return this.#t[t] = e, this;
  }
  recordIncrementalData(t, e) {
    return this.#e[t].push(e), this;
  }
  resetIncrementalData(t, e) {
    return this.#e[t].length = 0, this;
  }
  recordNamedData(t, e) {
    return this.#i.set(t, e), this;
  }
  recordSimpleDataFromNamed(t, e, s) {
    this.#t[t] = this.#i.get(e) ?? s;
  }
  recordFutureForcedDependency(t, e) {
    return this.recordIncrementalData(ye, e), this;
  }
  inheritSimpleDataAsFutureForcedDependencies(t) {
    for (const e of t)
      e in this.#t && this.recordFutureForcedDependency(e, this.#t[e]);
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    for (const t of this.#l)
      this.recordFutureForcedDependency(ye, t);
    return this;
  }
  resetBBox(t) {
    return this.#h !== t && (this.#h = t, this.#o[0] = 1 / 0, this.#o[1] = 1 / 0, this.#o[2] = -1 / 0, this.#o[3] = -1 / 0), this;
  }
  recordClipBox(t, e, s, i, n, r) {
    const a = B.multiplyByDOMMatrix(this.#n.at(-1), e.getTransform()), o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    B.axialAlignedBoundingBox([s, n, i, r], a, o);
    const l = B.intersect(this.#r, o);
    return l ? (this.#r[0] = l[0], this.#r[1] = l[1], this.#r[2] = l[2], this.#r[3] = l[3]) : (this.#r[0] = this.#r[1] = 1 / 0, this.#r[2] = this.#r[3] = -1 / 0), this;
  }
  recordBBox(t, e, s, i, n, r) {
    const a = this.#r;
    if (a[0] === 1 / 0)
      return this;
    const o = B.multiplyByDOMMatrix(this.#n.at(-1), e.getTransform());
    if (a[0] === -1 / 0)
      return B.axialAlignedBoundingBox([s, n, i, r], o, this.#o), this;
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return B.axialAlignedBoundingBox([s, n, i, r], o, l), this.#o[0] = Math.min(this.#o[0], Math.max(l[0], a[0])), this.#o[1] = Math.min(this.#o[1], Math.max(l[1], a[1])), this.#o[2] = Math.max(this.#o[2], Math.min(l[2], a[2])), this.#o[3] = Math.max(this.#o[3], Math.min(l[3], a[3])), this;
  }
  recordCharacterBBox(t, e, s, i = 1, n = 0, r = 0, a) {
    const o = s.bbox;
    let l, c;
    if (o && (l = o[2] !== o[0] && o[3] !== o[1] && this.#d.get(s), l !== !1 && (c = [0, 0, 0, 0], B.axialAlignedBoundingBox(o, s.fontMatrix, c), (i !== 1 || n !== 0 || r !== 0) && B.scaleMinMax([i, 0, 0, -i, n, r], c), l)))
      return this.recordBBox(t, e, c[0], c[2], c[1], c[3]);
    if (!a)
      return this.recordFullPageBBox(t);
    const d = a();
    return o && c && l === void 0 && (l = c[0] <= n - d.actualBoundingBoxLeft && c[2] >= n + d.actualBoundingBoxRight && c[1] <= r - d.actualBoundingBoxAscent && c[3] >= r + d.actualBoundingBoxDescent, this.#d.set(s, l), l) ? this.recordBBox(t, e, c[0], c[2], c[1], c[3]) : this.recordBBox(t, e, n - d.actualBoundingBoxLeft, n + d.actualBoundingBoxRight, r - d.actualBoundingBoxAscent, r + d.actualBoundingBoxDescent);
  }
  recordFullPageBBox(t) {
    return this.#o[0] = Math.max(0, this.#r[0]), this.#o[1] = Math.max(0, this.#r[1]), this.#o[2] = Math.min(this.#f, this.#r[2]), this.#o[3] = Math.min(this.#m, this.#r[3]), this;
  }
  getSimpleIndex(t) {
    return this.#t[t];
  }
  recordDependencies(t, e) {
    const s = this.#l, i = this.#t, n = this.#e;
    for (const r of e)
      r in this.#t ? s.add(i[r]) : r in n && n[r].forEach(s.add, s);
    return this;
  }
  recordNamedDependency(t, e) {
    return this.#i.has(e) && this.#l.add(this.#i.get(e)), this;
  }
  recordOperation(t, e = !1) {
    if (this.recordDependencies(t, [ye]), this.#g) {
      const s = ns(this.#g, t), {
        dependencies: i
      } = s;
      this.#l.forEach(i.add, i), this.#s.forEach(i.add, i), this.#a.forEach(i.add, i), i.delete(t), s.isRenderingOperation = !0;
    }
    if (this.#h === t) {
      const s = Ti(this.#o[0] * 256 / this.#f), i = Ti(this.#o[1] * 256 / this.#m), n = Ci(this.#o[2] * 256 / this.#f), r = Ci(this.#o[3] * 256 / this.#m);
      is(this.#p, t, s, i, n, r);
      for (const a of this.#l)
        a !== t && is(this.#p, a, s, i, n, r);
      for (const a of this.#s)
        a !== t && is(this.#p, a, s, i, n, r);
      for (const a of this.#a)
        a !== t && is(this.#p, a, s, i, n, r);
      e || (this.#l.clear(), this.#h = -1);
    }
    return this;
  }
  recordShowTextOperation(t, e = !1) {
    const s = Array.from(this.#l);
    this.recordOperation(t, e), this.recordIncrementalData("sameLineText", t);
    for (const i of s)
      this.recordIncrementalData("sameLineText", i);
    return this;
  }
  bboxToClipBoxDropOperation(t, e = !1) {
    return this.#h === t && (this.#h = -1, this.#r[0] = Math.max(this.#r[0], this.#o[0]), this.#r[1] = Math.max(this.#r[1], this.#o[1]), this.#r[2] = Math.min(this.#r[2], this.#o[2]), this.#r[3] = Math.min(this.#r[3], this.#o[3]), e || this.#l.clear()), this;
  }
  _takePendingDependencies() {
    const t = this.#l;
    return this.#l = /* @__PURE__ */ new Set(), t;
  }
  _extractOperation(t) {
    const e = this.#u.get(t);
    return this.#u.delete(t), e;
  }
  _pushPendingDependencies(t) {
    for (const e of t)
      this.#l.add(e);
  }
  take() {
    return this.#d.clear(), new ir(this.#c, this.#p);
  }
  takeDebugMetadata() {
    return this.#g;
  }
}
class fs {
  #t;
  #e;
  #i;
  #s = 0;
  #a = 0;
  constructor(t, e, s) {
    if (t instanceof fs && t.#i === !!s)
      return t;
    this.#t = t, this.#e = e, this.#i = !!s;
  }
  growOperationsCount() {
    throw new Error("Unreachable");
  }
  save(t) {
    return this.#a++, this.#t.save(this.#e), this;
  }
  restore(t) {
    return this.#a > 0 && (this.#t.restore(this.#e), this.#a--), this;
  }
  recordOpenMarker(t) {
    return this.#s++, this;
  }
  getOpenMarker() {
    return this.#s > 0 ? this.#e : this.#t.getOpenMarker();
  }
  recordCloseMarker(t) {
    return this.#s--, this;
  }
  beginMarkedContent(t) {
    return this;
  }
  endMarkedContent(t) {
    return this;
  }
  pushBaseTransform(t) {
    return this.#t.pushBaseTransform(t), this;
  }
  popBaseTransform() {
    return this.#t.popBaseTransform(), this;
  }
  recordSimpleData(t, e) {
    return this.#t.recordSimpleData(t, this.#e), this;
  }
  recordIncrementalData(t, e) {
    return this.#t.recordIncrementalData(t, this.#e), this;
  }
  resetIncrementalData(t, e) {
    return this.#t.resetIncrementalData(t, this.#e), this;
  }
  recordNamedData(t, e) {
    return this;
  }
  recordSimpleDataFromNamed(t, e, s) {
    return this.#t.recordSimpleDataFromNamed(t, e, this.#e), this;
  }
  recordFutureForcedDependency(t, e) {
    return this.#t.recordFutureForcedDependency(t, this.#e), this;
  }
  inheritSimpleDataAsFutureForcedDependencies(t) {
    return this.#t.inheritSimpleDataAsFutureForcedDependencies(t), this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    return this.#t.inheritPendingDependenciesAsFutureForcedDependencies(), this;
  }
  resetBBox(t) {
    return this.#i || this.#t.resetBBox(this.#e), this;
  }
  recordClipBox(t, e, s, i, n, r) {
    return this.#i || this.#t.recordClipBox(this.#e, e, s, i, n, r), this;
  }
  recordBBox(t, e, s, i, n, r) {
    return this.#i || this.#t.recordBBox(this.#e, e, s, i, n, r), this;
  }
  recordCharacterBBox(t, e, s, i, n, r, a) {
    return this.#i || this.#t.recordCharacterBBox(this.#e, e, s, i, n, r, a), this;
  }
  recordFullPageBBox(t) {
    return this.#i || this.#t.recordFullPageBBox(this.#e), this;
  }
  getSimpleIndex(t) {
    return this.#t.getSimpleIndex(t);
  }
  recordDependencies(t, e) {
    return this.#t.recordDependencies(this.#e, e), this;
  }
  recordNamedDependency(t, e) {
    return this.#t.recordNamedDependency(this.#e, e), this;
  }
  recordOperation(t) {
    return this.#t.recordOperation(this.#e, !0), this;
  }
  recordShowTextOperation(t) {
    return this.#t.recordShowTextOperation(this.#e, !0), this;
  }
  bboxToClipBoxDropOperation(t) {
    return this.#i || this.#t.bboxToClipBoxDropOperation(this.#e, !0), this;
  }
  take() {
    throw new Error("Unreachable");
  }
  takeDebugMetadata() {
    throw new Error("Unreachable");
  }
}
const Ht = {
  stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
  fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
  imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
  rawFillPath: ["filter", "fillColor", "fillAlpha"],
  showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"],
  transform: ["transform"],
  transformAndFill: ["transform", "fillColor"]
}, xt = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function _s(h, t) {
  if (!t)
    return;
  const e = t[2] - t[0], s = t[3] - t[1], i = new Path2D();
  i.rect(t[0], t[1], e, s), h.clip(i);
}
class qs {
  isModifyingCurrentTransform() {
    return !1;
  }
  getPattern() {
    it("Abstract method `getPattern` called.");
  }
}
class rr extends qs {
  constructor(t) {
    super(), this._type = t[1], this._bbox = t[2], this._colorStops = t[3], this._p0 = t[4], this._p1 = t[5], this._r0 = t[6], this._r1 = t[7], this.matrix = null;
  }
  _createGradient(t) {
    let e;
    this._type === "axial" ? e = t.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (e = t.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      e.addColorStop(s[0], s[1]);
    return e;
  }
  getPattern(t, e, s, i) {
    let n;
    if (i === xt.STROKE || i === xt.FILL) {
      const r = e.current.getClippedPathBoundingBox(i, ht(t)) || [0, 0, 0, 0], a = Math.ceil(r[2] - r[0]) || 1, o = Math.ceil(r[3] - r[1]) || 1, l = e.cachedCanvases.getCanvas("pattern", a, o), c = l.context;
      c.clearRect(0, 0, c.canvas.width, c.canvas.height), c.beginPath(), c.rect(0, 0, c.canvas.width, c.canvas.height), c.translate(-r[0], -r[1]), s = B.transform(s, [1, 0, 0, 1, r[0], r[1]]), c.transform(...e.baseTransform), this.matrix && c.transform(...this.matrix), _s(c, this._bbox), c.fillStyle = this._createGradient(c), c.fill(), n = t.createPattern(l.canvas, "no-repeat");
      const d = new DOMMatrix(s);
      n.setTransform(d);
    } else
      _s(t, this._bbox), n = this._createGradient(t);
    return n;
  }
}
function Rs(h, t, e, s, i, n, r, a) {
  const o = t.coords, l = t.colors, c = h.data, d = h.width * 4;
  let u;
  o[e + 1] > o[s + 1] && (u = e, e = s, s = u, u = n, n = r, r = u), o[s + 1] > o[i + 1] && (u = s, s = i, i = u, u = r, r = a, a = u), o[e + 1] > o[s + 1] && (u = e, e = s, s = u, u = n, n = r, r = u);
  const f = (o[e] + t.offsetX) * t.scaleX, g = (o[e + 1] + t.offsetY) * t.scaleY, p = (o[s] + t.offsetX) * t.scaleX, v = (o[s + 1] + t.offsetY) * t.scaleY, m = (o[i] + t.offsetX) * t.scaleX, b = (o[i + 1] + t.offsetY) * t.scaleY;
  if (g >= b)
    return;
  const y = l[n], E = l[n + 1], A = l[n + 2], w = l[r], S = l[r + 1], x = l[r + 2], T = l[a], C = l[a + 1], P = l[a + 2], O = Math.round(g), D = Math.round(b);
  let k, H, M, I, N, X, tt, ut;
  for (let q = O; q <= D; q++) {
    if (q < v) {
      const R = q < g ? 0 : (g - q) / (g - v);
      k = f - (f - p) * R, H = y - (y - w) * R, M = E - (E - S) * R, I = A - (A - x) * R;
    } else {
      let R;
      q > b ? R = 1 : v === b ? R = 0 : R = (v - q) / (v - b), k = p - (p - m) * R, H = w - (w - T) * R, M = S - (S - C) * R, I = x - (x - P) * R;
    }
    let Q;
    q < g ? Q = 0 : q > b ? Q = 1 : Q = (g - q) / (g - b), N = f - (f - m) * Q, X = y - (y - T) * Q, tt = E - (E - C) * Q, ut = A - (A - P) * Q;
    const rt = Math.round(Math.min(k, N)), Et = Math.round(Math.max(k, N));
    let L = d * q + rt * 4;
    for (let R = rt; R <= Et; R++)
      Q = (k - R) / (k - N), Q < 0 ? Q = 0 : Q > 1 && (Q = 1), c[L++] = H - (H - X) * Q | 0, c[L++] = M - (M - tt) * Q | 0, c[L++] = I - (I - ut) * Q | 0, c[L++] = 255;
  }
}
function ar(h, t, e) {
  const s = t.coords, i = t.colors;
  let n, r;
  switch (t.type) {
    case "lattice":
      const a = t.verticesPerRow, o = Math.floor(s.length / a) - 1, l = a - 1;
      for (n = 0; n < o; n++) {
        let c = n * a;
        for (let d = 0; d < l; d++, c++)
          Rs(h, e, s[c], s[c + 1], s[c + a], i[c], i[c + 1], i[c + a]), Rs(h, e, s[c + a + 1], s[c + 1], s[c + a], i[c + a + 1], i[c + 1], i[c + a]);
      }
      break;
    case "triangles":
      for (n = 0, r = s.length; n < r; n += 3)
        Rs(h, e, s[n], s[n + 1], s[n + 2], i[n], i[n + 1], i[n + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class or extends qs {
  constructor(t) {
    super(), this._coords = t[2], this._colors = t[3], this._figures = t[4], this._bounds = t[5], this._bbox = t[6], this._background = t[7], this.matrix = null;
  }
  _createMeshCanvas(t, e, s) {
    const a = Math.floor(this._bounds[0]), o = Math.floor(this._bounds[1]), l = Math.ceil(this._bounds[2]) - a, c = Math.ceil(this._bounds[3]) - o, d = Math.min(Math.ceil(Math.abs(l * t[0] * 1.1)), 3e3), u = Math.min(Math.ceil(Math.abs(c * t[1] * 1.1)), 3e3), f = l / d, g = c / u, p = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -a,
      offsetY: -o,
      scaleX: 1 / f,
      scaleY: 1 / g
    }, v = d + 4, m = u + 4, b = s.getCanvas("mesh", v, m), y = b.context, E = y.createImageData(d, u);
    if (e) {
      const w = E.data;
      for (let S = 0, x = w.length; S < x; S += 4)
        w[S] = e[0], w[S + 1] = e[1], w[S + 2] = e[2], w[S + 3] = 255;
    }
    for (const w of this._figures)
      ar(E, w, p);
    return y.putImageData(E, 2, 2), {
      canvas: b.canvas,
      offsetX: a - 2 * f,
      offsetY: o - 2 * g,
      scaleX: f,
      scaleY: g
    };
  }
  isModifyingCurrentTransform() {
    return !0;
  }
  getPattern(t, e, s, i) {
    _s(t, this._bbox);
    const n = new Float32Array(2);
    if (i === xt.SHADING)
      B.singularValueDecompose2dScale(ht(t), n);
    else if (this.matrix) {
      B.singularValueDecompose2dScale(this.matrix, n);
      const [a, o] = n;
      B.singularValueDecompose2dScale(e.baseTransform, n), n[0] *= a, n[1] *= o;
    } else
      B.singularValueDecompose2dScale(e.baseTransform, n);
    const r = this._createMeshCanvas(n, i === xt.SHADING ? null : this._background, e.cachedCanvases);
    return i !== xt.SHADING && (t.setTransform(...e.baseTransform), this.matrix && t.transform(...this.matrix)), t.translate(r.offsetX, r.offsetY), t.scale(r.scaleX, r.scaleY), t.createPattern(r.canvas, "no-repeat");
  }
}
class lr extends qs {
  getPattern() {
    return "hotpink";
  }
}
function hr(h) {
  switch (h[0]) {
    case "RadialAxial":
      return new rr(h);
    case "Mesh":
      return new or(h);
    case "Dummy":
      return new lr();
  }
  throw new Error(`Unknown IR type: ${h[0]}`);
}
const Pi = {
  COLORED: 1,
  UNCOLORED: 2
};
class ti {
  static MAX_PATTERN_SIZE = 3e3;
  constructor(t, e, s, i) {
    this.color = t[1], this.operatorList = t[2], this.matrix = t[3], this.bbox = t[4], this.xstep = t[5], this.ystep = t[6], this.paintType = t[7], this.tilingType = t[8], this.ctx = e, this.canvasGraphicsFactory = s, this.baseTransform = i;
  }
  createPatternCanvas(t, e) {
    const {
      bbox: s,
      operatorList: i,
      paintType: n,
      tilingType: r,
      color: a,
      canvasGraphicsFactory: o
    } = this;
    let {
      xstep: l,
      ystep: c
    } = this;
    l = Math.abs(l), c = Math.abs(c), ms("TilingType: " + r);
    const d = s[0], u = s[1], f = s[2], g = s[3], p = f - d, v = g - u, m = new Float32Array(2);
    B.singularValueDecompose2dScale(this.matrix, m);
    const [b, y] = m;
    B.singularValueDecompose2dScale(this.baseTransform, m);
    const E = b * m[0], A = y * m[1];
    let w = p, S = v, x = !1, T = !1;
    const C = Math.ceil(l * E), P = Math.ceil(c * A), O = Math.ceil(p * E), D = Math.ceil(v * A);
    C >= O ? w = l : x = !0, P >= D ? S = c : T = !0;
    const k = this.getSizeAndScale(w, this.ctx.canvas.width, E), H = this.getSizeAndScale(S, this.ctx.canvas.height, A), M = t.cachedCanvases.getCanvas("pattern", k.size, H.size), I = M.context, N = o.createCanvasGraphics(I, e);
    if (N.groupLevel = t.groupLevel, this.setFillAndStrokeStyleToContext(N, n, a), I.translate(-k.scale * d, -H.scale * u), N.transform(0, k.scale, 0, 0, H.scale, 0, 0), I.save(), N.dependencyTracker?.save(), this.clipBbox(N, d, u, f, g), N.baseTransform = ht(N.ctx), N.executeOperatorList(i), N.endDrawing(), N.dependencyTracker?.restore(), I.restore(), x || T) {
      const X = M.canvas;
      x && (w = l), T && (S = c);
      const tt = this.getSizeAndScale(w, this.ctx.canvas.width, E), ut = this.getSizeAndScale(S, this.ctx.canvas.height, A), q = tt.size, Q = ut.size, rt = t.cachedCanvases.getCanvas("pattern-workaround", q, Q), Et = rt.context, L = x ? Math.floor(p / l) : 0, R = T ? Math.floor(v / c) : 0;
      for (let F = 0; F <= L; F++)
        for (let V = 0; V <= R; V++)
          Et.drawImage(X, q * F, Q * V, q, Q, 0, 0, q, Q);
      return {
        canvas: rt.canvas,
        scaleX: tt.scale,
        scaleY: ut.scale,
        offsetX: d,
        offsetY: u
      };
    }
    return {
      canvas: M.canvas,
      scaleX: k.scale,
      scaleY: H.scale,
      offsetX: d,
      offsetY: u
    };
  }
  getSizeAndScale(t, e, s) {
    const i = Math.max(ti.MAX_PATTERN_SIZE, e);
    let n = Math.ceil(t * s);
    return n >= i ? n = i : s = n / t, {
      scale: s,
      size: n
    };
  }
  clipBbox(t, e, s, i, n) {
    const r = i - e, a = n - s;
    t.ctx.rect(e, s, r, a), B.axialAlignedBoundingBox([e, s, i, n], ht(t.ctx), t.current.minMax), t.clip(), t.endPath();
  }
  setFillAndStrokeStyleToContext(t, e, s) {
    const i = t.ctx, n = t.current;
    switch (e) {
      case Pi.COLORED:
        const {
          fillStyle: r,
          strokeStyle: a
        } = this.ctx;
        i.fillStyle = n.fillColor = r, i.strokeStyle = n.strokeColor = a;
        break;
      case Pi.UNCOLORED:
        i.fillStyle = i.strokeStyle = s, n.fillColor = n.strokeColor = s;
        break;
      default:
        throw new Mn(`Unsupported paint type: ${e}`);
    }
  }
  isModifyingCurrentTransform() {
    return !1;
  }
  getPattern(t, e, s, i, n) {
    let r = s;
    i !== xt.SHADING && (r = B.transform(r, e.baseTransform), this.matrix && (r = B.transform(r, this.matrix)));
    const a = this.createPatternCanvas(e, n);
    let o = new DOMMatrix(r);
    o = o.translate(a.offsetX, a.offsetY), o = o.scale(1 / a.scaleX, 1 / a.scaleY);
    const l = t.createPattern(a.canvas, "repeat");
    return l.setTransform(o), l;
  }
}
function cr({
  src: h,
  srcPos: t = 0,
  dest: e,
  width: s,
  height: i,
  nonBlackColor: n = 4294967295,
  inverseDecode: r = !1
}) {
  const a = wt.isLittleEndian ? 4278190080 : 255, [o, l] = r ? [n, a] : [a, n], c = s >> 3, d = s & 7, u = h.length;
  e = new Uint32Array(e.buffer);
  let f = 0;
  for (let g = 0; g < i; g++) {
    for (const v = t + c; t < v; t++) {
      const m = t < u ? h[t] : 255;
      e[f++] = m & 128 ? l : o, e[f++] = m & 64 ? l : o, e[f++] = m & 32 ? l : o, e[f++] = m & 16 ? l : o, e[f++] = m & 8 ? l : o, e[f++] = m & 4 ? l : o, e[f++] = m & 2 ? l : o, e[f++] = m & 1 ? l : o;
    }
    if (d === 0)
      continue;
    const p = t < u ? h[t++] : 255;
    for (let v = 0; v < d; v++)
      e[f++] = p & 1 << 7 - v ? l : o;
  }
  return {
    srcPos: t,
    destPos: f
  };
}
const Ri = 16, Ii = 100, dr = 15, Mi = 10, Ot = 16, Is = new DOMMatrix(), Nt = new Float32Array(2), we = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
function ur(h, t) {
  if (h._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  h.__originalSave = h.save, h.__originalRestore = h.restore, h.__originalRotate = h.rotate, h.__originalScale = h.scale, h.__originalTranslate = h.translate, h.__originalTransform = h.transform, h.__originalSetTransform = h.setTransform, h.__originalResetTransform = h.resetTransform, h.__originalClip = h.clip, h.__originalMoveTo = h.moveTo, h.__originalLineTo = h.lineTo, h.__originalBezierCurveTo = h.bezierCurveTo, h.__originalRect = h.rect, h.__originalClosePath = h.closePath, h.__originalBeginPath = h.beginPath, h._removeMirroring = () => {
    h.save = h.__originalSave, h.restore = h.__originalRestore, h.rotate = h.__originalRotate, h.scale = h.__originalScale, h.translate = h.__originalTranslate, h.transform = h.__originalTransform, h.setTransform = h.__originalSetTransform, h.resetTransform = h.__originalResetTransform, h.clip = h.__originalClip, h.moveTo = h.__originalMoveTo, h.lineTo = h.__originalLineTo, h.bezierCurveTo = h.__originalBezierCurveTo, h.rect = h.__originalRect, h.closePath = h.__originalClosePath, h.beginPath = h.__originalBeginPath, delete h._removeMirroring;
  }, h.save = function() {
    t.save(), this.__originalSave();
  }, h.restore = function() {
    t.restore(), this.__originalRestore();
  }, h.translate = function(e, s) {
    t.translate(e, s), this.__originalTranslate(e, s);
  }, h.scale = function(e, s) {
    t.scale(e, s), this.__originalScale(e, s);
  }, h.transform = function(e, s, i, n, r, a) {
    t.transform(e, s, i, n, r, a), this.__originalTransform(e, s, i, n, r, a);
  }, h.setTransform = function(e, s, i, n, r, a) {
    t.setTransform(e, s, i, n, r, a), this.__originalSetTransform(e, s, i, n, r, a);
  }, h.resetTransform = function() {
    t.resetTransform(), this.__originalResetTransform();
  }, h.rotate = function(e) {
    t.rotate(e), this.__originalRotate(e);
  }, h.clip = function(e) {
    t.clip(e), this.__originalClip(e);
  }, h.moveTo = function(e, s) {
    t.moveTo(e, s), this.__originalMoveTo(e, s);
  }, h.lineTo = function(e, s) {
    t.lineTo(e, s), this.__originalLineTo(e, s);
  }, h.bezierCurveTo = function(e, s, i, n, r, a) {
    t.bezierCurveTo(e, s, i, n, r, a), this.__originalBezierCurveTo(e, s, i, n, r, a);
  }, h.rect = function(e, s, i, n) {
    t.rect(e, s, i, n), this.__originalRect(e, s, i, n);
  }, h.closePath = function() {
    t.closePath(), this.__originalClosePath();
  }, h.beginPath = function() {
    t.beginPath(), this.__originalBeginPath();
  };
}
class fr {
  constructor(t) {
    this.canvasFactory = t, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(t, e, s) {
    let i;
    return this.cache[t] !== void 0 ? (i = this.cache[t], this.canvasFactory.reset(i, e, s)) : (i = this.canvasFactory.create(e, s), this.cache[t] = i), i;
  }
  delete(t) {
    delete this.cache[t];
  }
  clear() {
    for (const t in this.cache) {
      const e = this.cache[t];
      this.canvasFactory.destroy(e), delete this.cache[t];
    }
  }
}
function rs(h, t, e, s, i, n, r, a, o, l) {
  const [c, d, u, f, g, p] = ht(h);
  if (d === 0 && u === 0) {
    const b = r * c + g, y = Math.round(b), E = a * f + p, A = Math.round(E), w = (r + o) * c + g, S = Math.abs(Math.round(w) - y) || 1, x = (a + l) * f + p, T = Math.abs(Math.round(x) - A) || 1;
    return h.setTransform(Math.sign(c), 0, 0, Math.sign(f), y, A), h.drawImage(t, e, s, i, n, 0, 0, S, T), h.setTransform(c, d, u, f, g, p), [S, T];
  }
  if (c === 0 && f === 0) {
    const b = a * u + g, y = Math.round(b), E = r * d + p, A = Math.round(E), w = (a + l) * u + g, S = Math.abs(Math.round(w) - y) || 1, x = (r + o) * d + p, T = Math.abs(Math.round(x) - A) || 1;
    return h.setTransform(0, Math.sign(d), Math.sign(u), 0, y, A), h.drawImage(t, e, s, i, n, 0, 0, T, S), h.setTransform(c, d, u, f, g, p), [T, S];
  }
  h.drawImage(t, e, s, i, n, r, a, o, l);
  const v = Math.hypot(c, d), m = Math.hypot(u, f);
  return [v * o, m * l];
}
class Di {
  alphaIsShape = !1;
  fontSize = 0;
  fontSizeScale = 1;
  textMatrix = null;
  textMatrixScale = 1;
  fontMatrix = Os;
  leading = 0;
  x = 0;
  y = 0;
  lineX = 0;
  lineY = 0;
  charSpacing = 0;
  wordSpacing = 0;
  textHScale = 1;
  textRenderingMode = St.FILL;
  textRise = 0;
  fillColor = "#000000";
  strokeColor = "#000000";
  patternFill = !1;
  patternStroke = !1;
  fillAlpha = 1;
  strokeAlpha = 1;
  lineWidth = 1;
  activeSMask = null;
  transferMaps = "none";
  constructor(t, e, s) {
    s?.(this), this.clipBox = new Float32Array([0, 0, t, e]), this.minMax = we.slice();
  }
  clone() {
    const t = Object.create(this);
    return t.clipBox = this.clipBox.slice(), t.minMax = this.minMax.slice(), t;
  }
  getPathBoundingBox(t = xt.FILL, e = null) {
    const s = this.minMax.slice();
    if (t === xt.STROKE) {
      e || it("Stroke bounding box must include transform."), B.singularValueDecompose2dScale(e, Nt);
      const i = Nt[0] * this.lineWidth / 2, n = Nt[1] * this.lineWidth / 2;
      s[0] -= i, s[1] -= n, s[2] += i, s[3] += n;
    }
    return s;
  }
  updateClipFromPath() {
    const t = B.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(t || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === 1 / 0;
  }
  startNewPathAndClipBox(t) {
    this.clipBox.set(t, 0), this.minMax.set(we, 0);
  }
  getClippedPathBoundingBox(t = xt.FILL, e = null) {
    return B.intersect(this.clipBox, this.getPathBoundingBox(t, e));
  }
}
function Li(h, t) {
  if (t instanceof ImageData) {
    h.putImageData(t, 0, 0);
    return;
  }
  const e = t.height, s = t.width, i = e % Ot, n = (e - i) / Ot, r = i === 0 ? n : n + 1, a = h.createImageData(s, Ot);
  let o = 0, l;
  const c = t.data, d = a.data;
  let u, f, g, p;
  if (t.kind === Vt.GRAYSCALE_1BPP) {
    const v = c.byteLength, m = new Uint32Array(d.buffer, 0, d.byteLength >> 2), b = m.length, y = s + 7 >> 3, E = 4294967295, A = wt.isLittleEndian ? 4278190080 : 255;
    for (u = 0; u < r; u++) {
      for (g = u < n ? Ot : i, l = 0, f = 0; f < g; f++) {
        const w = v - o;
        let S = 0;
        const x = w > y ? s : w * 8 - 7, T = x & -8;
        let C = 0, P = 0;
        for (; S < T; S += 8)
          P = c[o++], m[l++] = P & 128 ? E : A, m[l++] = P & 64 ? E : A, m[l++] = P & 32 ? E : A, m[l++] = P & 16 ? E : A, m[l++] = P & 8 ? E : A, m[l++] = P & 4 ? E : A, m[l++] = P & 2 ? E : A, m[l++] = P & 1 ? E : A;
        for (; S < x; S++)
          C === 0 && (P = c[o++], C = 128), m[l++] = P & C ? E : A, C >>= 1;
      }
      for (; l < b; )
        m[l++] = 0;
      h.putImageData(a, 0, u * Ot);
    }
  } else if (t.kind === Vt.RGBA_32BPP) {
    for (f = 0, p = s * Ot * 4, u = 0; u < n; u++)
      d.set(c.subarray(o, o + p)), o += p, h.putImageData(a, 0, f), f += Ot;
    u < r && (p = s * i * 4, d.set(c.subarray(o, o + p)), h.putImageData(a, 0, f));
  } else if (t.kind === Vt.RGB_24BPP)
    for (g = Ot, p = s * g, u = 0; u < r; u++) {
      for (u >= n && (g = i, p = s * g), l = 0, f = p; f--; )
        d[l++] = c[o++], d[l++] = c[o++], d[l++] = c[o++], d[l++] = 255;
      h.putImageData(a, 0, u * Ot);
    }
  else
    throw new Error(`bad image kind: ${t.kind}`);
}
function Oi(h, t) {
  if (t.bitmap) {
    h.drawImage(t.bitmap, 0, 0);
    return;
  }
  const e = t.height, s = t.width, i = e % Ot, n = (e - i) / Ot, r = i === 0 ? n : n + 1, a = h.createImageData(s, Ot);
  let o = 0;
  const l = t.data, c = a.data;
  for (let d = 0; d < r; d++) {
    const u = d < n ? Ot : i;
    ({
      srcPos: o
    } = cr({
      src: l,
      srcPos: o,
      dest: c,
      width: s,
      height: u,
      nonBlackColor: 0
    })), h.putImageData(a, 0, d * Ot);
  }
}
function Le(h, t) {
  const e = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of e)
    h[s] !== void 0 && (t[s] = h[s]);
  h.setLineDash !== void 0 && (t.setLineDash(h.getLineDash()), t.lineDashOffset = h.lineDashOffset);
}
function as(h) {
  h.strokeStyle = h.fillStyle = "#000000", h.fillRule = "nonzero", h.globalAlpha = 1, h.lineWidth = 1, h.lineCap = "butt", h.lineJoin = "miter", h.miterLimit = 10, h.globalCompositeOperation = "source-over", h.font = "10px sans-serif", h.setLineDash !== void 0 && (h.setLineDash([]), h.lineDashOffset = 0);
  const {
    filter: t
  } = h;
  t !== "none" && t !== "" && (h.filter = "none");
}
function ki(h, t) {
  if (t)
    return !0;
  B.singularValueDecompose2dScale(h, Nt);
  const e = Math.fround(Gt.pixelRatio * fe.PDF_TO_CSS_UNITS);
  return Nt[0] <= e && Nt[1] <= e;
}
const pr = ["butt", "round", "square"], gr = ["miter", "round", "bevel"], mr = {}, Fi = {};
class Se {
  constructor(t, e, s, i, n, {
    optionalContentConfig: r,
    markedContentStack: a = null
  }, o, l, c) {
    this.ctx = t, this.current = new Di(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = e, this.objs = s, this.canvasFactory = i, this.filterFactory = n, this.groupStack = [], this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = a || [], this.optionalContentConfig = r, this.cachedCanvases = new fr(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = o, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = l, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map(), this.dependencyTracker = c ?? null;
  }
  getObject(t, e, s = null) {
    return typeof e == "string" ? (this.dependencyTracker?.recordNamedDependency(t, e), e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e)) : s;
  }
  beginDrawing({
    transform: t,
    viewport: e,
    transparency: s = !1,
    background: i = null
  }) {
    const n = this.ctx.canvas.width, r = this.ctx.canvas.height, a = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, n, r), this.ctx.fillStyle = a, s) {
      const o = this.cachedCanvases.getCanvas("transparent", n, r);
      this.compositeCtx = this.ctx, this.transparentCanvas = o.canvas, this.ctx = o.context, this.ctx.save(), this.ctx.transform(...ht(this.compositeCtx));
    }
    this.ctx.save(), as(this.ctx), t && (this.ctx.transform(...t), this.outputScaleX = t[0], this.outputScaleY = t[0]), this.ctx.transform(...e.transform), this.viewportScale = e.scale, this.baseTransform = ht(this.ctx);
  }
  executeOperatorList(t, e, s, i, n) {
    const r = t.argsArray, a = t.fnArray;
    let o = e || 0;
    const l = r.length;
    if (l === o)
      return o;
    const c = l - o > Mi && typeof s == "function", d = c ? Date.now() + dr : 0;
    let u = 0;
    const f = this.commonObjs, g = this.objs;
    let p, v;
    for (; ; ) {
      if (i !== void 0 && o === i.nextBreakPoint)
        return i.breakIt(o, s), o;
      if (!n || n(o))
        if (p = a[o], v = r[o] ?? null, p !== It.dependency)
          v === null ? this[p](o) : this[p](o, ...v);
        else
          for (const m of v) {
            this.dependencyTracker?.recordNamedData(m, o);
            const b = m.startsWith("g_") ? f : g;
            if (!b.has(m))
              return b.get(m, s), o;
          }
      if (o++, o === l)
        return o;
      if (c && ++u > Mi) {
        if (Date.now() > d)
          return s(), o;
        u = 0;
      }
    }
  }
  #t() {
    for (; this.stateStack.length || this.inSMaskMode; )
      this.restore();
    this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
  }
  endDrawing() {
    this.#t(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const t of this._cachedBitmapsMap.values()) {
      for (const e of t.values())
        typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && (e.width = e.height = 0);
      t.clear();
    }
    this._cachedBitmapsMap.clear(), this.#e();
  }
  #e() {
    if (this.pageColors) {
      const t = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (t !== "none") {
        const e = this.ctx.filter;
        this.ctx.filter = t, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = e;
      }
    }
  }
  _scaleImage(t, e) {
    const s = t.width ?? t.displayWidth, i = t.height ?? t.displayHeight;
    let n = Math.max(Math.hypot(e[0], e[1]), 1), r = Math.max(Math.hypot(e[2], e[3]), 1), a = s, o = i, l = "prescale1", c, d;
    for (; n > 2 && a > 1 || r > 2 && o > 1; ) {
      let u = a, f = o;
      n > 2 && a > 1 && (u = a >= 16384 ? Math.floor(a / 2) - 1 || 1 : Math.ceil(a / 2), n /= a / u), r > 2 && o > 1 && (f = o >= 16384 ? Math.floor(o / 2) - 1 || 1 : Math.ceil(o) / 2, r /= o / f), c = this.cachedCanvases.getCanvas(l, u, f), d = c.context, d.clearRect(0, 0, u, f), d.drawImage(t, 0, 0, a, o, 0, 0, u, f), t = c.canvas, a = u, o = f, l = l === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: t,
      paintWidth: a,
      paintHeight: o
    };
  }
  _createMaskCanvas(t, e) {
    const s = this.ctx, {
      width: i,
      height: n
    } = e, r = this.current.fillColor, a = this.current.patternFill, o = ht(s);
    let l, c, d, u;
    if ((e.bitmap || e.data) && e.count > 1) {
      const C = e.bitmap || e.data.buffer;
      c = JSON.stringify(a ? o : [o.slice(0, 4), r]), l = this._cachedBitmapsMap.get(C), l || (l = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(C, l));
      const P = l.get(c);
      if (P && !a) {
        const O = Math.round(Math.min(o[0], o[2]) + o[4]), D = Math.round(Math.min(o[1], o[3]) + o[5]);
        return this.dependencyTracker?.recordDependencies(t, Ht.transformAndFill), {
          canvas: P,
          offsetX: O,
          offsetY: D
        };
      }
      d = P;
    }
    d || (u = this.cachedCanvases.getCanvas("maskCanvas", i, n), Oi(u.context, e));
    let f = B.transform(o, [1 / i, 0, 0, -1 / n, 0, 0]);
    f = B.transform(f, [1, 0, 0, 1, 0, -n]);
    const g = we.slice();
    B.axialAlignedBoundingBox([0, 0, i, n], f, g);
    const [p, v, m, b] = g, y = Math.round(m - p) || 1, E = Math.round(b - v) || 1, A = this.cachedCanvases.getCanvas("fillCanvas", y, E), w = A.context, S = p, x = v;
    w.translate(-S, -x), w.transform(...f), d || (d = this._scaleImage(u.canvas, Yt(w)), d = d.img, l && a && l.set(c, d)), w.imageSmoothingEnabled = ki(ht(w), e.interpolate), rs(w, d, 0, 0, d.width, d.height, 0, 0, i, n), w.globalCompositeOperation = "source-in";
    const T = B.transform(Yt(w), [1, 0, 0, 1, -S, -x]);
    return w.fillStyle = a ? r.getPattern(s, this, T, xt.FILL, t) : r, w.fillRect(0, 0, i, n), l && !a && (this.cachedCanvases.delete("fillCanvas"), l.set(c, A.canvas)), this.dependencyTracker?.recordDependencies(t, Ht.transformAndFill), {
      canvas: A.canvas,
      offsetX: Math.round(S),
      offsetY: Math.round(x)
    };
  }
  setLineWidth(t, e) {
    this.dependencyTracker?.recordSimpleData("lineWidth", t), e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e;
  }
  setLineCap(t, e) {
    this.dependencyTracker?.recordSimpleData("lineCap", t), this.ctx.lineCap = pr[e];
  }
  setLineJoin(t, e) {
    this.dependencyTracker?.recordSimpleData("lineJoin", t), this.ctx.lineJoin = gr[e];
  }
  setMiterLimit(t, e) {
    this.dependencyTracker?.recordSimpleData("miterLimit", t), this.ctx.miterLimit = e;
  }
  setDash(t, e, s) {
    this.dependencyTracker?.recordSimpleData("dash", t);
    const i = this.ctx;
    i.setLineDash !== void 0 && (i.setLineDash(e), i.lineDashOffset = s);
  }
  setRenderingIntent(t, e) {
  }
  setFlatness(t, e) {
  }
  setGState(t, e) {
    for (const [s, i] of e)
      switch (s) {
        case "LW":
          this.setLineWidth(t, i);
          break;
        case "LC":
          this.setLineCap(t, i);
          break;
        case "LJ":
          this.setLineJoin(t, i);
          break;
        case "ML":
          this.setMiterLimit(t, i);
          break;
        case "D":
          this.setDash(t, i[0], i[1]);
          break;
        case "RI":
          this.setRenderingIntent(t, i);
          break;
        case "FL":
          this.setFlatness(t, i);
          break;
        case "Font":
          this.setFont(t, i[0], i[1]);
          break;
        case "CA":
          this.dependencyTracker?.recordSimpleData("strokeAlpha", t), this.current.strokeAlpha = i;
          break;
        case "ca":
          this.dependencyTracker?.recordSimpleData("fillAlpha", t), this.ctx.globalAlpha = this.current.fillAlpha = i;
          break;
        case "BM":
          this.dependencyTracker?.recordSimpleData("globalCompositeOperation", t), this.ctx.globalCompositeOperation = i;
          break;
        case "SMask":
          this.dependencyTracker?.recordSimpleData("SMask", t), this.current.activeSMask = i ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.dependencyTracker?.recordSimpleData("filter", t), this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(i);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const t = this.inSMaskMode;
    this.current.activeSMask && !t ? this.beginSMaskMode() : !this.current.activeSMask && t && this.endSMaskMode();
  }
  beginSMaskMode(t) {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const e = this.ctx.canvas.width, s = this.ctx.canvas.height, i = "smaskGroupAt" + this.groupLevel, n = this.cachedCanvases.getCanvas(i, e, s);
    this.suspendedCtx = this.ctx;
    const r = this.ctx = n.context;
    r.setTransform(this.suspendedCtx.getTransform()), Le(this.suspendedCtx, r), ur(r, this.suspendedCtx), this.setGState(t, [["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), Le(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(t) {
    if (!this.current.activeSMask)
      return;
    t ? (t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.ceil(t[2]), t[3] = Math.ceil(t[3])) : t = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const e = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, e, this.ctx, t), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(t, e, s, i) {
    const n = i[0], r = i[1], a = i[2] - n, o = i[3] - r;
    a === 0 || o === 0 || (this.genericComposeSMask(e.context, s, a, o, e.subtype, e.backdrop, e.transferMap, n, r, e.offsetX, e.offsetY), t.save(), t.globalAlpha = 1, t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s.canvas, 0, 0), t.restore());
  }
  genericComposeSMask(t, e, s, i, n, r, a, o, l, c, d) {
    let u = t.canvas, f = o - c, g = l - d;
    if (r)
      if (f < 0 || g < 0 || f + s > u.width || g + i > u.height) {
        const v = this.cachedCanvases.getCanvas("maskExtension", s, i), m = v.context;
        m.drawImage(u, -f, -g), m.globalCompositeOperation = "destination-atop", m.fillStyle = r, m.fillRect(0, 0, s, i), m.globalCompositeOperation = "source-over", u = v.canvas, f = g = 0;
      } else {
        t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0);
        const v = new Path2D();
        v.rect(f, g, s, i), t.clip(v), t.globalCompositeOperation = "destination-atop", t.fillStyle = r, t.fillRect(f, g, s, i), t.restore();
      }
    e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0), n === "Alpha" && a ? e.filter = this.filterFactory.addAlphaFilter(a) : n === "Luminosity" && (e.filter = this.filterFactory.addLuminosityFilter(a));
    const p = new Path2D();
    p.rect(o, l, s, i), e.clip(p), e.globalCompositeOperation = "destination-in", e.drawImage(u, f, g, s, i, o, l, s, i), e.restore();
  }
  save(t) {
    this.inSMaskMode && Le(this.ctx, this.suspendedCtx), this.ctx.save();
    const e = this.current;
    this.stateStack.push(e), this.current = e.clone(), this.dependencyTracker?.save(t);
  }
  restore(t) {
    if (this.dependencyTracker?.restore(t), this.stateStack.length === 0) {
      this.inSMaskMode && this.endSMaskMode();
      return;
    }
    this.current = this.stateStack.pop(), this.ctx.restore(), this.inSMaskMode && Le(this.suspendedCtx, this.ctx), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  transform(t, e, s, i, n, r, a) {
    this.dependencyTracker?.recordIncrementalData("transform", t), this.ctx.transform(e, s, i, n, r, a), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(t, e, s, i) {
    let [n] = s;
    if (!i) {
      n ||= s[0] = new Path2D(), this[e](t, n);
      return;
    }
    if (this.dependencyTracker !== null) {
      const r = e === It.stroke ? this.current.lineWidth / 2 : 0;
      this.dependencyTracker.resetBBox(t).recordBBox(t, this.ctx, i[0] - r, i[2] + r, i[1] - r, i[3] + r).recordDependencies(t, ["transform"]);
    }
    if (!(n instanceof Path2D)) {
      const r = s[0] = new Path2D();
      for (let a = 0, o = n.length; a < o; )
        switch (n[a++]) {
          case qe.moveTo:
            r.moveTo(n[a++], n[a++]);
            break;
          case qe.lineTo:
            r.lineTo(n[a++], n[a++]);
            break;
          case qe.curveTo:
            r.bezierCurveTo(n[a++], n[a++], n[a++], n[a++], n[a++], n[a++]);
            break;
          case qe.closePath:
            r.closePath();
            break;
          default:
            z(`Unrecognized drawing path operator: ${n[a - 1]}`);
            break;
        }
      n = r;
    }
    B.axialAlignedBoundingBox(i, ht(this.ctx), this.current.minMax), this[e](t, n), this._pathStartIdx = t;
  }
  closePath(t) {
    this.ctx.closePath();
  }
  stroke(t, e, s = !0) {
    const i = this.ctx, n = this.current.strokeColor;
    if (i.globalAlpha = this.current.strokeAlpha, this.contentVisible)
      if (typeof n == "object" && n?.getPattern) {
        const r = n.isModifyingCurrentTransform() ? i.getTransform() : null;
        if (i.save(), i.strokeStyle = n.getPattern(i, this, Yt(i), xt.STROKE, t), r) {
          const a = new Path2D();
          a.addPath(e, i.getTransform().invertSelf().multiplySelf(r)), e = a;
        }
        this.rescaleAndStroke(e, !1), i.restore();
      } else
        this.rescaleAndStroke(e, !0);
    this.dependencyTracker?.recordDependencies(t, Ht.stroke), s && this.consumePath(t, e, this.current.getClippedPathBoundingBox(xt.STROKE, ht(this.ctx))), i.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(t, e) {
    this.stroke(t, e);
  }
  fill(t, e, s = !0) {
    const i = this.ctx, n = this.current.fillColor, r = this.current.patternFill;
    let a = !1;
    if (r) {
      const l = n.isModifyingCurrentTransform() ? i.getTransform() : null;
      if (this.dependencyTracker?.save(t), i.save(), i.fillStyle = n.getPattern(i, this, Yt(i), xt.FILL, t), l) {
        const c = new Path2D();
        c.addPath(e, i.getTransform().invertSelf().multiplySelf(l)), e = c;
      }
      a = !0;
    }
    const o = this.current.getClippedPathBoundingBox();
    this.contentVisible && o !== null && (this.pendingEOFill ? (i.fill(e, "evenodd"), this.pendingEOFill = !1) : i.fill(e)), this.dependencyTracker?.recordDependencies(t, Ht.fill), a && (i.restore(), this.dependencyTracker?.restore(t)), s && this.consumePath(t, e, o);
  }
  eoFill(t, e) {
    this.pendingEOFill = !0, this.fill(t, e);
  }
  fillStroke(t, e) {
    this.fill(t, e, !1), this.stroke(t, e, !1), this.consumePath(t, e);
  }
  eoFillStroke(t, e) {
    this.pendingEOFill = !0, this.fillStroke(t, e);
  }
  closeFillStroke(t, e) {
    this.fillStroke(t, e);
  }
  closeEOFillStroke(t, e) {
    this.pendingEOFill = !0, this.fillStroke(t, e);
  }
  endPath(t, e) {
    this.consumePath(t, e);
  }
  rawFillPath(t, e) {
    this.ctx.fill(e), this.dependencyTracker?.recordDependencies(t, Ht.rawFillPath).recordOperation(t);
  }
  clip(t) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", t), this.pendingClip = mr;
  }
  eoClip(t) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", t), this.pendingClip = Fi;
  }
  beginText(t) {
    this.current.textMatrix = null, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0, this.dependencyTracker?.recordOpenMarker(t).resetIncrementalData("sameLineText").resetIncrementalData("moveText", t);
  }
  endText(t) {
    const e = this.pendingTextPaths, s = this.ctx;
    if (this.dependencyTracker) {
      const {
        dependencyTracker: i
      } = this;
      e !== void 0 && i.recordFutureForcedDependency("textClip", i.getOpenMarker()).recordFutureForcedDependency("textClip", t), i.recordCloseMarker(t);
    }
    if (e !== void 0) {
      const i = new Path2D(), n = s.getTransform().invertSelf();
      for (const {
        transform: r,
        x: a,
        y: o,
        fontSize: l,
        path: c
      } of e)
        c && i.addPath(c, new DOMMatrix(r).preMultiplySelf(n).translate(a, o).scale(l, -l));
      s.clip(i);
    }
    delete this.pendingTextPaths;
  }
  setCharSpacing(t, e) {
    this.dependencyTracker?.recordSimpleData("charSpacing", t), this.current.charSpacing = e;
  }
  setWordSpacing(t, e) {
    this.dependencyTracker?.recordSimpleData("wordSpacing", t), this.current.wordSpacing = e;
  }
  setHScale(t, e) {
    this.dependencyTracker?.recordSimpleData("hScale", t), this.current.textHScale = e / 100;
  }
  setLeading(t, e) {
    this.dependencyTracker?.recordSimpleData("leading", t), this.current.leading = -e;
  }
  setFont(t, e, s) {
    this.dependencyTracker?.recordSimpleData("font", t).recordSimpleDataFromNamed("fontObj", e, t);
    const i = this.commonObjs.get(e), n = this.current;
    if (!i)
      throw new Error(`Can't find font for ${e}`);
    if (n.fontMatrix = i.fontMatrix || Os, (n.fontMatrix[0] === 0 || n.fontMatrix[3] === 0) && z("Invalid font matrix for font " + e), s < 0 ? (s = -s, n.fontDirection = -1) : n.fontDirection = 1, this.current.font = i, this.current.fontSize = s, i.isType3Font)
      return;
    const r = i.loadedName || "sans-serif", a = i.systemFontInfo?.css || `"${r}", ${i.fallbackName}`;
    let o = "normal";
    i.black ? o = "900" : i.bold && (o = "bold");
    const l = i.italic ? "italic" : "normal";
    let c = s;
    s < Ri ? c = Ri : s > Ii && (c = Ii), this.current.fontSizeScale = s / c, this.ctx.font = `${l} ${o} ${c}px ${a}`;
  }
  setTextRenderingMode(t, e) {
    this.dependencyTracker?.recordSimpleData("textRenderingMode", t), this.current.textRenderingMode = e;
  }
  setTextRise(t, e) {
    this.dependencyTracker?.recordSimpleData("textRise", t), this.current.textRise = e;
  }
  moveText(t, e, s) {
    this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", t), this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += s;
  }
  setLeadingMoveText(t, e, s) {
    this.setLeading(t, -s), this.moveText(t, e, s);
  }
  setTextMatrix(t, e) {
    this.dependencyTracker?.recordSimpleData("textMatrix", t);
    const {
      current: s
    } = this;
    s.textMatrix = e, s.textMatrixScale = Math.hypot(e[0], e[1]), s.x = s.lineX = 0, s.y = s.lineY = 0;
  }
  nextLine(t) {
    this.moveText(t, 0, this.current.leading), this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? t);
  }
  #i(t, e, s) {
    const i = new Path2D();
    return i.addPath(t, new DOMMatrix(s).invertSelf().multiplySelf(e)), i;
  }
  paintChar(t, e, s, i, n, r) {
    const a = this.ctx, o = this.current, l = o.font, c = o.textRenderingMode, d = o.fontSize / o.fontSizeScale, u = c & St.FILL_STROKE_MASK, f = !!(c & St.ADD_TO_PATH_FLAG), g = o.patternFill && !l.missingFile, p = o.patternStroke && !l.missingFile;
    let v;
    if ((l.disableFontFace || f || g || p) && !l.missingFile && (v = l.getPathGenerator(this.commonObjs, e)), v && (l.disableFontFace || g || p)) {
      a.save(), a.translate(s, i), a.scale(d, -d), this.dependencyTracker?.recordCharacterBBox(t, a, l);
      let m;
      if (u === St.FILL || u === St.FILL_STROKE)
        if (n) {
          m = a.getTransform(), a.setTransform(...n);
          const b = this.#i(v, m, n);
          a.fill(b);
        } else
          a.fill(v);
      if (u === St.STROKE || u === St.FILL_STROKE)
        if (r) {
          m ||= a.getTransform(), a.setTransform(...r);
          const {
            a: b,
            b: y,
            c: E,
            d: A
          } = m, w = B.inverseTransform(r), S = B.transform([b, y, E, A, 0, 0], w);
          B.singularValueDecompose2dScale(S, Nt), a.lineWidth *= Math.max(Nt[0], Nt[1]) / d, a.stroke(this.#i(v, m, r));
        } else
          a.lineWidth /= d, a.stroke(v);
      a.restore();
    } else
      (u === St.FILL || u === St.FILL_STROKE) && (a.fillText(e, s, i), this.dependencyTracker?.recordCharacterBBox(t, a, l, d, s, i, () => a.measureText(e))), (u === St.STROKE || u === St.FILL_STROKE) && (this.dependencyTracker && this.dependencyTracker?.recordCharacterBBox(t, a, l, d, s, i, () => a.measureText(e)).recordDependencies(t, Ht.stroke), a.strokeText(e, s, i));
    f && ((this.pendingTextPaths ||= []).push({
      transform: ht(a),
      x: s,
      y: i,
      fontSize: d,
      path: v
    }), this.dependencyTracker?.recordCharacterBBox(t, a, l, d, s, i));
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: t
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    t.scale(1.5, 1), t.fillText("I", 0, 10);
    const e = t.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < e.length; i += 4)
      if (e[i] > 0 && e[i] < 255) {
        s = !0;
        break;
      }
    return K(this, "isFontSubpixelAAEnabled", s);
  }
  showText(t, e) {
    this.dependencyTracker && (this.dependencyTracker.recordDependencies(t, Ht.showText).resetBBox(t), this.current.textRenderingMode & St.ADD_TO_PATH_FLAG && this.dependencyTracker.recordFutureForcedDependency("textClip", t).inheritPendingDependenciesAsFutureForcedDependencies());
    const s = this.current, i = s.font;
    if (i.isType3Font) {
      this.showType3Text(t, e), this.dependencyTracker?.recordShowTextOperation(t);
      return;
    }
    const n = s.fontSize;
    if (n === 0) {
      this.dependencyTracker?.recordOperation(t);
      return;
    }
    const r = this.ctx, a = s.fontSizeScale, o = s.charSpacing, l = s.wordSpacing, c = s.fontDirection, d = s.textHScale * c, u = e.length, f = i.vertical, g = f ? 1 : -1, p = i.defaultVMetrics, v = n * s.fontMatrix[0], m = s.textRenderingMode === St.FILL && !i.disableFontFace && !s.patternFill;
    r.save(), s.textMatrix && r.transform(...s.textMatrix), r.translate(s.x, s.y + s.textRise), c > 0 ? r.scale(d, -1) : r.scale(d, 1);
    let b, y;
    if (s.patternFill) {
      r.save();
      const x = s.fillColor.getPattern(r, this, Yt(r), xt.FILL, t);
      b = ht(r), r.restore(), r.fillStyle = x;
    }
    if (s.patternStroke) {
      r.save();
      const x = s.strokeColor.getPattern(r, this, Yt(r), xt.STROKE, t);
      y = ht(r), r.restore(), r.strokeStyle = x;
    }
    let E = s.lineWidth;
    const A = s.textMatrixScale;
    if (A === 0 || E === 0) {
      const x = s.textRenderingMode & St.FILL_STROKE_MASK;
      (x === St.STROKE || x === St.FILL_STROKE) && (E = this.getSinglePixelWidth());
    } else
      E /= A;
    if (a !== 1 && (r.scale(a, a), E /= a), r.lineWidth = E, i.isInvalidPDFjsFont) {
      const x = [];
      let T = 0;
      for (const P of e)
        x.push(P.unicode), T += P.width;
      const C = x.join("");
      if (r.fillText(C, 0, 0), this.dependencyTracker !== null) {
        const P = r.measureText(C);
        this.dependencyTracker.recordBBox(t, this.ctx, -P.actualBoundingBoxLeft, P.actualBoundingBoxRight, -P.actualBoundingBoxAscent, P.actualBoundingBoxDescent).recordShowTextOperation(t);
      }
      s.x += T * v * d, r.restore(), this.compose();
      return;
    }
    let w = 0, S;
    for (S = 0; S < u; ++S) {
      const x = e[S];
      if (typeof x == "number") {
        w += g * x * n / 1e3;
        continue;
      }
      let T = !1;
      const C = (x.isSpace ? l : 0) + o, P = x.fontChar, O = x.accent;
      let D, k, H = x.width;
      if (f) {
        const N = x.vmetric || p, X = -(x.vmetric ? N[1] : H * 0.5) * v, tt = N[2] * v;
        H = N ? -N[0] : H, D = X / a, k = (w + tt) / a;
      } else
        D = w / a, k = 0;
      let M;
      if (i.remeasure && H > 0) {
        M = r.measureText(P);
        const N = M.width * 1e3 / n * a;
        if (H < N && this.isFontSubpixelAAEnabled) {
          const X = H / N;
          T = !0, r.save(), r.scale(X, 1), D /= X;
        } else H !== N && (D += (H - N) / 2e3 * n / a);
      }
      if (this.contentVisible && (x.isInFont || i.missingFile)) {
        if (m && !O)
          r.fillText(P, D, k), this.dependencyTracker?.recordCharacterBBox(t, r, M ? {
            bbox: null
          } : i, n / a, D, k, () => M ?? r.measureText(P));
        else if (this.paintChar(t, P, D, k, b, y), O) {
          const N = D + n * O.offset.x / a, X = k - n * O.offset.y / a;
          this.paintChar(t, O.fontChar, N, X, b, y);
        }
      }
      const I = f ? H * v - C * c : H * v + C * c;
      w += I, T && r.restore();
    }
    f ? s.y -= w : s.x += w * d, r.restore(), this.compose(), this.dependencyTracker?.recordShowTextOperation(t);
  }
  showType3Text(t, e) {
    const s = this.ctx, i = this.current, n = i.font, r = i.fontSize, a = i.fontDirection, o = n.vertical ? 1 : -1, l = i.charSpacing, c = i.wordSpacing, d = i.textHScale * a, u = i.fontMatrix || Os, f = e.length, g = i.textRenderingMode === St.INVISIBLE;
    let p, v, m, b;
    if (g || r === 0)
      return;
    this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, s.save(), i.textMatrix && s.transform(...i.textMatrix), s.translate(i.x, i.y + i.textRise), s.scale(d, a);
    const y = this.dependencyTracker;
    for (this.dependencyTracker = y ? new fs(y, t) : null, p = 0; p < f; ++p) {
      if (v = e[p], typeof v == "number") {
        b = o * v * r / 1e3, this.ctx.translate(b, 0), i.x += b * d;
        continue;
      }
      const E = (v.isSpace ? c : 0) + l, A = n.charProcOperatorList[v.operatorListId];
      A ? this.contentVisible && (this.save(), s.scale(r, r), s.transform(...u), this.executeOperatorList(A), this.restore()) : z(`Type3 character "${v.operatorListId}" is not available.`);
      const w = [v.width, 0];
      B.applyTransform(w, u), m = w[0] * r + E, s.translate(m, 0), i.x += m * d;
    }
    s.restore(), y && (this.dependencyTracker = y);
  }
  setCharWidth(t, e, s) {
  }
  setCharWidthAndBounds(t, e, s, i, n, r, a) {
    const o = new Path2D();
    o.rect(i, n, r - i, a - n), this.ctx.clip(o), this.dependencyTracker?.recordBBox(t, this.ctx, i, r, n, a).recordClipBox(t, this.ctx, i, r, n, a), this.endPath(t);
  }
  getColorN_Pattern(t, e) {
    let s;
    if (e[0] === "TilingPattern") {
      const i = this.baseTransform || ht(this.ctx), n = {
        createCanvasGraphics: (r, a) => new Se(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        }, void 0, void 0, this.dependencyTracker ? new fs(this.dependencyTracker, a, !0) : null)
      };
      s = new ti(e, this.ctx, n, i);
    } else
      s = this._getPattern(t, e[1], e[2]);
    return s;
  }
  setStrokeColorN(t, ...e) {
    this.dependencyTracker?.recordSimpleData("strokeColor", t), this.current.strokeColor = this.getColorN_Pattern(t, e), this.current.patternStroke = !0;
  }
  setFillColorN(t, ...e) {
    this.dependencyTracker?.recordSimpleData("fillColor", t), this.current.fillColor = this.getColorN_Pattern(t, e), this.current.patternFill = !0;
  }
  setStrokeRGBColor(t, e) {
    this.dependencyTracker?.recordSimpleData("strokeColor", t), this.ctx.strokeStyle = this.current.strokeColor = e, this.current.patternStroke = !1;
  }
  setStrokeTransparent(t) {
    this.dependencyTracker?.recordSimpleData("strokeColor", t), this.ctx.strokeStyle = this.current.strokeColor = "transparent", this.current.patternStroke = !1;
  }
  setFillRGBColor(t, e) {
    this.dependencyTracker?.recordSimpleData("fillColor", t), this.ctx.fillStyle = this.current.fillColor = e, this.current.patternFill = !1;
  }
  setFillTransparent(t) {
    this.dependencyTracker?.recordSimpleData("fillColor", t), this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
  }
  _getPattern(t, e, s = null) {
    let i;
    return this.cachedPatterns.has(e) ? i = this.cachedPatterns.get(e) : (i = hr(this.getObject(t, e)), this.cachedPatterns.set(e, i)), s && (i.matrix = s), i;
  }
  shadingFill(t, e) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    this.save(t);
    const i = this._getPattern(t, e);
    s.fillStyle = i.getPattern(s, this, Yt(s), xt.SHADING, t);
    const n = Yt(s);
    if (n) {
      const {
        width: r,
        height: a
      } = s.canvas, o = we.slice();
      B.axialAlignedBoundingBox([0, 0, r, a], n, o);
      const [l, c, d, u] = o;
      this.ctx.fillRect(l, c, d - l, u - c);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.dependencyTracker?.resetBBox(t).recordFullPageBBox(t).recordDependencies(t, Ht.transform).recordDependencies(t, Ht.fill).recordOperation(t), this.compose(this.current.getClippedPathBoundingBox()), this.restore(t);
  }
  beginInlineImage() {
    it("Should not call beginInlineImage");
  }
  beginImageData() {
    it("Should not call beginImageData");
  }
  paintFormXObjectBegin(t, e, s) {
    if (this.contentVisible && (this.save(t), this.baseTransformStack.push(this.baseTransform), e && this.transform(t, ...e), this.baseTransform = ht(this.ctx), s)) {
      B.axialAlignedBoundingBox(s, this.baseTransform, this.current.minMax);
      const [i, n, r, a] = s, o = new Path2D();
      o.rect(i, n, r - i, a - n), this.ctx.clip(o), this.dependencyTracker?.recordClipBox(t, this.ctx, i, r, n, a), this.endPath(t);
    }
  }
  paintFormXObjectEnd(t) {
    this.contentVisible && (this.restore(t), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(t, e) {
    if (!this.contentVisible)
      return;
    this.save(t), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const s = this.ctx;
    e.isolated || ms("TODO: Support non-isolated groups."), e.knockout && z("Knockout groups not supported.");
    const i = ht(s);
    if (e.matrix && s.transform(...e.matrix), !e.bbox)
      throw new Error("Bounding box is required.");
    let n = we.slice();
    B.axialAlignedBoundingBox(e.bbox, ht(s), n);
    const r = [0, 0, s.canvas.width, s.canvas.height];
    n = B.intersect(n, r) || [0, 0, 0, 0];
    const a = Math.floor(n[0]), o = Math.floor(n[1]), l = Math.max(Math.ceil(n[2]) - a, 1), c = Math.max(Math.ceil(n[3]) - o, 1);
    this.current.startNewPathAndClipBox([0, 0, l, c]);
    let d = "groupAt" + this.groupLevel;
    e.smask && (d += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(d, l, c), f = u.context;
    f.translate(-a, -o), f.transform(...i);
    let g = new Path2D();
    const [p, v, m, b] = e.bbox;
    if (g.rect(p, v, m - p, b - v), e.matrix) {
      const y = new Path2D();
      y.addPath(g, new DOMMatrix(e.matrix)), g = y;
    }
    f.clip(g), e.smask && this.smaskStack.push({
      canvas: u.canvas,
      context: f,
      offsetX: a,
      offsetY: o,
      subtype: e.smask.subtype,
      backdrop: e.smask.backdrop,
      transferMap: e.smask.transferMap || null,
      startTransformInverse: null
    }), (!e.smask || this.dependencyTracker) && (s.setTransform(1, 0, 0, 1, 0, 0), s.translate(a, o), s.save()), Le(s, f), this.ctx = f, this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(s), this.setGState(t, [["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(s), this.groupLevel++;
  }
  endGroup(t, e) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const s = this.ctx, i = this.groupStack.pop();
    if (this.ctx = i, this.ctx.imageSmoothingEnabled = !1, this.dependencyTracker?.popBaseTransform(), e.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore(t), this.dependencyTracker && this.ctx.restore();
    else {
      this.ctx.restore();
      const n = ht(this.ctx);
      this.restore(t), this.ctx.save(), this.ctx.setTransform(...n);
      const r = we.slice();
      B.axialAlignedBoundingBox([0, 0, s.canvas.width, s.canvas.height], n, r), this.ctx.drawImage(s.canvas, 0, 0), this.ctx.restore(), this.compose(r);
    }
  }
  beginAnnotation(t, e, s, i, n, r) {
    if (this.#t(), as(this.ctx), this.ctx.save(), this.save(t), this.baseTransform && this.ctx.setTransform(...this.baseTransform), s) {
      const a = s[2] - s[0], o = s[3] - s[1];
      if (r && this.annotationCanvasMap) {
        i = i.slice(), i[4] -= s[0], i[5] -= s[1], s = s.slice(), s[0] = s[1] = 0, s[2] = a, s[3] = o, B.singularValueDecompose2dScale(ht(this.ctx), Nt);
        const {
          viewportScale: l
        } = this, c = Math.ceil(a * this.outputScaleX * l), d = Math.ceil(o * this.outputScaleY * l);
        this.annotationCanvas = this.canvasFactory.create(c, d);
        const {
          canvas: u,
          context: f
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(e, u), this.annotationCanvas.savedCtx = this.ctx, this.ctx = f, this.ctx.save(), this.ctx.setTransform(Nt[0], 0, 0, -Nt[1], 0, o * Nt[1]), as(this.ctx);
      } else {
        as(this.ctx), this.endPath(t);
        const l = new Path2D();
        l.rect(s[0], s[1], a, o), this.ctx.clip(l);
      }
    }
    this.current = new Di(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(t, ...i), this.transform(t, ...n);
  }
  endAnnotation(t) {
    this.annotationCanvas && (this.ctx.restore(), this.#e(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(t, e) {
    if (!this.contentVisible)
      return;
    const s = e.count;
    e = this.getObject(t, e.data, e), e.count = s;
    const i = this.ctx, n = this._createMaskCanvas(t, e), r = n.canvas;
    i.save(), i.setTransform(1, 0, 0, 1, 0, 0), i.drawImage(r, n.offsetX, n.offsetY), this.dependencyTracker?.resetBBox(t).recordBBox(t, this.ctx, n.offsetX, n.offsetX + r.width, n.offsetY, n.offsetY + r.height).recordOperation(t), i.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(t, e, s, i = 0, n = 0, r, a) {
    if (!this.contentVisible)
      return;
    e = this.getObject(t, e.data, e);
    const o = this.ctx;
    o.save();
    const l = ht(o);
    o.transform(s, i, n, r, 0, 0);
    const c = this._createMaskCanvas(t, e);
    o.setTransform(1, 0, 0, 1, c.offsetX - l[4], c.offsetY - l[5]), this.dependencyTracker?.resetBBox(t);
    for (let d = 0, u = a.length; d < u; d += 2) {
      const f = B.transform(l, [s, i, n, r, a[d], a[d + 1]]);
      o.drawImage(c.canvas, f[4], f[5]), this.dependencyTracker?.recordBBox(t, this.ctx, f[4], f[4] + c.canvas.width, f[5], f[5] + c.canvas.height);
    }
    o.restore(), this.compose(), this.dependencyTracker?.recordOperation(t);
  }
  paintImageMaskXObjectGroup(t, e) {
    if (!this.contentVisible)
      return;
    const s = this.ctx, i = this.current.fillColor, n = this.current.patternFill;
    this.dependencyTracker?.resetBBox(t).recordDependencies(t, Ht.transformAndFill);
    for (const r of e) {
      const {
        data: a,
        width: o,
        height: l,
        transform: c
      } = r, d = this.cachedCanvases.getCanvas("maskCanvas", o, l), u = d.context;
      u.save();
      const f = this.getObject(t, a, r);
      Oi(u, f), u.globalCompositeOperation = "source-in", u.fillStyle = n ? i.getPattern(u, this, Yt(s), xt.FILL, t) : i, u.fillRect(0, 0, o, l), u.restore(), s.save(), s.transform(...c), s.scale(1, -1), rs(s, d.canvas, 0, 0, o, l, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(t, s, 0, o, 0, l), s.restore();
    }
    this.compose(), this.dependencyTracker?.recordOperation(t);
  }
  paintImageXObject(t, e) {
    if (!this.contentVisible)
      return;
    const s = this.getObject(t, e);
    if (!s) {
      z("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(t, s);
  }
  paintImageXObjectRepeat(t, e, s, i, n) {
    if (!this.contentVisible)
      return;
    const r = this.getObject(t, e);
    if (!r) {
      z("Dependent image isn't ready yet");
      return;
    }
    const a = r.width, o = r.height, l = [];
    for (let c = 0, d = n.length; c < d; c += 2)
      l.push({
        transform: [s, 0, 0, i, n[c], n[c + 1]],
        x: 0,
        y: 0,
        w: a,
        h: o
      });
    this.paintInlineImageXObjectGroup(t, r, l);
  }
  applyTransferMapsToCanvas(t) {
    return this.current.transferMaps !== "none" && (t.filter = this.current.transferMaps, t.drawImage(t.canvas, 0, 0), t.filter = "none"), t.canvas;
  }
  applyTransferMapsToBitmap(t) {
    if (this.current.transferMaps === "none")
      return t.bitmap;
    const {
      bitmap: e,
      width: s,
      height: i
    } = t, n = this.cachedCanvases.getCanvas("inlineImage", s, i), r = n.context;
    return r.filter = this.current.transferMaps, r.drawImage(e, 0, 0), r.filter = "none", n.canvas;
  }
  paintInlineImageXObject(t, e) {
    if (!this.contentVisible)
      return;
    const s = e.width, i = e.height, n = this.ctx;
    this.save(t);
    const {
      filter: r
    } = n;
    r !== "none" && r !== "" && (n.filter = "none"), n.scale(1 / s, -1 / i);
    let a;
    if (e.bitmap)
      a = this.applyTransferMapsToBitmap(e);
    else if (typeof HTMLElement == "function" && e instanceof HTMLElement || !e.data)
      a = e;
    else {
      const c = this.cachedCanvases.getCanvas("inlineImage", s, i).context;
      Li(c, e), a = this.applyTransferMapsToCanvas(c);
    }
    const o = this._scaleImage(a, Yt(n));
    n.imageSmoothingEnabled = ki(ht(n), e.interpolate), this.dependencyTracker?.resetBBox(t).recordBBox(t, n, 0, s, -i, 0).recordDependencies(t, Ht.imageXObject).recordOperation(t), rs(n, o.img, 0, 0, o.paintWidth, o.paintHeight, 0, -i, s, i), this.compose(), this.restore(t);
  }
  paintInlineImageXObjectGroup(t, e, s) {
    if (!this.contentVisible)
      return;
    const i = this.ctx;
    let n;
    if (e.bitmap)
      n = e.bitmap;
    else {
      const r = e.width, a = e.height, l = this.cachedCanvases.getCanvas("inlineImage", r, a).context;
      Li(l, e), n = this.applyTransferMapsToCanvas(l);
    }
    this.dependencyTracker?.resetBBox(t);
    for (const r of s)
      i.save(), i.transform(...r.transform), i.scale(1, -1), rs(i, n, r.x, r.y, r.w, r.h, 0, -1, 1, 1), this.dependencyTracker?.recordBBox(t, i, 0, 1, -1, 0), i.restore();
    this.dependencyTracker?.recordOperation(t), this.compose();
  }
  paintSolidColorImageMask(t) {
    this.contentVisible && (this.dependencyTracker?.resetBBox(t).recordBBox(t, this.ctx, 0, 1, 0, 1).recordDependencies(t, Ht.fill).recordOperation(t), this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(t, e) {
  }
  markPointProps(t, e, s) {
  }
  beginMarkedContent(t, e) {
    this.dependencyTracker?.beginMarkedContent(t), this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(t, e, s) {
    this.dependencyTracker?.beginMarkedContent(t), e === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(s)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent(t) {
    this.dependencyTracker?.endMarkedContent(t), this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat(t) {
  }
  endCompat(t) {
  }
  consumePath(t, e, s) {
    const i = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(s);
    const n = this.ctx;
    this.pendingClip ? (i || (this.pendingClip === Fi ? n.clip(e, "evenodd") : n.clip(e)), this.pendingClip = null, this.dependencyTracker?.bboxToClipBoxDropOperation(t).recordFutureForcedDependency("clipPath", t)) : this.dependencyTracker?.recordOperation(t), this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const t = ht(this.ctx);
      if (t[1] === 0 && t[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t[0]), Math.abs(t[3]));
      else {
        const e = Math.abs(t[0] * t[3] - t[2] * t[1]), s = Math.hypot(t[0], t[2]), i = Math.hypot(t[1], t[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / e;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: t
      } = this.current, {
        a: e,
        b: s,
        c: i,
        d: n
      } = this.ctx.getTransform();
      let r, a;
      if (s === 0 && i === 0) {
        const o = Math.abs(e), l = Math.abs(n);
        if (o === l)
          if (t === 0)
            r = a = 1 / o;
          else {
            const c = o * t;
            r = a = c < 1 ? 1 / c : 1;
          }
        else if (t === 0)
          r = 1 / o, a = 1 / l;
        else {
          const c = o * t, d = l * t;
          r = c < 1 ? 1 / c : 1, a = d < 1 ? 1 / d : 1;
        }
      } else {
        const o = Math.abs(e * n - s * i), l = Math.hypot(e, s), c = Math.hypot(i, n);
        if (t === 0)
          r = c / o, a = l / o;
        else {
          const d = t * o;
          r = c > d ? c / d : 1, a = l > d ? l / d : 1;
        }
      }
      this._cachedScaleForStroking[0] = r, this._cachedScaleForStroking[1] = a;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(t, e) {
    const {
      ctx: s,
      current: {
        lineWidth: i
      }
    } = this, [n, r] = this.getScaleForStroking();
    if (n === r) {
      s.lineWidth = (i || 1) * n, s.stroke(t);
      return;
    }
    const a = s.getLineDash();
    e && s.save(), s.scale(n, r), Is.a = 1 / n, Is.d = 1 / r;
    const o = new Path2D();
    if (o.addPath(t, Is), a.length > 0) {
      const l = Math.max(n, r);
      s.setLineDash(a.map((c) => c / l)), s.lineDashOffset /= l;
    }
    s.lineWidth = i || 1, s.stroke(o), e && s.restore();
  }
  isContentVisible() {
    for (let t = this.markedContentStack.length - 1; t >= 0; t--)
      if (!this.markedContentStack[t].visible)
        return !1;
    return !0;
  }
}
for (const h in It)
  Se.prototype[h] !== void 0 && (Se.prototype[It[h]] = Se.prototype[h]);
class xe {
  #t;
  #e;
  #i;
  static strings = ["fontFamily", "fontWeight", "italicAngle"];
  static write(t) {
    const e = new TextEncoder(), s = {};
    let i = 0;
    for (const l of xe.strings) {
      const c = e.encode(t[l]);
      s[l] = c, i += 4 + c.length;
    }
    const n = new ArrayBuffer(i), r = new Uint8Array(n), a = new DataView(n);
    let o = 0;
    for (const l of xe.strings) {
      const c = s[l], d = c.length;
      a.setUint32(o, d), r.set(c, o + 4), o += 4 + d;
    }
    return Z(o === n.byteLength, "CssFontInfo.write: Buffer overflow"), n;
  }
  constructor(t) {
    this.#t = t, this.#e = new DataView(this.#t), this.#i = new TextDecoder();
  }
  #s(t) {
    Z(t < xe.strings.length, "Invalid string index");
    let e = 0;
    for (let i = 0; i < t; i++)
      e += this.#e.getUint32(e) + 4;
    const s = this.#e.getUint32(e);
    return this.#i.decode(new Uint8Array(this.#t, e + 4, s));
  }
  get fontFamily() {
    return this.#s(0);
  }
  get fontWeight() {
    return this.#s(1);
  }
  get italicAngle() {
    return this.#s(2);
  }
}
class Te {
  #t;
  #e;
  #i;
  static strings = ["css", "loadedName", "baseFontName", "src"];
  static write(t) {
    const e = new TextEncoder(), s = {};
    let i = 0;
    for (const u of Te.strings) {
      const f = e.encode(t[u]);
      s[u] = f, i += 4 + f.length;
    }
    i += 4;
    let n, r, a = 1 + i;
    t.style && (n = e.encode(t.style.style), r = e.encode(t.style.weight), a += 4 + n.length + 4 + r.length);
    const o = new ArrayBuffer(a), l = new Uint8Array(o), c = new DataView(o);
    let d = 0;
    c.setUint8(d++, t.guessFallback ? 1 : 0), c.setUint32(d, 0), d += 4, i = 0;
    for (const u of Te.strings) {
      const f = s[u], g = f.length;
      i += 4 + g, c.setUint32(d, g), l.set(f, d + 4), d += 4 + g;
    }
    return c.setUint32(d - i - 4, i), t.style && (c.setUint32(d, n.length), l.set(n, d + 4), d += 4 + n.length, c.setUint32(d, r.length), l.set(r, d + 4), d += 4 + r.length), Z(d <= o.byteLength, "SubstitionInfo.write: Buffer overflow"), o.transferToFixedLength(d);
  }
  constructor(t) {
    this.#t = t, this.#e = new DataView(this.#t), this.#i = new TextDecoder();
  }
  get guessFallback() {
    return this.#e.getUint8(0) !== 0;
  }
  #s(t) {
    Z(t < Te.strings.length, "Invalid string index");
    let e = 5;
    for (let i = 0; i < t; i++)
      e += this.#e.getUint32(e) + 4;
    const s = this.#e.getUint32(e);
    return this.#i.decode(new Uint8Array(this.#t, e + 4, s));
  }
  get css() {
    return this.#s(0);
  }
  get loadedName() {
    return this.#s(1);
  }
  get baseFontName() {
    return this.#s(2);
  }
  get src() {
    return this.#s(3);
  }
  get style() {
    let t = 1;
    t += 4 + this.#e.getUint32(t);
    const e = this.#e.getUint32(t), s = this.#i.decode(new Uint8Array(this.#t, t + 4, e));
    t += 4 + e;
    const i = this.#e.getUint32(t), n = this.#i.decode(new Uint8Array(this.#t, t + 4, i));
    return {
      style: s,
      weight: n
    };
  }
}
class et {
  static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
  static numbers = ["ascent", "defaultWidth", "descent"];
  static strings = ["fallbackName", "loadedName", "mimetype", "name"];
  static #t = Math.ceil(this.bools.length * 2 / 8);
  static #e = this.#t + this.numbers.length * 8;
  static #i = this.#e + 1 + 8;
  static #s = this.#i + 1 + 48;
  static #a = this.#s + 1 + 6;
  #n;
  #r;
  #o;
  constructor({
    data: t,
    extra: e
  }) {
    this.#n = t, this.#r = new TextDecoder(), this.#o = new DataView(this.#n), e && Object.assign(this, e);
  }
  #h(t) {
    Z(t < et.bools.length, "Invalid boolean index");
    const e = Math.floor(t / 4), s = t * 2 % 8, i = this.#o.getUint8(e) >> s & 3;
    return i === 0 ? void 0 : i === 2;
  }
  get black() {
    return this.#h(0);
  }
  get bold() {
    return this.#h(1);
  }
  get disableFontFace() {
    return this.#h(2);
  }
  get fontExtraProperties() {
    return this.#h(3);
  }
  get isInvalidPDFjsFont() {
    return this.#h(4);
  }
  get isType3Font() {
    return this.#h(5);
  }
  get italic() {
    return this.#h(6);
  }
  get missingFile() {
    return this.#h(7);
  }
  get remeasure() {
    return this.#h(8);
  }
  get vertical() {
    return this.#h(9);
  }
  #l(t) {
    return Z(t < et.numbers.length, "Invalid number index"), this.#o.getFloat64(et.#t + t * 8);
  }
  get ascent() {
    return this.#l(0);
  }
  get defaultWidth() {
    return this.#l(1);
  }
  get descent() {
    return this.#l(2);
  }
  get bbox() {
    let t = et.#e;
    if (this.#o.getUint8(t) === 0)
      return;
    t += 1;
    const s = [];
    for (let i = 0; i < 4; i++)
      s.push(this.#o.getInt16(t, !0)), t += 2;
    return s;
  }
  get fontMatrix() {
    let t = et.#i;
    if (this.#o.getUint8(t) === 0)
      return;
    t += 1;
    const s = [];
    for (let i = 0; i < 6; i++)
      s.push(this.#o.getFloat64(t, !0)), t += 8;
    return s;
  }
  get defaultVMetrics() {
    let t = et.#s;
    if (this.#o.getUint8(t) === 0)
      return;
    t += 1;
    const s = [];
    for (let i = 0; i < 3; i++)
      s.push(this.#o.getInt16(t, !0)), t += 2;
    return s;
  }
  #u(t) {
    Z(t < et.strings.length, "Invalid string index");
    let e = et.#a + 4;
    for (let n = 0; n < t; n++)
      e += this.#o.getUint32(e) + 4;
    const s = this.#o.getUint32(e), i = new Uint8Array(s);
    return i.set(new Uint8Array(this.#n, e + 4, s)), this.#r.decode(i);
  }
  get fallbackName() {
    return this.#u(0);
  }
  get loadedName() {
    return this.#u(1);
  }
  get mimetype() {
    return this.#u(2);
  }
  get name() {
    return this.#u(3);
  }
  get data() {
    let t = et.#a;
    const e = this.#o.getUint32(t);
    t += 4 + e;
    const s = this.#o.getUint32(t);
    t += 4 + s;
    const i = this.#o.getUint32(t);
    t += 4 + i;
    const n = this.#o.getUint32(t);
    if (n !== 0)
      return new Uint8Array(this.#n, t + 4, n);
  }
  clearData() {
    let t = et.#a;
    const e = this.#o.getUint32(t);
    t += 4 + e;
    const s = this.#o.getUint32(t);
    t += 4 + s;
    const i = this.#o.getUint32(t);
    t += 4 + i;
    const n = this.#o.getUint32(t);
    new Uint8Array(this.#n, t + 4, n).fill(0), this.#o.setUint32(t, 0);
  }
  get cssFontInfo() {
    let t = et.#a;
    const e = this.#o.getUint32(t);
    t += 4 + e;
    const s = this.#o.getUint32(t);
    t += 4 + s;
    const i = this.#o.getUint32(t);
    if (i === 0)
      return null;
    const n = new Uint8Array(i);
    return n.set(new Uint8Array(this.#n, t + 4, i)), new xe(n.buffer);
  }
  get systemFontInfo() {
    let t = et.#a;
    const e = this.#o.getUint32(t);
    t += 4 + e;
    const s = this.#o.getUint32(t);
    if (s === 0)
      return null;
    const i = new Uint8Array(s);
    return i.set(new Uint8Array(this.#n, t + 4, s)), new Te(i.buffer);
  }
  static write(t) {
    const e = t.systemFontInfo ? Te.write(t.systemFontInfo) : null, s = t.cssFontInfo ? xe.write(t.cssFontInfo) : null, i = new TextEncoder(), n = {};
    let r = 0;
    for (const p of et.strings)
      n[p] = i.encode(t[p]), r += 4 + n[p].length;
    const a = et.#a + 4 + r + 4 + (e ? e.byteLength : 0) + 4 + (s ? s.byteLength : 0) + 4 + (t.data ? t.data.length : 0), o = new ArrayBuffer(a), l = new Uint8Array(o), c = new DataView(o);
    let d = 0;
    const u = et.bools.length;
    let f = 0, g = 0;
    for (let p = 0; p < u; p++) {
      const v = t[et.bools[p]];
      f |= (v === void 0 ? 0 : v ? 2 : 1) << g, g += 2, (g === 8 || p === u - 1) && (c.setUint8(d++, f), f = 0, g = 0);
    }
    Z(d === et.#t, "FontInfo.write: Boolean properties offset mismatch");
    for (const p of et.numbers)
      c.setFloat64(d, t[p]), d += 8;
    if (Z(d === et.#e, "FontInfo.write: Number properties offset mismatch"), t.bbox) {
      c.setUint8(d++, 4);
      for (const p of t.bbox)
        c.setInt16(d, p, !0), d += 2;
    } else
      c.setUint8(d++, 0), d += 8;
    if (Z(d === et.#i, "FontInfo.write: BBox properties offset mismatch"), t.fontMatrix) {
      c.setUint8(d++, 6);
      for (const p of t.fontMatrix)
        c.setFloat64(d, p, !0), d += 8;
    } else
      c.setUint8(d++, 0), d += 48;
    if (Z(d === et.#s, "FontInfo.write: FontMatrix properties offset mismatch"), t.defaultVMetrics) {
      c.setUint8(d++, 1);
      for (const p of t.defaultVMetrics)
        c.setInt16(d, p, !0), d += 2;
    } else
      c.setUint8(d++, 0), d += 6;
    Z(d === et.#a, "FontInfo.write: DefaultVMetrics properties offset mismatch"), c.setUint32(et.#a, 0), d += 4;
    for (const p of et.strings) {
      const v = n[p], m = v.length;
      c.setUint32(d, m), l.set(v, d + 4), d += 4 + m;
    }
    if (c.setUint32(et.#a, d - et.#a - 4), !e)
      c.setUint32(d, 0), d += 4;
    else {
      const p = e.byteLength;
      c.setUint32(d, p), Z(d + 4 + p <= o.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l.set(new Uint8Array(e), d + 4), d += 4 + p;
    }
    if (!s)
      c.setUint32(d, 0), d += 4;
    else {
      const p = s.byteLength;
      c.setUint32(d, p), Z(d + 4 + p <= o.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l.set(new Uint8Array(s), d + 4), d += 4 + p;
    }
    return t.data === void 0 ? (c.setUint32(d, 0), d += 4) : (c.setUint32(d, t.data.length), l.set(t.data, d + 4), d += 4 + t.data.length), Z(d <= o.byteLength, "FontInfo.write: Buffer overflow"), o.transferToFixedLength(d);
  }
}
class $t {
  static #t = null;
  static #e = "";
  static get workerPort() {
    return this.#t;
  }
  static set workerPort(t) {
    if (!(typeof Worker < "u" && t instanceof Worker) && t !== null)
      throw new Error("Invalid `workerPort` type.");
    this.#t = t;
  }
  static get workerSrc() {
    return this.#e;
  }
  static set workerSrc(t) {
    if (typeof t != "string")
      throw new Error("Invalid `workerSrc` type.");
    this.#e = t;
  }
}
class vr {
  #t;
  #e;
  constructor({
    parsedData: t,
    rawData: e
  }) {
    this.#t = t, this.#e = e;
  }
  getRaw() {
    return this.#e;
  }
  get(t) {
    return this.#t.get(t) ?? null;
  }
  [Symbol.iterator]() {
    return this.#t.entries();
  }
}
const Ae = Symbol("INTERNAL");
class yr {
  #t = !1;
  #e = !1;
  #i = !1;
  #s = !0;
  constructor(t, {
    name: e,
    intent: s,
    usage: i,
    rbGroups: n
  }) {
    this.#t = !!(t & kt.DISPLAY), this.#e = !!(t & kt.PRINT), this.name = e, this.intent = s, this.usage = i, this.rbGroups = n;
  }
  get visible() {
    if (this.#i)
      return this.#s;
    if (!this.#s)
      return !1;
    const {
      print: t,
      view: e
    } = this.usage;
    return this.#t ? e?.viewState !== "OFF" : this.#e ? t?.printState !== "OFF" : !0;
  }
  _setVisible(t, e, s = !1) {
    t !== Ae && it("Internal method `_setVisible` called."), this.#i = s, this.#s = e;
  }
}
class br {
  #t = null;
  #e = /* @__PURE__ */ new Map();
  #i = null;
  #s = null;
  constructor(t, e = kt.DISPLAY) {
    if (this.renderingIntent = e, this.name = null, this.creator = null, t !== null) {
      this.name = t.name, this.creator = t.creator, this.#s = t.order;
      for (const s of t.groups)
        this.#e.set(s.id, new yr(e, s));
      if (t.baseState === "OFF")
        for (const s of this.#e.values())
          s._setVisible(Ae, !1);
      for (const s of t.on)
        this.#e.get(s)._setVisible(Ae, !0);
      for (const s of t.off)
        this.#e.get(s)._setVisible(Ae, !1);
      this.#i = this.getHash();
    }
  }
  #a(t) {
    const e = t.length;
    if (e < 2)
      return !0;
    const s = t[0];
    for (let i = 1; i < e; i++) {
      const n = t[i];
      let r;
      if (Array.isArray(n))
        r = this.#a(n);
      else if (this.#e.has(n))
        r = this.#e.get(n).visible;
      else
        return z(`Optional content group not found: ${n}`), !0;
      switch (s) {
        case "And":
          if (!r)
            return !1;
          break;
        case "Or":
          if (r)
            return !0;
          break;
        case "Not":
          return !r;
        default:
          return !0;
      }
    }
    return s === "And";
  }
  isVisible(t) {
    if (this.#e.size === 0)
      return !0;
    if (!t)
      return ms("Optional content group not defined."), !0;
    if (t.type === "OCG")
      return this.#e.has(t.id) ? this.#e.get(t.id).visible : (z(`Optional content group not found: ${t.id}`), !0);
    if (t.type === "OCMD") {
      if (t.expression)
        return this.#a(t.expression);
      if (!t.policy || t.policy === "AnyOn") {
        for (const e of t.ids) {
          if (!this.#e.has(e))
            return z(`Optional content group not found: ${e}`), !0;
          if (this.#e.get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOn") {
        for (const e of t.ids) {
          if (!this.#e.has(e))
            return z(`Optional content group not found: ${e}`), !0;
          if (!this.#e.get(e).visible)
            return !1;
        }
        return !0;
      } else if (t.policy === "AnyOff") {
        for (const e of t.ids) {
          if (!this.#e.has(e))
            return z(`Optional content group not found: ${e}`), !0;
          if (!this.#e.get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOff") {
        for (const e of t.ids) {
          if (!this.#e.has(e))
            return z(`Optional content group not found: ${e}`), !0;
          if (this.#e.get(e).visible)
            return !1;
        }
        return !0;
      }
      return z(`Unknown optional content policy ${t.policy}.`), !0;
    }
    return z(`Unknown group type ${t.type}.`), !0;
  }
  setVisibility(t, e = !0, s = !0) {
    const i = this.#e.get(t);
    if (!i) {
      z(`Optional content group not found: ${t}`);
      return;
    }
    if (s && e && i.rbGroups.length)
      for (const n of i.rbGroups)
        for (const r of n)
          r !== t && this.#e.get(r)?._setVisible(Ae, !1, !0);
    i._setVisible(Ae, !!e, !0), this.#t = null;
  }
  setOCGState({
    state: t,
    preserveRB: e
  }) {
    let s;
    for (const i of t) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const n = this.#e.get(i);
      if (n)
        switch (s) {
          case "ON":
            this.setVisibility(i, !0, e);
            break;
          case "OFF":
            this.setVisibility(i, !1, e);
            break;
          case "Toggle":
            this.setVisibility(i, !n.visible, e);
            break;
        }
    }
    this.#t = null;
  }
  get hasInitialVisibility() {
    return this.#i === null || this.getHash() === this.#i;
  }
  getOrder() {
    return this.#e.size ? this.#s ? this.#s.slice() : [...this.#e.keys()] : null;
  }
  getGroup(t) {
    return this.#e.get(t) || null;
  }
  getHash() {
    if (this.#t !== null)
      return this.#t;
    const t = new qi();
    for (const [e, s] of this.#e)
      t.update(`${e}:${s.visible}`);
    return this.#t = t.hexdigest();
  }
  [Symbol.iterator]() {
    return this.#e.entries();
  }
}
class Ar {
  constructor(t, {
    disableRange: e = !1,
    disableStream: s = !1
  }) {
    Z(t, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: n,
      progressiveDone: r,
      contentDispositionFilename: a
    } = t;
    if (this._queuedChunks = [], this._progressiveDone = r, this._contentDispositionFilename = a, n?.length > 0) {
      const o = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
      this._queuedChunks.push(o);
    }
    this._pdfDataRangeTransport = t, this._isStreamingSupported = !s, this._isRangeSupported = !e, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], t.addRangeListener((o, l) => {
      this._onReceiveData({
        begin: o,
        chunk: l
      });
    }), t.addProgressListener((o, l) => {
      this._onProgress({
        loaded: o,
        total: l
      });
    }), t.addProgressiveReadListener((o) => {
      this._onReceiveData({
        chunk: o
      });
    }), t.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), t.transportReady();
  }
  _onReceiveData({
    begin: t,
    chunk: e
  }) {
    const s = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
    if (t === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(n) {
        return n._begin !== t ? !1 : (n._enqueue(s), !0);
      });
      Z(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(t) {
    t.total === void 0 ? this._rangeReaders[0]?.onProgress?.({
      loaded: t.loaded
    }) : this._fullRequestReader?.onProgress?.({
      loaded: t.loaded,
      total: t.total
    });
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(t) {
    const e = this._rangeReaders.indexOf(t);
    e >= 0 && this._rangeReaders.splice(e, 1);
  }
  getFullReader() {
    Z(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const t = this._queuedChunks;
    return this._queuedChunks = null, new wr(this, t, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = new Er(this, t, e);
    return this._pdfDataRangeTransport.requestDataRange(t, e), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(t) {
    this._fullRequestReader?.cancel(t);
    for (const e of this._rangeReaders.slice(0))
      e.cancel(t);
    this._pdfDataRangeTransport.abort();
  }
}
class wr {
  constructor(t, e, s = !1, i = null) {
    this._stream = t, this._done = s || !1, this._filename = ys(i) ? i : null, this._queuedChunks = e || [], this._loaded = 0;
    for (const n of this._queuedChunks)
      this._loaded += n.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(t) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class Er {
  constructor(t, e, s) {
    this._stream = t, this._begin = e, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(t) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = t;
      else {
        this._requests.shift().resolve({
          value: t,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function Sr(h) {
  let t = !0, e = s("filename\\*", "i").exec(h);
  if (e) {
    e = e[1];
    let c = a(e);
    return c = unescape(c), c = o(c), c = l(c), n(c);
  }
  if (e = r(h), e) {
    const c = l(e);
    return n(c);
  }
  if (e = s("filename", "i").exec(h), e) {
    e = e[1];
    let c = a(e);
    return c = l(c), n(c);
  }
  function s(c, d) {
    return new RegExp("(?:^|;)\\s*" + c + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', d);
  }
  function i(c, d) {
    if (c) {
      if (!/^[\x00-\xFF]+$/.test(d))
        return d;
      try {
        const u = new TextDecoder(c, {
          fatal: !0
        }), f = Ge(d);
        d = u.decode(f), t = !1;
      } catch {
      }
    }
    return d;
  }
  function n(c) {
    return t && /[\x80-\xff]/.test(c) && (c = i("utf-8", c), t && (c = i("iso-8859-1", c))), c;
  }
  function r(c) {
    const d = [];
    let u;
    const f = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (u = f.exec(c)) !== null; ) {
      let [, p, v, m] = u;
      if (p = parseInt(p, 10), p in d) {
        if (p === 0)
          break;
        continue;
      }
      d[p] = [v, m];
    }
    const g = [];
    for (let p = 0; p < d.length && p in d; ++p) {
      let [v, m] = d[p];
      m = a(m), v && (m = unescape(m), p === 0 && (m = o(m))), g.push(m);
    }
    return g.join("");
  }
  function a(c) {
    if (c.startsWith('"')) {
      const d = c.slice(1).split('\\"');
      for (let u = 0; u < d.length; ++u) {
        const f = d[u].indexOf('"');
        f !== -1 && (d[u] = d[u].slice(0, f), d.length = u + 1), d[u] = d[u].replaceAll(/\\(.)/g, "$1");
      }
      c = d.join('"');
    }
    return c;
  }
  function o(c) {
    const d = c.indexOf("'");
    if (d === -1)
      return c;
    const u = c.slice(0, d), g = c.slice(d + 1).replace(/^[^']*'/, "");
    return i(u, g);
  }
  function l(c) {
    return !c.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(c) ? c : c.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(d, u, f, g) {
      if (f === "q" || f === "Q")
        return g = g.replaceAll("_", " "), g = g.replaceAll(/=([0-9a-fA-F]{2})/g, function(p, v) {
          return String.fromCharCode(parseInt(v, 16));
        }), i(u, g);
      try {
        g = atob(g);
      } catch {
      }
      return i(u, g);
    });
  }
  return "";
}
function ln(h, t) {
  const e = new Headers();
  if (!h || !t || typeof t != "object")
    return e;
  for (const s in t) {
    const i = t[s];
    i !== void 0 && e.append(s, i);
  }
  return e;
}
function bs(h) {
  return URL.parse(h)?.origin ?? null;
}
function hn({
  responseHeaders: h,
  isHttp: t,
  rangeChunkSize: e,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, n = parseInt(h.get("Content-Length"), 10);
  return !Number.isInteger(n) || (i.suggestedLength = n, n <= 2 * e) || s || !t || h.get("Accept-Ranges") !== "bytes" || (h.get("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function cn(h) {
  const t = h.get("Content-Disposition");
  if (t) {
    let e = Sr(t);
    if (e.includes("%"))
      try {
        e = decodeURIComponent(e);
      } catch {
      }
    if (ys(e))
      return e;
  }
  return null;
}
function Je(h, t) {
  return new $e(`Unexpected server response (${h}) while retrieving PDF "${t}".`, h, h === 404 || h === 0 && t.startsWith("file:"));
}
function dn(h) {
  return h === 200 || h === 206;
}
function un(h, t, e) {
  return {
    method: "GET",
    headers: h,
    signal: e.signal,
    mode: "cors",
    credentials: t ? "include" : "same-origin",
    redirect: "follow"
  };
}
function fn(h) {
  return h instanceof Uint8Array ? h.buffer : h instanceof ArrayBuffer ? h : (z(`getArrayBuffer - unexpected data format: ${h}`), new Uint8Array(h).buffer);
}
class xr {
  _responseOrigin = null;
  constructor(t) {
    this.source = t, this.isHttp = /^https?:/i.test(t.url), this.headers = ln(this.isHttp, t.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    return Z(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new Tr(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = new Cr(this, t, e);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    this._fullRequestReader?.cancel(t);
    for (const e of this._rangeRequestReaders.slice(0))
      e.cancel(t);
  }
}
class Tr {
  constructor(t) {
    this._stream = t, this._reader = null, this._loaded = 0, this._filename = null;
    const e = t.source;
    this._withCredentials = e.withCredentials || !1, this._contentLength = e.length, this._headersCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange;
    const s = new Headers(t.headers), i = e.url;
    fetch(i, un(s, this._withCredentials, this._abortController)).then((n) => {
      if (t._responseOrigin = bs(n.url), !dn(n.status))
        throw Je(n.status, i);
      this._reader = n.body.getReader(), this._headersCapability.resolve();
      const r = n.headers, {
        allowRangeRequests: a,
        suggestedLength: o
      } = hn({
        responseHeaders: r,
        isHttp: t.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = a, this._contentLength = o || this._contentLength, this._filename = cn(r), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ie("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: fn(t),
      done: !1
    });
  }
  cancel(t) {
    this._reader?.cancel(t), this._abortController.abort();
  }
}
class Cr {
  constructor(t, e, s) {
    this._stream = t, this._reader = null, this._loaded = 0;
    const i = t.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController();
    const n = new Headers(t.headers);
    n.append("Range", `bytes=${e}-${s - 1}`);
    const r = i.url;
    fetch(r, un(n, this._withCredentials, this._abortController)).then((a) => {
      const o = bs(a.url);
      if (o !== t._responseOrigin)
        throw new Error(`Expected range response-origin "${o}" to match "${t._responseOrigin}".`);
      if (!dn(a.status))
        throw Je(a.status, r);
      this._readCapability.resolve(), this._reader = a.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, this.onProgress?.({
      loaded: this._loaded
    }), {
      value: fn(t),
      done: !1
    });
  }
  cancel(t) {
    this._reader?.cancel(t), this._abortController.abort();
  }
}
const Ms = 200, Ds = 206;
function Pr(h) {
  const t = h.response;
  return typeof t != "string" ? t : Ge(t).buffer;
}
class Rr {
  _responseOrigin = null;
  constructor({
    url: t,
    httpHeaders: e,
    withCredentials: s
  }) {
    this.url = t, this.isHttp = /^https?:/i.test(t), this.headers = ln(this.isHttp, e), this.withCredentials = s || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(t) {
    const e = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: e
    };
    e.open("GET", this.url), e.withCredentials = this.withCredentials;
    for (const [n, r] of this.headers)
      e.setRequestHeader(n, r);
    return this.isHttp && "begin" in t && "end" in t ? (e.setRequestHeader("Range", `bytes=${t.begin}-${t.end - 1}`), i.expectedStatus = Ds) : i.expectedStatus = Ms, e.responseType = "arraybuffer", Z(t.onError, "Expected `onError` callback to be provided."), e.onerror = () => {
      t.onError(e.status);
    }, e.onreadystatechange = this.onStateChange.bind(this, s), e.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = t.onHeadersReceived, i.onDone = t.onDone, i.onError = t.onError, i.onProgress = t.onProgress, e.send(null), s;
  }
  onProgress(t, e) {
    const s = this.pendingRequests[t];
    s && s.onProgress?.(e);
  }
  onStateChange(t, e) {
    const s = this.pendingRequests[t];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(t in this.pendingRequests))
      return;
    if (delete this.pendingRequests[t], i.status === 0 && this.isHttp) {
      s.onError(i.status);
      return;
    }
    const n = i.status || Ms;
    if (!(n === Ms && s.expectedStatus === Ds) && n !== s.expectedStatus) {
      s.onError(i.status);
      return;
    }
    const a = Pr(i);
    if (n === Ds) {
      const o = i.getResponseHeader("Content-Range"), l = /bytes (\d+)-(\d+)\/(\d+)/.exec(o);
      l ? s.onDone({
        begin: parseInt(l[1], 10),
        chunk: a
      }) : (z('Missing or invalid "Content-Range" header.'), s.onError(0));
    } else a ? s.onDone({
      begin: 0,
      chunk: a
    }) : s.onError(i.status);
  }
  getRequestXhr(t) {
    return this.pendingRequests[t].xhr;
  }
  isPendingRequest(t) {
    return t in this.pendingRequests;
  }
  abortRequest(t) {
    const e = this.pendingRequests[t].xhr;
    delete this.pendingRequests[t], e.abort();
  }
}
class Ir {
  constructor(t) {
    this._source = t, this._manager = new Rr(t), this._rangeChunkSize = t.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(t) {
    const e = this._rangeRequestReaders.indexOf(t);
    e >= 0 && this._rangeRequestReaders.splice(e, 1);
  }
  getFullReader() {
    return Z(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Mr(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    const s = new Dr(this._manager, t, e);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    this._fullRequestReader?.cancel(t);
    for (const e of this._rangeRequestReaders.slice(0))
      e.cancel(t);
  }
}
class Mr {
  constructor(t, e) {
    this._manager = t, this._url = e.url, this._fullRequestId = t.request({
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    }), this._headersCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._contentLength = e.length, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const t = this._fullRequestId, e = this._manager.getRequestXhr(t);
    this._manager._responseOrigin = bs(e.responseURL);
    const s = e.getAllResponseHeaders(), i = new Headers(s ? s.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((a) => {
      const [o, ...l] = a.split(": ");
      return [o, l.join(": ")];
    }) : []), {
      allowRangeRequests: n,
      suggestedLength: r
    } = hn({
      responseHeaders: i,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    n && (this._isRangeSupported = !0), this._contentLength = r || this._contentLength, this._filename = cn(i), this._isRangeSupported && this._manager.abortRequest(t), this._headersCapability.resolve();
  }
  _onDone(t) {
    if (t && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t.chunk,
      done: !1
    }) : this._cachedChunks.push(t.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(t) {
    this._storedError = Je(t, this._url), this._headersCapability.reject(this._storedError);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(t) {
    this.onProgress?.({
      loaded: t.loaded,
      total: t.lengthComputable ? t.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    if (await this._headersCapability.promise, this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0, this._headersCapability.reject(t);
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class Dr {
  constructor(t, e, s) {
    this._manager = t, this._url = t.url, this._requestId = t.request({
      begin: e,
      end: s,
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    }), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _onHeadersReceived() {
    const t = bs(this._manager.getRequestXhr(this._requestId)?.responseURL);
    t !== this._manager._responseOrigin && (this._storedError = new Error(`Expected range response-origin "${t}" to match "${this._manager._responseOrigin}".`), this._onError(0));
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(t) {
    const e = t.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunk = e, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(t) {
    this._storedError ??= Je(t, this._url);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(t) {
    this.isStreamingSupported || this.onProgress?.({
      loaded: t.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const Lr = /^[a-z][a-z0-9\-+.]+:/i;
function Or(h) {
  if (Lr.test(h))
    return new URL(h);
  const t = process.getBuiltinModule("url");
  return new URL(t.pathToFileURL(h));
}
class kr {
  constructor(t) {
    this.source = t, this.url = Or(t.url), Z(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs."), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    return Z(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = new Fr(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = new Nr(this, t, e);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    this._fullRequestReader?.cancel(t);
    for (const e of this._rangeRequestReaders.slice(0))
      e.cancel(t);
  }
}
class Fr {
  constructor(t) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const e = t.source;
    this._contentLength = e.length, this._loaded = 0, this._filename = null, this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    const s = process.getBuiltinModule("fs");
    s.promises.lstat(this._url).then((i) => {
      this._contentLength = i.size, this._setReadableStream(s.createReadStream(this._url)), this._headersCapability.resolve();
    }, (i) => {
      i.code === "ENOENT" && (i = Je(0, this._url.href)), this._storedError = i, this._headersCapability.reject(i);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ie("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class Nr {
  constructor(t, e, s) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const i = t.source;
    this._isStreamingSupported = !i.disableStream;
    const n = process.getBuiltinModule("fs");
    this._setReadableStream(n.createReadStream(this._url, {
      start: e,
      end: s - 1
    }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, this.onProgress?.({
      loaded: this._loaded
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
const Oe = Symbol("INITIAL_DATA");
class pn {
  #t = /* @__PURE__ */ Object.create(null);
  #e(t) {
    return this.#t[t] ||= {
      ...Promise.withResolvers(),
      data: Oe
    };
  }
  get(t, e = null) {
    if (e) {
      const i = this.#e(t);
      return i.promise.then(() => e(i.data)), null;
    }
    const s = this.#t[t];
    if (!s || s.data === Oe)
      throw new Error(`Requesting object that isn't resolved yet ${t}.`);
    return s.data;
  }
  has(t) {
    const e = this.#t[t];
    return !!e && e.data !== Oe;
  }
  delete(t) {
    const e = this.#t[t];
    return !e || e.data === Oe ? !1 : (delete this.#t[t], !0);
  }
  resolve(t, e = null) {
    const s = this.#e(t);
    s.data = e, s.resolve();
  }
  clear() {
    for (const t in this.#t) {
      const {
        data: e
      } = this.#t[t];
      e?.bitmap?.close();
    }
    this.#t = /* @__PURE__ */ Object.create(null);
  }
  *[Symbol.iterator]() {
    for (const t in this.#t) {
      const {
        data: e
      } = this.#t[t];
      e !== Oe && (yield [t, e]);
    }
  }
}
const Br = 1e5, Ni = 30;
class Tt {
  #t = Promise.withResolvers();
  #e = null;
  #i = !1;
  #s = !!globalThis.FontInspector?.enabled;
  #a = null;
  #n = null;
  #r = 0;
  #o = 0;
  #h = null;
  #l = null;
  #u = 0;
  #d = 0;
  #f = /* @__PURE__ */ Object.create(null);
  #m = [];
  #p = null;
  #c = [];
  #g = /* @__PURE__ */ new WeakMap();
  #v = null;
  static #b = /* @__PURE__ */ new Map();
  static #y = /* @__PURE__ */ new Map();
  static #T = /* @__PURE__ */ new WeakMap();
  static #S = null;
  static #A = /* @__PURE__ */ new Set();
  constructor({
    textContentSource: t,
    container: e,
    viewport: s
  }) {
    if (t instanceof ReadableStream)
      this.#p = t;
    else if (typeof t == "object")
      this.#p = new ReadableStream({
        start(o) {
          o.enqueue(t), o.close();
        }
      });
    else
      throw new Error('No "textContentSource" parameter specified.');
    this.#e = this.#l = e, this.#d = s.scale * Gt.pixelRatio, this.#u = s.rotation, this.#n = {
      div: null,
      properties: null,
      ctx: null
    };
    const {
      pageWidth: i,
      pageHeight: n,
      pageX: r,
      pageY: a
    } = s.rawDims;
    this.#v = [1, 0, 0, -1, -r, a + n], this.#o = i, this.#r = n, Tt.#I(), ae(e, s), this.#t.promise.finally(() => {
      Tt.#A.delete(this), this.#n = null, this.#f = null;
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows: t,
      isFirefox: e
    } = wt.platform;
    return K(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${t && e ? "Calibri, " : ""}sans-serif`], ["monospace", `${t && e ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const t = () => {
      this.#h.read().then(({
        value: e,
        done: s
      }) => {
        if (s) {
          this.#t.resolve();
          return;
        }
        this.#a ??= e.lang, Object.assign(this.#f, e.styles), this.#P(e.items), t();
      }, this.#t.reject);
    };
    return this.#h = this.#p.getReader(), Tt.#A.add(this), t(), this.#t.promise;
  }
  update({
    viewport: t,
    onBefore: e = null
  }) {
    const s = t.scale * Gt.pixelRatio, i = t.rotation;
    if (i !== this.#u && (e?.(), this.#u = i, ae(this.#l, {
      rotation: i
    })), s !== this.#d) {
      e?.(), this.#d = s;
      const n = {
        div: null,
        properties: null,
        ctx: Tt.#M(this.#a)
      };
      for (const r of this.#c)
        n.properties = this.#g.get(r), n.div = r, this.#x(n);
    }
  }
  cancel() {
    const t = new ie("TextLayer task cancelled.");
    this.#h?.cancel(t).catch(() => {
    }), this.#h = null, this.#t.reject(t);
  }
  get textDivs() {
    return this.#c;
  }
  get textContentItemsStr() {
    return this.#m;
  }
  #P(t) {
    if (this.#i)
      return;
    this.#n.ctx ??= Tt.#M(this.#a);
    const e = this.#c, s = this.#m;
    for (const i of t) {
      if (e.length > Br) {
        z("Ignoring additional textDivs for performance reasons."), this.#i = !0;
        return;
      }
      if (i.str === void 0) {
        if (i.type === "beginMarkedContentProps" || i.type === "beginMarkedContent") {
          const n = this.#e;
          this.#e = document.createElement("span"), this.#e.classList.add("markedContent"), i.id && this.#e.setAttribute("id", `${i.id}`), n.append(this.#e);
        } else i.type === "endMarkedContent" && (this.#e = this.#e.parentNode);
        continue;
      }
      s.push(i.str), this.#E(i);
    }
  }
  #E(t) {
    const e = document.createElement("span"), s = {
      angle: 0,
      canvasWidth: 0,
      hasText: t.str !== "",
      hasEOL: t.hasEOL,
      fontSize: 0
    };
    this.#c.push(e);
    const i = B.transform(this.#v, t.transform);
    let n = Math.atan2(i[1], i[0]);
    const r = this.#f[t.fontName];
    r.vertical && (n += Math.PI / 2);
    let a = this.#s && r.fontSubstitution || r.fontFamily;
    a = Tt.fontFamilyMap.get(a) || a;
    const o = Math.hypot(i[2], i[3]), l = o * Tt.#B(a, r, this.#a);
    let c, d;
    n === 0 ? (c = i[4], d = i[5] - l) : (c = i[4] + l * Math.sin(n), d = i[5] - l * Math.cos(n));
    const u = "calc(var(--total-scale-factor) *", f = e.style;
    this.#e === this.#l ? (f.left = `${(100 * c / this.#o).toFixed(2)}%`, f.top = `${(100 * d / this.#r).toFixed(2)}%`) : (f.left = `${u}${c.toFixed(2)}px)`, f.top = `${u}${d.toFixed(2)}px)`), f.fontSize = `${u}${(Tt.#S * o).toFixed(2)}px)`, f.fontFamily = a, s.fontSize = o, e.setAttribute("role", "presentation"), e.textContent = t.str, e.dir = t.dir, this.#s && (e.dataset.fontName = r.fontSubstitutionLoadedName || t.fontName), n !== 0 && (s.angle = n * (180 / Math.PI));
    let g = !1;
    if (t.str.length > 1)
      g = !0;
    else if (t.str !== " " && t.transform[0] !== t.transform[3]) {
      const p = Math.abs(t.transform[0]), v = Math.abs(t.transform[3]);
      p !== v && Math.max(p, v) / Math.min(p, v) > 1.5 && (g = !0);
    }
    if (g && (s.canvasWidth = r.vertical ? t.height : t.width), this.#g.set(e, s), this.#n.div = e, this.#n.properties = s, this.#x(this.#n), s.hasText && this.#e.append(e), s.hasEOL) {
      const p = document.createElement("br");
      p.setAttribute("role", "presentation"), this.#e.append(p);
    }
  }
  #x(t) {
    const {
      div: e,
      properties: s,
      ctx: i
    } = t, {
      style: n
    } = e;
    let r = "";
    if (Tt.#S > 1 && (r = `scale(${1 / Tt.#S})`), s.canvasWidth !== 0 && s.hasText) {
      const {
        fontFamily: a
      } = n, {
        canvasWidth: o,
        fontSize: l
      } = s;
      Tt.#R(i, l * this.#d, a);
      const {
        width: c
      } = i.measureText(e.textContent);
      c > 0 && (r = `scaleX(${o * this.#d / c}) ${r}`);
    }
    s.angle !== 0 && (r = `rotate(${s.angle}deg) ${r}`), r.length > 0 && (n.transform = r);
  }
  static cleanup() {
    if (!(this.#A.size > 0)) {
      this.#b.clear();
      for (const {
        canvas: t
      } of this.#y.values())
        t.remove();
      this.#y.clear();
    }
  }
  static #M(t = null) {
    let e = this.#y.get(t ||= "");
    if (!e) {
      const s = document.createElement("canvas");
      s.className = "hiddenCanvasElement", s.lang = t, document.body.append(s), e = s.getContext("2d", {
        alpha: !1,
        willReadFrequently: !0
      }), this.#y.set(t, e), this.#T.set(e, {
        size: 0,
        family: ""
      });
    }
    return e;
  }
  static #R(t, e, s) {
    const i = this.#T.get(t);
    e === i.size && s === i.family || (t.font = `${e}px ${s}`, i.size = e, i.family = s);
  }
  static #I() {
    if (this.#S !== null)
      return;
    const t = document.createElement("div");
    t.style.opacity = 0, t.style.lineHeight = 1, t.style.fontSize = "1px", t.style.position = "absolute", t.textContent = "X", document.body.append(t), this.#S = t.getBoundingClientRect().height, t.remove();
  }
  static #B(t, e, s) {
    const i = this.#b.get(t);
    if (i)
      return i;
    const n = this.#M(s);
    n.canvas.width = n.canvas.height = Ni, this.#R(n, Ni, t);
    const r = n.measureText(""), a = r.fontBoundingBoxAscent, o = Math.abs(r.fontBoundingBoxDescent);
    n.canvas.width = n.canvas.height = 0;
    let l = 0.8;
    return a ? l = a / (a + o) : (wt.platform.isFirefox && z("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering."), e.ascent ? l = e.ascent : e.descent && (l = 1 + e.descent)), this.#b.set(t, l), l;
  }
}
const _r = 100;
function ei(h = {}) {
  typeof h == "string" || h instanceof URL ? h = {
    url: h
  } : (h instanceof ArrayBuffer || ArrayBuffer.isView(h)) && (h = {
    data: h
  });
  const t = new si(), {
    docId: e
  } = t, s = h.url ? Wn(h.url) : null, i = h.data ? Xn(h.data) : null, n = h.httpHeaders || null, r = h.withCredentials === !0, a = h.password ?? null, o = h.range instanceof ii ? h.range : null, l = Number.isInteger(h.rangeChunkSize) && h.rangeChunkSize > 0 ? h.rangeChunkSize : 2 ** 16;
  let c = h.worker instanceof Re ? h.worker : null;
  const d = h.verbosity, u = typeof h.docBaseUrl == "string" && !Xe(h.docBaseUrl) ? h.docBaseUrl : null, f = es(h.cMapUrl), g = h.cMapPacked !== !1, p = h.CMapReaderFactory || (Rt ? tr : Ei), v = es(h.iccUrl), m = es(h.standardFontDataUrl), b = h.StandardFontDataFactory || (Rt ? er : Si), y = es(h.wasmUrl), E = h.WasmFactory || (Rt ? sr : xi), A = h.stopAtErrors !== !0, w = Number.isInteger(h.maxImageSize) && h.maxImageSize > -1 ? h.maxImageSize : -1, S = h.isEvalSupported !== !1, x = typeof h.isOffscreenCanvasSupported == "boolean" ? h.isOffscreenCanvasSupported : !Rt, T = typeof h.isImageDecoderSupported == "boolean" ? h.isImageDecoderSupported : !Rt && (wt.platform.isFirefox || !globalThis.chrome), C = Number.isInteger(h.canvasMaxAreaInBytes) ? h.canvasMaxAreaInBytes : -1, P = typeof h.disableFontFace == "boolean" ? h.disableFontFace : Rt, O = h.fontExtraProperties === !0, D = h.enableXfa === !0, k = h.ownerDocument || globalThis.document, H = h.disableRange === !0, M = h.disableStream === !0, I = h.disableAutoFetch === !0, N = h.pdfBug === !0, X = h.CanvasFactory || (Rt ? qn : Jn), tt = h.FilterFactory || (Rt ? Zn : Qn), ut = h.enableHWA === !0, q = h.useWasm !== !1, Q = o ? o.length : h.length ?? NaN, rt = typeof h.useSystemFonts == "boolean" ? h.useSystemFonts : !Rt && !P, Et = typeof h.useWorkerFetch == "boolean" ? h.useWorkerFetch : !!(p === Ei && b === Si && E === xi && f && m && y && Ne(f, document.baseURI) && Ne(m, document.baseURI) && Ne(y, document.baseURI)), L = null;
  Pn(d);
  const R = {
    canvasFactory: new X({
      ownerDocument: k,
      enableHWA: ut
    }),
    filterFactory: new tt({
      docId: e,
      ownerDocument: k
    }),
    cMapReaderFactory: Et ? null : new p({
      baseUrl: f,
      isCompressed: g
    }),
    standardFontDataFactory: Et ? null : new b({
      baseUrl: m
    }),
    wasmFactory: Et ? null : new E({
      baseUrl: y
    })
  };
  c || (c = Re.create({
    verbosity: d,
    port: $t.workerPort
  }), t._worker = c);
  const F = {
    docId: e,
    apiVersion: "5.4.296",
    data: i,
    password: a,
    disableAutoFetch: I,
    rangeChunkSize: l,
    length: Q,
    docBaseUrl: u,
    enableXfa: D,
    evaluatorOptions: {
      maxImageSize: w,
      disableFontFace: P,
      ignoreErrors: A,
      isEvalSupported: S,
      isOffscreenCanvasSupported: x,
      isImageDecoderSupported: T,
      canvasMaxAreaInBytes: C,
      fontExtraProperties: O,
      useSystemFonts: rt,
      useWasm: q,
      useWorkerFetch: Et,
      cMapUrl: f,
      iccUrl: v,
      standardFontDataUrl: m,
      wasmUrl: y
    }
  }, V = {
    ownerDocument: k,
    pdfBug: N,
    styleElement: L,
    loadingParams: {
      disableAutoFetch: I,
      enableXfa: D
    }
  };
  return c.promise.then(function() {
    if (t.destroyed)
      throw new Error("Loading aborted");
    if (c.destroyed)
      throw new Error("Worker was destroyed");
    const st = c.messageHandler.sendWithPromise("GetDocRequest", F, i ? [i.buffer] : null);
    let $;
    if (o)
      $ = new Ar(o, {
        disableRange: H,
        disableStream: M
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      const nt = Ne(s) ? xr : Rt ? kr : Ir;
      $ = new nt({
        url: s,
        length: Q,
        httpHeaders: n,
        withCredentials: r,
        rangeChunkSize: l,
        disableRange: H,
        disableStream: M
      });
    }
    return st.then((nt) => {
      if (t.destroyed)
        throw new Error("Loading aborted");
      if (c.destroyed)
        throw new Error("Worker was destroyed");
      const at = new Be(e, nt, c.port), _t = new $r(at, t, $, V, R, ut);
      t._transport = _t, at.send("Ready", null);
    });
  }).catch(t._capability.reject), t;
}
class si {
  static #t = 0;
  _capability = Promise.withResolvers();
  _transport = null;
  _worker = null;
  docId = `d${si.#t++}`;
  destroyed = !1;
  onPassword = null;
  onProgress = null;
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = !0;
    try {
      this._worker?.port && (this._worker._pendingDestroy = !0), await this._transport?.destroy();
    } catch (t) {
      throw this._worker?.port && delete this._worker._pendingDestroy, t;
    }
    this._transport = null, this._worker?.destroy(), this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
}
class ii {
  #t = Promise.withResolvers();
  #e = [];
  #i = [];
  #s = [];
  #a = [];
  constructor(t, e, s = !1, i = null) {
    this.length = t, this.initialData = e, this.progressiveDone = s, this.contentDispositionFilename = i;
  }
  addRangeListener(t) {
    this.#a.push(t);
  }
  addProgressListener(t) {
    this.#s.push(t);
  }
  addProgressiveReadListener(t) {
    this.#i.push(t);
  }
  addProgressiveDoneListener(t) {
    this.#e.push(t);
  }
  onDataRange(t, e) {
    for (const s of this.#a)
      s(t, e);
  }
  onDataProgress(t, e) {
    this.#t.promise.then(() => {
      for (const s of this.#s)
        s(t, e);
    });
  }
  onDataProgressiveRead(t) {
    this.#t.promise.then(() => {
      for (const e of this.#i)
        e(t);
    });
  }
  onDataProgressiveDone() {
    this.#t.promise.then(() => {
      for (const t of this.#e)
        t();
    });
  }
  transportReady() {
    this.#t.resolve();
  }
  requestDataRange(t, e) {
    it("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
}
class Ur {
  constructor(t, e) {
    this._pdfInfo = t, this._transport = e;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return K(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(t) {
    return this._transport.getPage(t);
  }
  getPageIndex(t) {
    return this._transport.getPageIndex(t);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(t) {
    return this._transport.getDestination(t);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getAnnotationsByType(t, e) {
    return this._transport.getAnnotationsByType(t, e);
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getOptionalContentConfig(e);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(t = !1) {
    return this._transport.startCleanup(t || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(t) {
    return this._transport.cachedPageNumber(t);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
class Hr {
  #t = !1;
  constructor(t, e, s, i = !1) {
    this._pageIndex = t, this._pageInfo = e, this._transport = s, this._stats = i ? new gi() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new pn(), this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1, this.recordedBBoxes = null;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: t,
    rotation: e = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: n = !1
  } = {}) {
    return new We({
      viewBox: this.view,
      userUnit: this.userUnit,
      scale: t,
      rotation: e,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  getAnnotations({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getAnnotations(this._pageIndex, e);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return K(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({
    canvasContext: t,
    canvas: e = t.canvas,
    viewport: s,
    intent: i = "display",
    annotationMode: n = se.ENABLE,
    transform: r = null,
    background: a = null,
    optionalContentConfigPromise: o = null,
    annotationCanvasMap: l = null,
    pageColors: c = null,
    printAnnotationStorage: d = null,
    isEditing: u = !1,
    recordOperations: f = !1,
    operationsFilter: g = null
  }) {
    this._stats?.time("Overall");
    const p = this._transport.getRenderingIntent(i, n, d, u), {
      renderingIntent: v,
      cacheKey: m
    } = p;
    this.#t = !1, o ||= this._transport.getOptionalContentConfig(v);
    let b = this._intentStates.get(m);
    b || (b = /* @__PURE__ */ Object.create(null), this._intentStates.set(m, b)), b.streamReaderCancelTimeout && (clearTimeout(b.streamReaderCancelTimeout), b.streamReaderCancelTimeout = null);
    const y = !!(v & kt.PRINT);
    b.displayReadyCapability || (b.displayReadyCapability = Promise.withResolvers(), b.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, this._stats?.time("Page Request"), this._pumpOperatorList(p));
    const E = !!(this._pdfBug && globalThis.StepperManager?.enabled), A = !this.recordedBBoxes && (f || E), w = (T) => {
      if (b.renderTasks.delete(S), A) {
        const C = S.gfx?.dependencyTracker.take();
        C && (S.stepper && S.stepper.setOperatorBBoxes(C, S.gfx.dependencyTracker.takeDebugMetadata()), f && (this.recordedBBoxes = C));
      }
      y && (this.#t = !0), this.#e(), T ? (S.capability.reject(T), this._abortOperatorList({
        intentState: b,
        reason: T instanceof Error ? T : new Error(T)
      })) : S.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, S = new Ee({
      callback: w,
      params: {
        canvas: e,
        canvasContext: t,
        dependencyTracker: A ? new nr(e, b.operatorList.length, E) : null,
        viewport: s,
        transform: r,
        background: a
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: l,
      operatorList: b.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !y,
      pdfBug: this._pdfBug,
      pageColors: c,
      enableHWA: this._transport.enableHWA,
      operationsFilter: g
    });
    (b.renderTasks ||= /* @__PURE__ */ new Set()).add(S);
    const x = S.task;
    return Promise.all([b.displayReadyCapability.promise, o]).then(([T, C]) => {
      if (this.destroyed) {
        w();
        return;
      }
      if (this._stats?.time("Rendering"), !(C.renderingIntent & v))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      S.initializeGraphics({
        transparency: T,
        optionalContentConfig: C
      }), S.operatorListChanged();
    }).catch(w), x;
  }
  getOperatorList({
    intent: t = "display",
    annotationMode: e = se.ENABLE,
    printAnnotationStorage: s = null,
    isEditing: i = !1
  } = {}) {
    function n() {
      a.operatorList.lastChunk && (a.opListReadCapability.resolve(a.operatorList), a.renderTasks.delete(o));
    }
    const r = this._transport.getRenderingIntent(t, e, s, i, !0);
    let a = this._intentStates.get(r.cacheKey);
    a || (a = /* @__PURE__ */ Object.create(null), this._intentStates.set(r.cacheKey, a));
    let o;
    return a.opListReadCapability || (o = /* @__PURE__ */ Object.create(null), o.operatorListChanged = n, a.opListReadCapability = Promise.withResolvers(), (a.renderTasks ||= /* @__PURE__ */ new Set()).add(o), a.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, this._stats?.time("Page Request"), this._pumpOperatorList(r)), a.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: t = !1,
    disableNormalization: e = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: t === !0,
      disableNormalization: e === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(t = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => je.textContent(s));
    const e = this.streamTextContent(t);
    return new Promise(function(s, i) {
      function n() {
        r.read().then(function({
          value: o,
          done: l
        }) {
          if (l) {
            s(a);
            return;
          }
          a.lang ??= o.lang, Object.assign(a.styles, o.styles), a.items.push(...o.items), n();
        }, i);
      }
      const r = e.getReader(), a = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      n();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const t = [];
    for (const e of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: e,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !e.opListReadCapability)
        for (const s of e.renderTasks)
          t.push(s.completed), s.cancel();
    return this.objs.clear(), this.#t = !1, Promise.all(t);
  }
  cleanup(t = !1) {
    this.#t = !0;
    const e = this.#e();
    return t && e && (this._stats &&= new gi()), e;
  }
  #e() {
    if (!this.#t || this.destroyed)
      return !1;
    for (const {
      renderTasks: t,
      operatorList: e
    } of this._intentStates.values())
      if (t.size > 0 || !e.lastChunk)
        return !1;
    return this._intentStates.clear(), this.objs.clear(), this.#t = !1, !0;
  }
  _startRenderPage(t, e) {
    const s = this._intentStates.get(e);
    s && (this._stats?.timeEnd("Page Request"), s.displayReadyCapability?.resolve(t));
  }
  _renderPageChunk(t, e) {
    for (let s = 0, i = t.length; s < i; s++)
      e.operatorList.fnArray.push(t.fnArray[s]), e.operatorList.argsArray.push(t.argsArray[s]);
    e.operatorList.lastChunk = t.lastChunk, e.operatorList.separateAnnots = t.separateAnnots;
    for (const s of e.renderTasks)
      s.operatorListChanged();
    t.lastChunk && this.#e();
  }
  _pumpOperatorList({
    renderingIntent: t,
    cacheKey: e,
    annotationStorageSerializable: s,
    modifiedIds: i
  }) {
    const {
      map: n,
      transfer: r
    } = s, o = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: t,
      cacheKey: e,
      annotationStorage: n,
      modifiedIds: i
    }, r).getReader(), l = this._intentStates.get(e);
    l.streamReader = o;
    const c = () => {
      o.read().then(({
        value: d,
        done: u
      }) => {
        if (u) {
          l.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(d, l), c());
      }, (d) => {
        if (l.streamReader = null, !this._transport.destroyed) {
          if (l.operatorList) {
            l.operatorList.lastChunk = !0;
            for (const u of l.renderTasks)
              u.operatorListChanged();
            this.#e();
          }
          if (l.displayReadyCapability)
            l.displayReadyCapability.reject(d);
          else if (l.opListReadCapability)
            l.opListReadCapability.reject(d);
          else
            throw d;
        }
      });
    };
    c();
  }
  _abortOperatorList({
    intentState: t,
    reason: e,
    force: s = !1
  }) {
    if (t.streamReader) {
      if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !s) {
        if (t.renderTasks.size > 0)
          return;
        if (e instanceof vs) {
          let i = _r;
          e.extraDelay > 0 && e.extraDelay < 1e3 && (i += e.extraDelay), t.streamReaderCancelTimeout = setTimeout(() => {
            t.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: t,
              reason: e,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (t.streamReader.cancel(new ie(e.message)).catch(() => {
      }), t.streamReader = null, !this._transport.destroyed) {
        for (const [i, n] of this._intentStates)
          if (n === t) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
var re, zt, ee, ce, ps, de, ue, Mt, hs, gn, mn, _e, Ce, cs;
const lt = class lt {
  constructor({
    name: t = null,
    port: e = null,
    verbosity: s = Rn()
  } = {}) {
    Wt(this, Mt);
    Wt(this, re, Promise.withResolvers());
    Wt(this, zt, null);
    Wt(this, ee, null);
    Wt(this, ce, null);
    if (this.name = t, this.destroyed = !1, this.verbosity = s, e) {
      if (ot(lt, ue).has(e))
        throw new Error("Cannot use more than one PDFWorker per port.");
      ot(lt, ue).set(e, this), Xt(this, Mt, gn).call(this, e);
    } else
      Xt(this, Mt, mn).call(this);
  }
  get promise() {
    return ot(this, re).promise;
  }
  get port() {
    return ot(this, ee);
  }
  get messageHandler() {
    return ot(this, zt);
  }
  destroy() {
    this.destroyed = !0, ot(this, ce)?.terminate(), Dt(this, ce, null), ot(lt, ue).delete(ot(this, ee)), Dt(this, ee, null), ot(this, zt)?.destroy(), Dt(this, zt, null);
  }
  static create(t) {
    const e = ot(this, ue).get(t?.port);
    if (e) {
      if (e._pendingDestroy)
        throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return e;
    }
    return new lt(t);
  }
  static get workerSrc() {
    if ($t.workerSrc)
      return $t.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return K(this, "_setupFakeWorkerGlobal", (async () => ot(this, Ce, cs) ? ot(this, Ce, cs) : (await import(
      /*webpackIgnore: true*/
      /*@vite-ignore*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
};
re = new WeakMap(), zt = new WeakMap(), ee = new WeakMap(), ce = new WeakMap(), ps = new WeakMap(), de = new WeakMap(), ue = new WeakMap(), Mt = new WeakSet(), hs = function() {
  ot(this, re).resolve(), ot(this, zt).send("configure", {
    verbosity: this.verbosity
  });
}, gn = function(t) {
  Dt(this, ee, t), Dt(this, zt, new Be("main", "worker", t)), ot(this, zt).on("ready", () => {
  }), Xt(this, Mt, hs).call(this);
}, mn = function() {
  if (ot(lt, de) || ot(lt, Ce, cs)) {
    Xt(this, Mt, _e).call(this);
    return;
  }
  let {
    workerSrc: t
  } = lt;
  try {
    lt._isSameOrigin(window.location, t) || (t = lt._createCDNWrapper(new URL(t, window.location).href));
    const e = new Worker(t, {
      type: "module"
    }), s = new Be("main", "worker", e), i = () => {
      n.abort(), s.destroy(), e.terminate(), this.destroyed ? ot(this, re).reject(new Error("Worker was destroyed")) : Xt(this, Mt, _e).call(this);
    }, n = new AbortController();
    e.addEventListener("error", () => {
      ot(this, ce) || i();
    }, {
      signal: n.signal
    }), s.on("test", (a) => {
      if (n.abort(), this.destroyed || !a) {
        i();
        return;
      }
      Dt(this, zt, s), Dt(this, ee, e), Dt(this, ce, e), Xt(this, Mt, hs).call(this);
    }), s.on("ready", (a) => {
      if (n.abort(), this.destroyed) {
        i();
        return;
      }
      try {
        r();
      } catch {
        Xt(this, Mt, _e).call(this);
      }
    });
    const r = () => {
      const a = new Uint8Array();
      s.send("test", a, [a.buffer]);
    };
    r();
    return;
  } catch {
    ms("The worker has been disabled.");
  }
  Xt(this, Mt, _e).call(this);
}, _e = function() {
  ot(lt, de) || (z("Setting up fake worker."), Dt(lt, de, !0)), lt._setupFakeWorkerGlobal.then((t) => {
    if (this.destroyed) {
      ot(this, re).reject(new Error("Worker was destroyed"));
      return;
    }
    const e = new Kn();
    Dt(this, ee, e);
    const s = `fake${di(lt, ps)._++}`, i = new Be(s + "_worker", s, e);
    t.setup(i, e), Dt(this, zt, new Be(s, s + "_worker", e)), Xt(this, Mt, hs).call(this);
  }).catch((t) => {
    ot(this, re).reject(new Error(`Setting up fake worker failed: "${t.message}".`));
  });
}, Ce = new WeakSet(), cs = function() {
  try {
    return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
  } catch {
    return null;
  }
}, Wt(lt, Ce), Wt(lt, ps, 0), Wt(lt, de, !1), Wt(lt, ue, /* @__PURE__ */ new WeakMap()), Rt && (Dt(lt, de, !0), $t.workerSrc ||= "./pdf.worker.mjs"), lt._isSameOrigin = (t, e) => {
  const s = URL.parse(t);
  if (!s?.origin || s.origin === "null")
    return !1;
  const i = new URL(e, s);
  return s.origin === i.origin;
}, lt._createCDNWrapper = (t) => {
  const e = `await import("${t}");`;
  return URL.createObjectURL(new Blob([e], {
    type: "text/javascript"
  }));
}, lt.fromPort = (t) => {
  if (Bn("`PDFWorker.fromPort` - please use `PDFWorker.create` instead."), !t?.port)
    throw new Error("PDFWorker.fromPort - invalid method signature.");
  return lt.create(t);
};
let Re = lt;
class $r {
  #t = /* @__PURE__ */ new Map();
  #e = /* @__PURE__ */ new Map();
  #i = /* @__PURE__ */ new Map();
  #s = /* @__PURE__ */ new Map();
  #a = null;
  constructor(t, e, s, i, n, r) {
    this.messageHandler = t, this.loadingTask = e, this.commonObjs = new pn(), this.fontLoader = new Vn({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = n.canvasFactory, this.filterFactory = n.filterFactory, this.cMapReaderFactory = n.cMapReaderFactory, this.standardFontDataFactory = n.standardFontDataFactory, this.wasmFactory = n.wasmFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.enableHWA = r, this.setupMessageHandler();
  }
  #n(t, e = null) {
    const s = this.#t.get(t);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise(t, e);
    return this.#t.set(t, i), i;
  }
  get annotationStorage() {
    return K(this, "annotationStorage", new Qs());
  }
  getRenderingIntent(t, e = se.ENABLE, s = null, i = !1, n = !1) {
    let r = kt.DISPLAY, a = Fs;
    switch (t) {
      case "any":
        r = kt.ANY;
        break;
      case "display":
        break;
      case "print":
        r = kt.PRINT;
        break;
      default:
        z(`getRenderingIntent - invalid intent: ${t}`);
    }
    const o = r & kt.PRINT && s instanceof tn ? s : this.annotationStorage;
    switch (e) {
      case se.DISABLE:
        r += kt.ANNOTATIONS_DISABLE;
        break;
      case se.ENABLE:
        break;
      case se.ENABLE_FORMS:
        r += kt.ANNOTATIONS_FORMS;
        break;
      case se.ENABLE_STORAGE:
        r += kt.ANNOTATIONS_STORAGE, a = o.serializable;
        break;
      default:
        z(`getRenderingIntent - invalid annotationMode: ${e}`);
    }
    i && (r += kt.IS_EDITING), n && (r += kt.OPLIST);
    const {
      ids: l,
      hash: c
    } = o.modifiedIds, d = [r, a.hash, c];
    return {
      renderingIntent: r,
      cacheKey: d.join("_"),
      annotationStorageSerializable: a,
      modifiedIds: l
    };
  }
  destroy() {
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), this.#a?.reject(new Error("Worker was destroyed during onPassword callback"));
    const t = [];
    for (const s of this.#e.values())
      t.push(s._destroy());
    this.#e.clear(), this.#i.clear(), this.#s.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const e = this.messageHandler.sendWithPromise("Terminate", null);
    return t.push(e), Promise.all(t).then(() => {
      this.commonObjs.clear(), this.fontLoader.clear(), this.#t.clear(), this.filterFactory.destroy(), Tt.cleanup(), this._networkStream?.cancelAllRequests(new ie("Worker was terminated.")), this.messageHandler?.destroy(), this.messageHandler = null, this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: t,
      loadingTask: e
    } = this;
    t.on("GetReader", (s, i) => {
      Z(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (n) => {
        this._lastProgress = {
          loaded: n.loaded,
          total: n.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: n,
          done: r
        }) {
          if (r) {
            i.close();
            return;
          }
          Z(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        this._fullReader.cancel(n), i.ready.catch((r) => {
          if (!this.destroyed)
            throw r;
        });
      };
    }), t.on("ReaderHeadersReady", async (s) => {
      await this._fullReader.headersReady;
      const {
        isStreamingSupported: i,
        isRangeSupported: n,
        contentLength: r
      } = this._fullReader;
      return (!i || !n) && (this._lastProgress && e.onProgress?.(this._lastProgress), this._fullReader.onProgress = (a) => {
        e.onProgress?.({
          loaded: a.loaded,
          total: a.total
        });
      }), {
        isStreamingSupported: i,
        isRangeSupported: n,
        contentLength: r
      };
    }), t.on("GetRangeReader", (s, i) => {
      Z(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const n = this._networkStream.getRangeReader(s.begin, s.end);
      if (!n) {
        i.close();
        return;
      }
      i.onPull = () => {
        n.read().then(function({
          value: r,
          done: a
        }) {
          if (a) {
            i.close();
            return;
          }
          Z(r instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(r), 1, [r]);
        }).catch((r) => {
          i.error(r);
        });
      }, i.onCancel = (r) => {
        n.cancel(r), i.ready.catch((a) => {
          if (!this.destroyed)
            throw a;
        });
      };
    }), t.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, e._capability.resolve(new Ur(s, this));
    }), t.on("DocException", (s) => {
      e._capability.reject(Lt(s));
    }), t.on("PasswordRequest", (s) => {
      this.#a = Promise.withResolvers();
      try {
        if (!e.onPassword)
          throw Lt(s);
        const i = (n) => {
          n instanceof Error ? this.#a.reject(n) : this.#a.resolve({
            password: n
          });
        };
        e.onPassword(i, s.code);
      } catch (i) {
        this.#a.reject(i);
      }
      return this.#a.promise;
    }), t.on("DataLoaded", (s) => {
      e.onProgress?.({
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), t.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      this.#e.get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), t.on("commonobj", ([s, i, n]) => {
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          if ("error" in n) {
            const c = n.error;
            z(`Error during font loading: ${c}`), this.commonObjs.resolve(s, c);
            break;
          }
          const r = new et(n), a = this._params.pdfBug && globalThis.FontInspector?.enabled ? (c, d) => globalThis.FontInspector.fontAdded(c, d) : null, o = new Gn(r, a, n.extra, n.charProcOperatorList);
          this.fontLoader.bind(o).catch(() => t.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !o.fontExtraProperties && o.data && o.clearData(), this.commonObjs.resolve(s, o);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: l
          } = n;
          Z(l, "The imageRef must be defined.");
          for (const c of this.#e.values())
            for (const [, d] of c.objs)
              if (d?.ref === l)
                return d.dataLen ? (this.commonObjs.resolve(s, structuredClone(d)), d.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, n);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), t.on("obj", ([s, i, n, r]) => {
      if (this.destroyed)
        return;
      const a = this.#e.get(i);
      if (!a.objs.has(s)) {
        if (a._intentStates.size === 0) {
          r?.bitmap?.close();
          return;
        }
        switch (n) {
          case "Image":
          case "Pattern":
            a.objs.resolve(s, r);
            break;
          default:
            throw new Error(`Got unknown object type ${n}`);
        }
      }
    }), t.on("DocProgress", (s) => {
      this.destroyed || e.onProgress?.({
        loaded: s.loaded,
        total: s.total
      });
    }), t.on("FetchBinaryData", async (s) => {
      if (this.destroyed)
        throw new Error("Worker was destroyed.");
      const i = this[s.type];
      if (!i)
        throw new Error(`${s.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      return i.fetch(s);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    this.annotationStorage.size <= 0 && z("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: t,
      transfer: e
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: t,
      filename: this._fullReader?.filename ?? null
    }, e).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(t) {
    if (!Number.isInteger(t) || t <= 0 || t > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const e = t - 1, s = this.#i.get(e);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: e
    }).then((n) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      n.refStr && this.#s.set(n.refStr, t);
      const r = new Hr(e, n, this, this._params.pdfBug);
      return this.#e.set(e, r), r;
    });
    return this.#i.set(e, i), i;
  }
  getPageIndex(t) {
    return Ns(t) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: t.num,
      gen: t.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(t, e) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: t,
      intent: e
    });
  }
  getFieldObjects() {
    return this.#n("GetFieldObjects");
  }
  hasJSActions() {
    return this.#n("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(t) {
    return typeof t != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: t
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getAnnotationsByType(t, e) {
    return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
      types: t,
      pageIndexesToSkip: e
    });
  }
  getDocJSActions() {
    return this.#n("GetDocJSActions");
  }
  getPageJSActions(t) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: t
    });
  }
  getStructTree(t) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: t
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(t) {
    return this.#n("GetOptionalContentConfig").then((e) => new br(e, t));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const t = "GetMetadata", e = this.#t.get(t);
    if (e)
      return e;
    const s = this.messageHandler.sendWithPromise(t, null).then((i) => ({
      info: i[0],
      metadata: i[1] ? new vr(i[1]) : null,
      contentDispositionFilename: this._fullReader?.filename ?? null,
      contentLength: this._fullReader?.contentLength ?? null
    }));
    return this.#t.set(t, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(t = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const e of this.#e.values())
        if (!e.cleanup())
          throw new Error(`startCleanup: Page ${e.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), t || this.fontLoader.clear(), this.#t.clear(), this.filterFactory.destroy(!0), Tt.cleanup();
    }
  }
  cachedPageNumber(t) {
    if (!Ns(t))
      return null;
    const e = t.gen === 0 ? `${t.num}R` : `${t.num}R${t.gen}`;
    return this.#s.get(e) ?? null;
  }
}
class jr {
  #t = null;
  onContinue = null;
  onError = null;
  constructor(t) {
    this.#t = t;
  }
  get promise() {
    return this.#t.capability.promise;
  }
  cancel(t = 0) {
    this.#t.cancel(null, t);
  }
  get separateAnnots() {
    const {
      separateAnnots: t
    } = this.#t.operatorList;
    if (!t)
      return !1;
    const {
      annotationCanvasMap: e
    } = this.#t;
    return t.form || t.canvas && e?.size > 0;
  }
}
class Ee {
  #t = null;
  static #e = /* @__PURE__ */ new WeakSet();
  constructor({
    callback: t,
    params: e,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: n,
    operatorList: r,
    pageIndex: a,
    canvasFactory: o,
    filterFactory: l,
    useRequestAnimationFrame: c = !1,
    pdfBug: d = !1,
    pageColors: u = null,
    enableHWA: f = !1,
    operationsFilter: g = null
  }) {
    this.callback = t, this.params = e, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = n, this.operatorListIdx = null, this.operatorList = r, this._pageIndex = a, this.canvasFactory = o, this.filterFactory = l, this._pdfBug = d, this.pageColors = u, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = c === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new jr(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = e.canvas, this._canvasContext = e.canvas ? null : e.canvasContext, this._enableHWA = f, this._dependencyTracker = e.dependencyTracker, this._operationsFilter = g;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: t = !1,
    optionalContentConfig: e
  }) {
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (Ee.#e.has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      Ee.#e.add(this._canvas);
    }
    this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      viewport: s,
      transform: i,
      background: n,
      dependencyTracker: r
    } = this.params, a = this._canvasContext || this._canvas.getContext("2d", {
      alpha: !1,
      willReadFrequently: !this._enableHWA
    });
    this.gfx = new Se(a, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: e
    }, this.annotationCanvasMap, this.pageColors, r), this.gfx.beginDrawing({
      transform: i,
      viewport: s,
      transparency: t,
      background: n
    }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback?.();
  }
  cancel(t = null, e = 0) {
    this.running = !1, this.cancelled = !0, this.gfx?.endDrawing(), this.#t && (window.cancelAnimationFrame(this.#t), this.#t = null), Ee.#e.delete(this._canvas), t ||= new vs(`Rendering cancelled, page ${this._pageIndex + 1}`, e), this.callback(t), this.task.onError?.(t);
  }
  operatorListChanged() {
    if (!this.graphicsReady) {
      this.graphicsReadyCallback ||= this._continueBound;
      return;
    }
    this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length), this.stepper?.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? this.#t = window.requestAnimationFrame(() => {
      this.#t = null, this._nextBound().catch(this._cancelBound);
    }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), Ee.#e.delete(this._canvas), this.callback())));
  }
}
const vn = "5.4.296", yn = "f56dc8601";
class Ft {
  #t = null;
  #e = null;
  #i;
  #s = null;
  #a = !1;
  #n = !1;
  #r = null;
  #o;
  #h = null;
  #l = null;
  static #u = null;
  static get _keyboardManager() {
    return K(this, "_keyboardManager", new Ye([[["Escape", "mac+Escape"], Ft.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], Ft.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], Ft.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], Ft.prototype._moveToPrevious], [["Home", "mac+Home"], Ft.prototype._moveToBeginning], [["End", "mac+End"], Ft.prototype._moveToEnd]]));
  }
  constructor({
    editor: t = null,
    uiManager: e = null
  }) {
    t ? (this.#n = !1, this.#r = t) : this.#n = !0, this.#l = t?._uiManager || e, this.#o = this.#l._eventBus, this.#i = t?.color?.toUpperCase() || this.#l?.highlightColors.values().next().value || "#FFFF98", Ft.#u ||= Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    });
  }
  renderButton() {
    const t = this.#t = document.createElement("button");
    t.className = "colorPicker", t.tabIndex = "0", t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), t.ariaHasPopup = "true", this.#r && (t.ariaControls = `${this.#r.id}_colorpicker_dropdown`);
    const e = this.#l._signal;
    t.addEventListener("click", this.#p.bind(this), {
      signal: e
    }), t.addEventListener("keydown", this.#m.bind(this), {
      signal: e
    });
    const s = this.#e = document.createElement("span");
    return s.className = "swatch", s.ariaHidden = "true", s.style.backgroundColor = this.#i, t.append(s), t;
  }
  renderMainDropdown() {
    const t = this.#s = this.#d();
    return t.ariaOrientation = "horizontal", t.ariaLabelledBy = "highlightColorPickerLabel", t;
  }
  #d() {
    const t = document.createElement("div"), e = this.#l._signal;
    t.addEventListener("contextmenu", Bt, {
      signal: e
    }), t.className = "dropdown", t.role = "listbox", t.ariaMultiSelectable = "false", t.ariaOrientation = "vertical", t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown"), this.#r && (t.id = `${this.#r.id}_colorpicker_dropdown`);
    for (const [s, i] of this.#l.highlightColors) {
      const n = document.createElement("button");
      n.tabIndex = "0", n.role = "option", n.setAttribute("data-color", i), n.title = s, n.setAttribute("data-l10n-id", Ft.#u[s]);
      const r = document.createElement("span");
      n.append(r), r.className = "swatch", r.style.backgroundColor = i, n.ariaSelected = i === this.#i, n.addEventListener("click", this.#f.bind(this, i), {
        signal: e
      }), t.append(n);
    }
    return t.addEventListener("keydown", this.#m.bind(this), {
      signal: e
    }), t;
  }
  #f(t, e) {
    e.stopPropagation(), this.#o.dispatch("switchannotationeditorparams", {
      source: this,
      type: J.HIGHLIGHT_COLOR,
      value: t
    }), this.updateColor(t);
  }
  _colorSelectFromKeyboard(t) {
    if (t.target === this.#t) {
      this.#p(t);
      return;
    }
    const e = t.target.getAttribute("data-color");
    e && this.#f(e, t);
  }
  _moveToNext(t) {
    if (!this.#g) {
      this.#p(t);
      return;
    }
    if (t.target === this.#t) {
      this.#s.firstChild?.focus();
      return;
    }
    t.target.nextSibling?.focus();
  }
  _moveToPrevious(t) {
    if (t.target === this.#s?.firstChild || t.target === this.#t) {
      this.#g && this._hideDropdownFromKeyboard();
      return;
    }
    this.#g || this.#p(t), t.target.previousSibling?.focus();
  }
  _moveToBeginning(t) {
    if (!this.#g) {
      this.#p(t);
      return;
    }
    this.#s.firstChild?.focus();
  }
  _moveToEnd(t) {
    if (!this.#g) {
      this.#p(t);
      return;
    }
    this.#s.lastChild?.focus();
  }
  #m(t) {
    Ft._keyboardManager.exec(this, t);
  }
  #p(t) {
    if (this.#g) {
      this.hideDropdown();
      return;
    }
    if (this.#a = t.detail === 0, this.#h || (this.#h = new AbortController(), window.addEventListener("pointerdown", this.#c.bind(this), {
      signal: this.#l.combinedSignal(this.#h)
    })), this.#t.ariaExpanded = "true", this.#s) {
      this.#s.classList.remove("hidden");
      return;
    }
    const e = this.#s = this.#d();
    this.#t.append(e);
  }
  #c(t) {
    this.#s?.contains(t.target) || this.hideDropdown();
  }
  hideDropdown() {
    this.#s?.classList.add("hidden"), this.#t.ariaExpanded = "false", this.#h?.abort(), this.#h = null;
  }
  get #g() {
    return this.#s && !this.#s.classList.contains("hidden");
  }
  _hideDropdownFromKeyboard() {
    if (!this.#n) {
      if (!this.#g) {
        this.#r?.unselect();
        return;
      }
      this.hideDropdown(), this.#t.focus({
        preventScroll: !0,
        focusVisible: this.#a
      });
    }
  }
  updateColor(t) {
    if (this.#e && (this.#e.style.backgroundColor = t), !this.#s)
      return;
    const e = this.#l.highlightColors.values();
    for (const s of this.#s.children)
      s.ariaSelected = e.next().value === t.toUpperCase();
  }
  destroy() {
    this.#t?.remove(), this.#t = null, this.#e = null, this.#s?.remove(), this.#s = null;
  }
}
class ze {
  #t = null;
  #e = null;
  #i = null;
  static #s = null;
  constructor(t) {
    this.#e = t, this.#i = t._uiManager, ze.#s ||= Object.freeze({
      freetext: "pdfjs-editor-color-picker-free-text-input",
      ink: "pdfjs-editor-color-picker-ink-input"
    });
  }
  renderButton() {
    if (this.#t)
      return this.#t;
    const {
      editorType: t,
      colorType: e,
      colorValue: s
    } = this.#e, i = this.#t = document.createElement("input");
    return i.type = "color", i.value = s || "#000000", i.className = "basicColorPicker", i.tabIndex = 0, i.setAttribute("data-l10n-id", ze.#s[t]), i.addEventListener("input", () => {
      this.#i.updateParams(e, i.value);
    }, {
      signal: this.#i._signal
    }), i;
  }
  update(t) {
    this.#t && (this.#t.value = t);
  }
  destroy() {
    this.#t?.remove(), this.#t = null;
  }
  hideDropdown() {
  }
}
W(116);
W(531);
function Bi(h) {
  return Math.floor(Math.max(0, Math.min(1, h)) * 255).toString(16).padStart(2, "0");
}
function ke(h) {
  return Math.max(0, Math.min(255, 255 * h));
}
class _i {
  static CMYK_G([t, e, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * t + 0.59 * s + 0.11 * e + i)];
  }
  static G_CMYK([t]) {
    return ["CMYK", 0, 0, 0, 1 - t];
  }
  static G_RGB([t]) {
    return ["RGB", t, t, t];
  }
  static G_rgb([t]) {
    return t = ke(t), [t, t, t];
  }
  static G_HTML([t]) {
    const e = Bi(t);
    return `#${e}${e}${e}`;
  }
  static RGB_G([t, e, s]) {
    return ["G", 0.3 * t + 0.59 * e + 0.11 * s];
  }
  static RGB_rgb(t) {
    return t.map(ke);
  }
  static RGB_HTML(t) {
    return `#${t.map(Bi).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([t, e, s, i]) {
    return ["RGB", 1 - Math.min(1, t + i), 1 - Math.min(1, s + i), 1 - Math.min(1, e + i)];
  }
  static CMYK_rgb([t, e, s, i]) {
    return [ke(1 - Math.min(1, t + i)), ke(1 - Math.min(1, s + i)), ke(1 - Math.min(1, e + i))];
  }
  static CMYK_HTML(t) {
    const e = this.CMYK_RGB(t).slice(1);
    return this.RGB_HTML(e);
  }
  static RGB_CMYK([t, e, s]) {
    const i = 1 - t, n = 1 - e, r = 1 - s, a = Math.min(i, n, r);
    return ["CMYK", i, n, r, a];
  }
}
class zr {
  create(t, e, s = !1) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${t}px`), i.setAttribute("height", `${e}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${t} ${e}`), i;
  }
  createElement(t) {
    if (typeof t != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(t);
  }
  _createSVG(t) {
    it("Abstract method `_createSVG` called.");
  }
}
class Ve extends zr {
  _createSVG(t) {
    return document.createElementNS(qt, t);
  }
}
const Vr = 9, pe = /* @__PURE__ */ new WeakSet(), Gr = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
class Ui {
  static create(t) {
    switch (t.data.annotationType) {
      case ft.LINK:
        return new ni(t);
      case ft.TEXT:
        return new Xr(t);
      case ft.WIDGET:
        switch (t.data.fieldType) {
          case "Tx":
            return new Yr(t);
          case "Btn":
            return t.data.radioButton ? new bn(t) : t.data.checkBox ? new Jr(t) : new Qr(t);
          case "Ch":
            return new Zr(t);
          case "Sig":
            return new Kr(t);
        }
        return new me(t);
      case ft.POPUP:
        return new Us(t);
      case ft.FREETEXT:
        return new An(t);
      case ft.LINE:
        return new ta(t);
      case ft.SQUARE:
        return new ea(t);
      case ft.CIRCLE:
        return new sa(t);
      case ft.POLYLINE:
        return new wn(t);
      case ft.CARET:
        return new na(t);
      case ft.INK:
        return new ri(t);
      case ft.POLYGON:
        return new ia(t);
      case ft.HIGHLIGHT:
        return new En(t);
      case ft.UNDERLINE:
        return new ra(t);
      case ft.SQUIGGLY:
        return new aa(t);
      case ft.STRIKEOUT:
        return new oa(t);
      case ft.STAMP:
        return new Sn(t);
      case ft.FILEATTACHMENT:
        return new la(t);
      default:
        return new dt(t);
    }
  }
}
class dt {
  #t = null;
  #e = !1;
  #i = null;
  constructor(t, {
    isRenderable: e = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    this.isRenderable = e, this.data = t.data, this.layer = t.layer, this.linkService = t.linkService, this.downloadManager = t.downloadManager, this.imageResourcesPath = t.imageResourcesPath, this.renderForms = t.renderForms, this.svgFactory = t.svgFactory, this.annotationStorage = t.annotationStorage, this.enableComment = t.enableComment, this.enableScripting = t.enableScripting, this.hasJSActions = t.hasJSActions, this._fieldObjects = t.fieldObjects, this.parent = t.parent, e && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    contentsObj: t,
    richText: e
  }) {
    return !!(t?.str || e?.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return dt._hasPopupData(this.data) || this.enableComment && !!this.commentText;
  }
  get commentData() {
    const {
      data: t
    } = this, e = this.annotationStorage?.getEditor(t.id);
    return e ? e.getData() : t;
  }
  get hasCommentButton() {
    return this.enableComment && this.hasPopupElement;
  }
  get commentButtonPosition() {
    const t = this.annotationStorage?.getEditor(this.data.id);
    if (t)
      return t.commentButtonPositionInPage;
    const {
      quadPoints: e,
      inkLists: s,
      rect: i
    } = this.data;
    let n = -1 / 0, r = -1 / 0;
    if (e?.length >= 8) {
      for (let a = 0; a < e.length; a += 8)
        e[a + 1] > r ? (r = e[a + 1], n = e[a + 2]) : e[a + 1] === r && (n = Math.max(n, e[a + 2]));
      return [n, r];
    }
    if (s?.length >= 1) {
      for (const a of s)
        for (let o = 0, l = a.length; o < l; o += 2)
          a[o + 1] > r ? (r = a[o + 1], n = a[o]) : a[o + 1] === r && (n = Math.max(n, a[o]));
      if (n !== 1 / 0)
        return [n, r];
    }
    return i ? [i[2], i[3]] : null;
  }
  _normalizePoint(t) {
    const {
      page: {
        view: e
      },
      viewport: {
        rawDims: {
          pageWidth: s,
          pageHeight: i,
          pageX: n,
          pageY: r
        }
      }
    } = this.parent;
    return t[1] = e[3] - t[1] + e[1], t[0] = 100 * (t[0] - n) / s, t[1] = 100 * (t[1] - r) / i, t;
  }
  get commentText() {
    const {
      data: t
    } = this;
    return this.annotationStorage.getRawValue(`${He}${t.id}`)?.popup?.contents || t.contentsObj?.str || "";
  }
  set commentText(t) {
    const {
      data: e
    } = this, s = {
      deleted: !t,
      contents: t || ""
    };
    this.annotationStorage.updateEditor(e.id, {
      popup: s
    }) || this.annotationStorage.setValue(`${He}${e.id}`, {
      id: e.id,
      annotationType: e.annotationType,
      pageIndex: this.parent.page._pageIndex,
      popup: s,
      popupRef: e.popupRef,
      modificationDate: /* @__PURE__ */ new Date()
    }), t || this.removePopup();
  }
  removePopup() {
    (this.#i?.popup || this.popup)?.remove(), this.#i = this.popup = null;
  }
  updateEdited(t) {
    if (!this.container)
      return;
    t.rect && (this.#t ||= {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: e,
      popup: s
    } = t;
    e && this.#s(e);
    let i = this.#i?.popup || this.popup;
    !i && s?.text && (this._createPopup(s), i = this.#i.popup), i && (i.updateEdited(t), s?.deleted && (i.remove(), this.#i = null, this.popup = null));
  }
  resetEdited() {
    this.#t && (this.#s(this.#t.rect), this.#i?.popup.resetEdited(), this.#t = null);
  }
  #s(t) {
    const {
      container: {
        style: e
      },
      data: {
        rect: s,
        rotation: i
      },
      parent: {
        viewport: {
          rawDims: {
            pageWidth: n,
            pageHeight: r,
            pageX: a,
            pageY: o
          }
        }
      }
    } = this;
    s?.splice(0, 4, ...t), e.left = `${100 * (t[0] - a) / n}%`, e.top = `${100 * (r - t[3] + o) / r}%`, i === 0 ? (e.width = `${100 * (t[2] - t[0]) / n}%`, e.height = `${100 * (t[3] - t[1]) / r}%`) : this.setRotation(i);
  }
  _createContainer(t) {
    const {
      data: e,
      parent: {
        page: s,
        viewport: i
      }
    } = this, n = document.createElement("section");
    n.setAttribute("data-annotation-id", e.id), !(this instanceof me) && !(this instanceof ni) && (n.tabIndex = 0);
    const {
      style: r
    } = n;
    if (r.zIndex = this.parent.zIndex, this.parent.zIndex += 2, e.alternativeText && (n.title = e.alternativeText), e.noRotate && n.classList.add("norotate"), !e.rect || this instanceof Us) {
      const {
        rotation: p
      } = e;
      return !e.hasOwnCanvas && p !== 0 && this.setRotation(p, n), n;
    }
    const {
      width: a,
      height: o
    } = this;
    if (!t && e.borderStyle.width > 0) {
      r.borderWidth = `${e.borderStyle.width}px`;
      const p = e.borderStyle.horizontalCornerRadius, v = e.borderStyle.verticalCornerRadius;
      if (p > 0 || v > 0) {
        const b = `calc(${p}px * var(--total-scale-factor)) / calc(${v}px * var(--total-scale-factor))`;
        r.borderRadius = b;
      } else if (this instanceof bn) {
        const b = `calc(${a}px * var(--total-scale-factor)) / calc(${o}px * var(--total-scale-factor))`;
        r.borderRadius = b;
      }
      switch (e.borderStyle.style) {
        case be.SOLID:
          r.borderStyle = "solid";
          break;
        case be.DASHED:
          r.borderStyle = "dashed";
          break;
        case be.BEVELED:
          z("Unimplemented border style: beveled");
          break;
        case be.INSET:
          z("Unimplemented border style: inset");
          break;
        case be.UNDERLINE:
          r.borderBottomStyle = "solid";
          break;
      }
      const m = e.borderColor || null;
      m ? (this.#e = !0, r.borderColor = B.makeHexColor(m[0] | 0, m[1] | 0, m[2] | 0)) : r.borderWidth = 0;
    }
    const l = B.normalizeRect([e.rect[0], s.view[3] - e.rect[1] + s.view[1], e.rect[2], s.view[3] - e.rect[3] + s.view[1]]), {
      pageWidth: c,
      pageHeight: d,
      pageX: u,
      pageY: f
    } = i.rawDims;
    r.left = `${100 * (l[0] - u) / c}%`, r.top = `${100 * (l[1] - f) / d}%`;
    const {
      rotation: g
    } = e;
    return e.hasOwnCanvas || g === 0 ? (r.width = `${100 * a / c}%`, r.height = `${100 * o / d}%`) : this.setRotation(g, n), n;
  }
  setRotation(t, e = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims;
    let {
      width: n,
      height: r
    } = this;
    t % 180 !== 0 && ([n, r] = [r, n]), e.style.width = `${100 * n / s}%`, e.style.height = `${100 * r / i}%`, e.setAttribute("data-main-rotation", (360 - t) % 360);
  }
  get _commonActions() {
    const t = (e, s, i) => {
      const n = i.detail[e], r = n[0], a = n.slice(1);
      i.target.style[s] = _i[`${r}_HTML`](a), this.annotationStorage.setValue(this.data.id, {
        [s]: _i[`${r}_rgb`](a)
      });
    };
    return K(this, "_commonActions", {
      display: (e) => {
        const {
          display: s
        } = e.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      },
      print: (e) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !e.detail.print
        });
      },
      hidden: (e) => {
        const {
          hidden: s
        } = e.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      },
      focus: (e) => {
        setTimeout(() => e.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (e) => {
        e.target.title = e.detail.userName;
      },
      readonly: (e) => {
        e.target.disabled = e.detail.readonly;
      },
      required: (e) => {
        this._setRequired(e.target, e.detail.required);
      },
      bgColor: (e) => {
        t("bgColor", "backgroundColor", e);
      },
      fillColor: (e) => {
        t("fillColor", "backgroundColor", e);
      },
      fgColor: (e) => {
        t("fgColor", "color", e);
      },
      textColor: (e) => {
        t("textColor", "color", e);
      },
      borderColor: (e) => {
        t("borderColor", "borderColor", e);
      },
      strokeColor: (e) => {
        t("strokeColor", "borderColor", e);
      },
      rotation: (e) => {
        const s = e.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }
    });
  }
  _dispatchEventFromSandbox(t, e) {
    const s = this._commonActions;
    for (const i of Object.keys(e.detail))
      (t[i] || s[i])?.(e);
  }
  _setDefaultPropertiesFromJS(t) {
    if (!this.enableScripting)
      return;
    const e = this.annotationStorage.getRawValue(this.data.id);
    if (!e)
      return;
    const s = this._commonActions;
    for (const [i, n] of Object.entries(e)) {
      const r = s[i];
      if (r) {
        const a = {
          detail: {
            [i]: n
          },
          target: t
        };
        r(a), delete e[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: t
    } = this.data;
    if (!t)
      return;
    const [e, s, i, n] = this.data.rect.map((p) => Math.fround(p));
    if (t.length === 8) {
      const [p, v, m, b] = t.subarray(2, 6);
      if (i === p && n === v && e === m && s === b)
        return;
    }
    const {
      style: r
    } = this.container;
    let a;
    if (this.#e) {
      const {
        borderColor: p,
        borderWidth: v
      } = r;
      r.borderWidth = 0, a = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${p}" stroke-width="${v}">`], this.container.classList.add("hasBorder");
    }
    const o = i - e, l = n - s, {
      svgFactory: c
    } = this, d = c.createElement("svg");
    d.classList.add("quadrilateralsContainer"), d.setAttribute("width", 0), d.setAttribute("height", 0), d.role = "none";
    const u = c.createElement("defs");
    d.append(u);
    const f = c.createElement("clipPath"), g = `clippath_${this.data.id}`;
    f.setAttribute("id", g), f.setAttribute("clipPathUnits", "objectBoundingBox"), u.append(f);
    for (let p = 2, v = t.length; p < v; p += 8) {
      const m = t[p], b = t[p + 1], y = t[p + 2], E = t[p + 3], A = c.createElement("rect"), w = (y - e) / o, S = (n - b) / l, x = (m - y) / o, T = (b - E) / l;
      A.setAttribute("x", w), A.setAttribute("y", S), A.setAttribute("width", x), A.setAttribute("height", T), f.append(A), a?.push(`<rect vector-effect="non-scaling-stroke" x="${w}" y="${S}" width="${x}" height="${T}"/>`);
    }
    this.#e && (a.push("</g></svg>')"), r.backgroundImage = a.join("")), this.container.append(d), this.container.style.clipPath = `url(#${g})`;
  }
  _createPopup(t = null) {
    const {
      data: e
    } = this;
    let s, i;
    t ? (s = {
      str: t.text
    }, i = t.date) : (s = e.contentsObj, i = e.modificationDate);
    const n = this.#i = new Us({
      data: {
        color: e.color,
        titleObj: e.titleObj,
        modificationDate: i,
        contentsObj: s,
        richText: e.richText,
        parentRect: e.rect,
        borderStyle: 0,
        id: `popup_${e.id}`,
        rotation: e.rotation,
        noRotate: !0
      },
      linkService: this.linkService,
      parent: this.parent,
      elements: [this]
    });
    this.parent._commentManager || this.parent.div.append(n.render());
  }
  get hasPopupElement() {
    return !!(this.#i || this.popup || this.data.popupRef);
  }
  get extraPopupElement() {
    return this.#i;
  }
  render() {
    it("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(t, e = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[t];
      if (i)
        for (const {
          page: n,
          id: r,
          exportValues: a
        } of i) {
          if (n === -1 || r === e)
            continue;
          const o = typeof a == "string" ? a : null, l = document.querySelector(`[data-element-id="${r}"]`);
          if (l && !pe.has(l)) {
            z(`_getElementsByName - element not allowed: ${r}`);
            continue;
          }
          s.push({
            id: r,
            exportValue: o,
            domElement: l
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(t)) {
      const {
        exportValue: n
      } = i, r = i.getAttribute("data-element-id");
      r !== e && pe.has(i) && s.push({
        id: r,
        exportValue: n,
        domElement: i
      });
    }
    return s;
  }
  show() {
    this.container && (this.container.hidden = !1), this.popup?.maybeShow();
  }
  hide() {
    this.container && (this.container.hidden = !0), this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const t = this.getElementsToTriggerPopup();
    if (Array.isArray(t))
      for (const e of t)
        e.classList.add("highlightArea");
    else
      t.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: t,
      data: {
        id: e
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", {
        source: this,
        mode: t,
        editId: e,
        mustEnterInEditMode: !0
      });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
}
class Wr extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.editor = t.editor;
  }
  render() {
    return this.container.className = "editorAnnotation", this.container;
  }
  createOrUpdatePopup() {
    const {
      editor: t
    } = this;
    t.hasComment && (this._createPopup(t.comment), this.extraPopupElement.popup.renderCommentButton());
  }
  get hasCommentButton() {
    return this.enableComment && this.editor.hasComment;
  }
  get commentButtonPosition() {
    return this.editor.commentButtonPositionInPage;
  }
  get commentText() {
    return this.editor.comment.text;
  }
  set commentText(t) {
    this.editor.comment = t, t || this.removePopup();
  }
  get commentData() {
    return this.editor.getData();
  }
  remove() {
    this.container.remove(), this.container = null, this.removePopup();
  }
}
class ni extends dt {
  constructor(t, e = null) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !!e?.ignoreBorder,
      createQuadrilaterals: !0
    }), this.isTooltipOnly = t.data.isTooltipOnly;
  }
  render() {
    const {
      data: t,
      linkService: e
    } = this, s = document.createElement("a");
    s.setAttribute("data-element-id", t.id);
    let i = !1;
    return t.url ? (e.addLinkAttributes(s, t.url, t.newWindow), i = !0) : t.action ? (this._bindNamedAction(s, t.action, t.overlaidText), i = !0) : t.attachment ? (this.#e(s, t.attachment, t.overlaidText, t.attachmentDest), i = !0) : t.setOCGState ? (this.#i(s, t.setOCGState, t.overlaidText), i = !0) : t.dest ? (this._bindLink(s, t.dest, t.overlaidText), i = !0) : (t.actions && (t.actions.Action || t.actions["Mouse Up"] || t.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(s, t), i = !0), t.resetForm ? (this._bindResetFormAction(s, t.resetForm), i = !0) : this.isTooltipOnly && !i && (this._bindLink(s, ""), i = !0)), this.container.classList.add("linkAnnotation"), i && this.container.append(s), this.container;
  }
  #t() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(t, e, s = "") {
    t.href = this.linkService.getDestinationHash(e), t.onclick = () => (e && this.linkService.goToDestination(e), !1), (e || e === "") && this.#t(), s && (t.title = s);
  }
  _bindNamedAction(t, e, s = "") {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeNamedAction(e), !1), s && (t.title = s), this.#t();
  }
  #e(t, e, s = "", i = null) {
    t.href = this.linkService.getAnchorUrl(""), e.description ? t.title = e.description : s && (t.title = s), t.onclick = () => (this.downloadManager?.openOrDownloadData(e.content, e.filename, i), !1), this.#t();
  }
  #i(t, e, s = "") {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeSetOCGState(e), !1), s && (t.title = s), this.#t();
  }
  _bindJSAction(t, e) {
    t.href = this.linkService.getAnchorUrl("");
    const s = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const i of Object.keys(e.actions)) {
      const n = s.get(i);
      n && (t[n] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: e.id,
          name: i
        }
      }), !1));
    }
    e.overlaidText && (t.title = e.overlaidText), t.onclick || (t.onclick = () => !1), this.#t();
  }
  _bindResetFormAction(t, e) {
    const s = t.onclick;
    if (s || (t.href = this.linkService.getAnchorUrl("")), this.#t(), !this._fieldObjects) {
      z('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), s || (t.onclick = () => !1);
      return;
    }
    t.onclick = () => {
      s?.();
      const {
        fields: i,
        refs: n,
        include: r
      } = e, a = [];
      if (i.length !== 0 || n.length !== 0) {
        const c = new Set(n);
        for (const d of i) {
          const u = this._fieldObjects[d] || [];
          for (const {
            id: f
          } of u)
            c.add(f);
        }
        for (const d of Object.values(this._fieldObjects))
          for (const u of d)
            c.has(u.id) === r && a.push(u);
      } else
        for (const c of Object.values(this._fieldObjects))
          a.push(...c);
      const o = this.annotationStorage, l = [];
      for (const c of a) {
        const {
          id: d
        } = c;
        switch (l.push(d), c.type) {
          case "text": {
            const f = c.defaultValue || "";
            o.setValue(d, {
              value: f
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const f = c.defaultValue === c.exportValues;
            o.setValue(d, {
              value: f
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const f = c.defaultValue || "";
            o.setValue(d, {
              value: f
            });
            break;
          }
          default:
            continue;
        }
        const u = document.querySelector(`[data-element-id="${d}"]`);
        if (u) {
          if (!pe.has(u)) {
            z(`_bindResetFormAction - element not allowed: ${d}`);
            continue;
          }
        } else continue;
        u.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: l,
          name: "ResetForm"
        }
      }), !1;
    };
  }
}
class Xr extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const t = document.createElement("img");
    return t.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", t.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), t.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(t), this.container;
  }
}
class me extends dt {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(t) {
    this.data.hasOwnCanvas && (t.previousSibling?.nodeName === "CANVAS" && (t.previousSibling.hidden = !0), t.hidden = !1);
  }
  _getKeyModifier(t) {
    return wt.platform.isMac ? t.metaKey : t.ctrlKey;
  }
  _setEventListener(t, e, s, i, n) {
    s.includes("mouse") ? t.addEventListener(s, (r) => {
      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r),
          shift: r.shiftKey,
          modifier: this._getKeyModifier(r)
        }
      });
    }) : t.addEventListener(s, (r) => {
      if (s === "blur") {
        if (!e.focused || !r.relatedTarget)
          return;
        e.focused = !1;
      } else if (s === "focus") {
        if (e.focused)
          return;
        e.focused = !0;
      }
      n && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r)
        }
      });
    });
  }
  _setEventListeners(t, e, s, i) {
    for (const [n, r] of s)
      (r === "Action" || this.data.actions?.[r]) && ((r === "Focus" || r === "Blur") && (e ||= {
        focused: !1
      }), this._setEventListener(t, e, n, r, i), r === "Focus" && !this.data.actions?.Blur ? this._setEventListener(t, e, "blur", "Blur", null) : r === "Blur" && !this.data.actions?.Focus && this._setEventListener(t, e, "focus", "Focus", null));
  }
  _setBackgroundColor(t) {
    const e = this.data.backgroundColor || null;
    t.style.backgroundColor = e === null ? "transparent" : B.makeHexColor(e[0], e[1], e[2]);
  }
  _setTextStyle(t) {
    const e = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || Vr, n = t.style;
    let r;
    const a = 2, o = (l) => Math.round(10 * l) / 10;
    if (this.data.multiLine) {
      const l = Math.abs(this.data.rect[3] - this.data.rect[1] - a), c = Math.round(l / (xs * i)) || 1, d = l / c;
      r = Math.min(i, o(d / xs));
    } else {
      const l = Math.abs(this.data.rect[3] - this.data.rect[1] - a);
      r = Math.min(i, o(l / xs));
    }
    n.fontSize = `calc(${r}px * var(--total-scale-factor))`, n.color = B.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (n.textAlign = e[this.data.textAlignment]);
  }
  _setRequired(t, e) {
    e ? t.setAttribute("required", !0) : t.removeAttribute("required"), t.setAttribute("aria-required", e);
  }
}
class Yr extends me {
  constructor(t) {
    const e = t.renderForms || t.data.hasOwnCanvas || !t.data.hasAppearance && !!t.data.fieldValue;
    super(t, {
      isRenderable: e
    });
  }
  setPropertyOnSiblings(t, e, s, i) {
    const n = this.annotationStorage;
    for (const r of this._getElementsByName(t.name, t.id))
      r.domElement && (r.domElement[e] = s), n.setValue(r.id, {
        [i]: s
      });
  }
  render() {
    const t = this.annotationStorage, e = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const i = t.getValue(e, {
        value: this.data.fieldValue
      });
      let n = i.value || "";
      const r = t.getValue(e, {
        charLimit: this.data.maxLen
      }).charLimit;
      r && n.length > r && (n = n.slice(0, r));
      let a = i.formattedValue || this.data.textContent?.join(`
`) || null;
      a && this.data.comb && (a = a.replaceAll(/\s+/g, ""));
      const o = {
        userValue: n,
        formattedValue: a,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = a ?? n, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = this.data.password ? "password" : "text", s.setAttribute("value", a ?? n), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), pe.add(s), s.setAttribute("data-element-id", e), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = 0;
      const {
        datetimeFormat: l,
        datetimeType: c,
        timeStep: d
      } = this.data, u = !!c && this.enableScripting;
      l && (s.title = l), this._setRequired(s, this.data.required), r && (s.maxLength = r), s.addEventListener("input", (g) => {
        t.setValue(e, {
          value: g.target.value
        }), this.setPropertyOnSiblings(s, "value", g.target.value, "value"), o.formattedValue = null;
      }), s.addEventListener("resetform", (g) => {
        const p = this.data.defaultFieldValue ?? "";
        s.value = o.userValue = p, o.formattedValue = null;
      });
      let f = (g) => {
        const {
          formattedValue: p
        } = o;
        p != null && (g.target.value = p), g.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (p) => {
          if (o.focused)
            return;
          const {
            target: v
          } = p;
          if (u && (v.type = c, d && (v.step = d)), o.userValue) {
            const m = o.userValue;
            if (u)
              if (c === "time") {
                const b = new Date(m), y = [b.getHours(), b.getMinutes(), b.getSeconds()];
                v.value = y.map((E) => E.toString().padStart(2, "0")).join(":");
              } else
                v.value = new Date(m - Gr).toISOString().split(c === "date" ? "T" : ".", 1)[0];
            else
              v.value = m;
          }
          o.lastCommittedValue = v.value, o.commitKey = 1, this.data.actions?.Focus || (o.focused = !0);
        }), s.addEventListener("updatefromsandbox", (p) => {
          this.showElementAndHideCanvas(p.target);
          const v = {
            value(m) {
              o.userValue = m.detail.value ?? "", u || t.setValue(e, {
                value: o.userValue.toString()
              }), m.target.value = o.userValue;
            },
            formattedValue(m) {
              const {
                formattedValue: b
              } = m.detail;
              o.formattedValue = b, b != null && m.target !== document.activeElement && (m.target.value = b);
              const y = {
                formattedValue: b
              };
              u && (y.value = b), t.setValue(e, y);
            },
            selRange(m) {
              m.target.setSelectionRange(...m.detail.selRange);
            },
            charLimit: (m) => {
              const {
                charLimit: b
              } = m.detail, {
                target: y
              } = m;
              if (b === 0) {
                y.removeAttribute("maxLength");
                return;
              }
              y.setAttribute("maxLength", b);
              let E = o.userValue;
              !E || E.length <= b || (E = E.slice(0, b), y.value = o.userValue = E, t.setValue(e, {
                value: E
              }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: e,
                  name: "Keystroke",
                  value: E,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: y.selectionStart,
                  selEnd: y.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(v, p);
        }), s.addEventListener("keydown", (p) => {
          o.commitKey = 1;
          let v = -1;
          if (p.key === "Escape" ? v = 0 : p.key === "Enter" && !this.data.multiLine ? v = 2 : p.key === "Tab" && (o.commitKey = 3), v === -1)
            return;
          const {
            value: m
          } = p.target;
          o.lastCommittedValue !== m && (o.lastCommittedValue = m, o.userValue = m, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: m,
              willCommit: !0,
              commitKey: v,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          }));
        });
        const g = f;
        f = null, s.addEventListener("blur", (p) => {
          if (!o.focused || !p.relatedTarget)
            return;
          this.data.actions?.Blur || (o.focused = !1);
          const {
            target: v
          } = p;
          let {
            value: m
          } = v;
          if (u) {
            if (m && c === "time") {
              const b = m.split(":").map((y) => parseInt(y, 10));
              m = new Date(2e3, 0, 1, b[0], b[1], b[2] || 0).valueOf(), v.step = "";
            } else
              m.includes("T") || (m = `${m}T00:00`), m = new Date(m).valueOf();
            v.type = "text";
          }
          o.userValue = m, o.lastCommittedValue !== m && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: m,
              willCommit: !0,
              commitKey: o.commitKey,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          }), g(p);
        }), this.data.actions?.Keystroke && s.addEventListener("beforeinput", (p) => {
          o.lastCommittedValue = null;
          const {
            data: v,
            target: m
          } = p, {
            value: b,
            selectionStart: y,
            selectionEnd: E
          } = m;
          let A = y, w = E;
          switch (p.inputType) {
            case "deleteWordBackward": {
              const S = b.substring(0, y).match(/\w*[^\w]*$/);
              S && (A -= S[0].length);
              break;
            }
            case "deleteWordForward": {
              const S = b.substring(y).match(/^[^\w]*\w*/);
              S && (w += S[0].length);
              break;
            }
            case "deleteContentBackward":
              y === E && (A -= 1);
              break;
            case "deleteContentForward":
              y === E && (w += 1);
              break;
          }
          p.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: b,
              change: v || "",
              willCommit: !1,
              selStart: A,
              selEnd: w
            }
          });
        }), this._setEventListeners(s, o, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (p) => p.target.value);
      }
      if (f && s.addEventListener("blur", f), this.data.comb) {
        const p = (this.data.rect[2] - this.data.rect[0]) / r;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${p}px * var(--total-scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class Kr extends me {
  constructor(t) {
    super(t, {
      isRenderable: !!t.data.hasOwnCanvas
    });
  }
}
class Jr extends me {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    const t = this.annotationStorage, e = this.data, s = e.id;
    let i = t.getValue(s, {
      value: e.exportValue === e.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", t.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n = document.createElement("input");
    return pe.add(n), n.setAttribute("data-element-id", s), n.disabled = e.readOnly, this._setRequired(n, this.data.required), n.type = "checkbox", n.name = e.fieldName, i && n.setAttribute("checked", !0), n.setAttribute("exportValue", e.exportValue), n.tabIndex = 0, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: o
      } = r.target;
      for (const l of this._getElementsByName(a, s)) {
        const c = o && l.exportValue === e.exportValue;
        l.domElement && (l.domElement.checked = c), t.setValue(l.id, {
          value: c
        });
      }
      t.setValue(s, {
        value: o
      });
    }), n.addEventListener("resetform", (r) => {
      const a = e.defaultFieldValue || "Off";
      r.target.checked = a === e.exportValue;
    }), this.enableScripting && this.hasJSActions && (n.addEventListener("updatefromsandbox", (r) => {
      const a = {
        value(o) {
          o.target.checked = o.detail.value !== "Off", t.setValue(s, {
            value: o.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(a, r);
    }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (r) => r.target.checked)), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class bn extends me {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const t = this.annotationStorage, e = this.data, s = e.id;
    let i = t.getValue(s, {
      value: e.fieldValue === e.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== e.buttonValue, t.setValue(s, {
      value: i
    })), i)
      for (const r of this._getElementsByName(e.fieldName, s))
        t.setValue(r.id, {
          value: !1
        });
    const n = document.createElement("input");
    if (pe.add(n), n.setAttribute("data-element-id", s), n.disabled = e.readOnly, this._setRequired(n, this.data.required), n.type = "radio", n.name = e.fieldName, i && n.setAttribute("checked", !0), n.tabIndex = 0, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: o
      } = r.target;
      for (const l of this._getElementsByName(a, s))
        t.setValue(l.id, {
          value: !1
        });
      t.setValue(s, {
        value: o
      });
    }), n.addEventListener("resetform", (r) => {
      const a = e.defaultFieldValue;
      r.target.checked = a != null && a === e.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const r = e.buttonValue;
      n.addEventListener("updatefromsandbox", (a) => {
        const o = {
          value: (l) => {
            const c = r === l.detail.value;
            for (const d of this._getElementsByName(l.target.name)) {
              const u = c && d.id === s;
              d.domElement && (d.domElement.checked = u), t.setValue(d.id, {
                value: u
              });
            }
          }
        };
        this._dispatchEventFromSandbox(o, a);
      }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (a) => a.target.checked);
    }
    return this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class Qr extends ni {
  constructor(t) {
    super(t, {
      ignoreBorder: t.data.hasAppearance
    });
  }
  render() {
    const t = super.render();
    t.classList.add("buttonWidgetAnnotation", "pushButton");
    const e = t.lastChild;
    return this.enableScripting && this.hasJSActions && e && (this._setDefaultPropertiesFromJS(e), e.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), t;
  }
}
class Zr extends me {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const t = this.annotationStorage, e = this.data.id, s = t.getValue(e, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    pe.add(i), i.setAttribute("data-element-id", e), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = 0;
    let n = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (c) => {
      const d = this.data.defaultFieldValue;
      for (const u of i.options)
        u.selected = u.value === d;
    });
    for (const c of this.data.options) {
      const d = document.createElement("option");
      d.textContent = c.displayValue, d.value = c.exportValue, s.value.includes(c.exportValue) && (d.setAttribute("selected", !0), n = !1), i.append(d);
    }
    let r = null;
    if (n) {
      const c = document.createElement("option");
      c.value = " ", c.setAttribute("hidden", !0), c.setAttribute("selected", !0), i.prepend(c), r = () => {
        c.remove(), i.removeEventListener("input", r), r = null;
      }, i.addEventListener("input", r);
    }
    const a = (c) => {
      const d = c ? "value" : "textContent", {
        options: u,
        multiple: f
      } = i;
      return f ? Array.prototype.filter.call(u, (g) => g.selected).map((g) => g[d]) : u.selectedIndex === -1 ? null : u[u.selectedIndex][d];
    };
    let o = a(!1);
    const l = (c) => {
      const d = c.target.options;
      return Array.prototype.map.call(d, (u) => ({
        displayValue: u.textContent,
        exportValue: u.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (c) => {
      const d = {
        value(u) {
          r?.();
          const f = u.detail.value, g = new Set(Array.isArray(f) ? f : [f]);
          for (const p of i.options)
            p.selected = g.has(p.value);
          t.setValue(e, {
            value: a(!0)
          }), o = a(!1);
        },
        multipleSelection(u) {
          i.multiple = !0;
        },
        remove(u) {
          const f = i.options, g = u.detail.remove;
          f[g].selected = !1, i.remove(g), f.length > 0 && Array.prototype.findIndex.call(f, (v) => v.selected) === -1 && (f[0].selected = !0), t.setValue(e, {
            value: a(!0),
            items: l(u)
          }), o = a(!1);
        },
        clear(u) {
          for (; i.length !== 0; )
            i.remove(0);
          t.setValue(e, {
            value: null,
            items: []
          }), o = a(!1);
        },
        insert(u) {
          const {
            index: f,
            displayValue: g,
            exportValue: p
          } = u.detail.insert, v = i.children[f], m = document.createElement("option");
          m.textContent = g, m.value = p, v ? v.before(m) : i.append(m), t.setValue(e, {
            value: a(!0),
            items: l(u)
          }), o = a(!1);
        },
        items(u) {
          const {
            items: f
          } = u.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const g of f) {
            const {
              displayValue: p,
              exportValue: v
            } = g, m = document.createElement("option");
            m.textContent = p, m.value = v, i.append(m);
          }
          i.options.length > 0 && (i.options[0].selected = !0), t.setValue(e, {
            value: a(!0),
            items: l(u)
          }), o = a(!1);
        },
        indices(u) {
          const f = new Set(u.detail.indices);
          for (const g of u.target.options)
            g.selected = f.has(g.index);
          t.setValue(e, {
            value: a(!0)
          }), o = a(!1);
        },
        editable(u) {
          u.target.disabled = !u.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(d, c);
    }), i.addEventListener("input", (c) => {
      const d = a(!0), u = a(!1);
      t.setValue(e, {
        value: d
      }), c.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: e,
          name: "Keystroke",
          value: o,
          change: u,
          changeEx: d,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (c) => c.target.value)) : i.addEventListener("input", function(c) {
      t.setValue(e, {
        value: a(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class Us extends dt {
  constructor(t) {
    const {
      data: e,
      elements: s,
      parent: i
    } = t, n = !!i._commentManager;
    if (super(t, {
      isRenderable: !n && dt._hasPopupData(e)
    }), this.elements = s, n && dt._hasPopupData(e)) {
      const r = this.popup = this.#t();
      for (const a of s)
        a.popup = r;
    } else
      this.popup = null;
  }
  #t() {
    return new qr({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate || this.data.creationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open,
      commentManager: this.parent._commentManager
    });
  }
  render() {
    const {
      container: t
    } = this;
    t.classList.add("popupAnnotation"), t.role = "comment";
    const e = this.popup = this.#t(), s = [];
    for (const i of this.elements)
      i.popup = e, i.container.ariaHasPopup = "dialog", s.push(i.data.id), i.addHighlightArea();
    return this.container.setAttribute("aria-controls", s.map((i) => `${Ws}${i}`).join(",")), this.container;
  }
}
class qr {
  #t = null;
  #e = this.#V.bind(this);
  #i = this.#U.bind(this);
  #s = this.#O.bind(this);
  #a = this.#w.bind(this);
  #n = null;
  #r = null;
  #o = null;
  #h = null;
  #l = null;
  #u = null;
  #d = null;
  #f = !1;
  #m = null;
  #p = null;
  #c = null;
  #g = null;
  #v = null;
  #b = null;
  #y = null;
  #T = null;
  #S = null;
  #A = null;
  #P = !1;
  #E = null;
  #x = null;
  constructor({
    container: t,
    color: e,
    elements: s,
    titleObj: i,
    modificationDate: n,
    contentsObj: r,
    richText: a,
    parent: o,
    rect: l,
    parentRect: c,
    open: d,
    commentManager: u = null
  }) {
    this.#r = t, this.#S = i, this.#o = r, this.#T = a, this.#u = o, this.#n = e, this.#y = l, this.#d = c, this.#l = s, this.#t = u, this.#E = s[0], this.#h = Pe.toDateObject(n), this.trigger = s.flatMap((f) => f.getElementsToTriggerPopup()), u ? this.renderCommentButton() : (this.#M(), this.#r.hidden = !0, d && this.#w());
  }
  #M() {
    if (this.#p)
      return;
    this.#p = new AbortController();
    const {
      signal: t
    } = this.#p;
    for (const e of this.trigger)
      e.addEventListener("click", this.#a, {
        signal: t
      }), e.addEventListener("pointerenter", this.#s, {
        signal: t
      }), e.addEventListener("pointerleave", this.#i, {
        signal: t
      }), e.classList.add("popupTriggerArea");
    for (const e of this.#l)
      e.container?.addEventListener("keydown", this.#e, {
        signal: t
      });
  }
  #R() {
    const t = this.#l.find((e) => e.hasCommentButton);
    t && (this.#v = t._normalizePoint(t.commentButtonPosition));
  }
  renderCommentButton() {
    if (this.#g || (this.#v || this.#R(), !this.#v))
      return;
    const {
      signal: t
    } = this.#p = new AbortController(), e = !!this.#E.extraPopupElement, s = () => {
      this.#t.toggleCommentPopup(this, !0, void 0, !e);
    }, i = () => {
      this.#t.toggleCommentPopup(this, !1, !0, !e);
    }, n = () => {
      this.#t.toggleCommentPopup(this, !1, !1);
    };
    if (e) {
      this.#g = this.#E.container;
      for (const r of this.trigger)
        r.ariaHasPopup = "dialog", r.ariaControls = "commentPopup", r.addEventListener("keydown", this.#e, {
          signal: t
        }), r.addEventListener("click", s, {
          signal: t
        }), r.addEventListener("pointerenter", i, {
          signal: t
        }), r.addEventListener("pointerleave", n, {
          signal: t
        }), r.classList.add("popupTriggerArea");
    } else {
      const r = this.#g = document.createElement("button");
      r.className = "annotationCommentButton";
      const a = this.#E.container;
      r.style.zIndex = a.style.zIndex + 1, r.tabIndex = 0, r.ariaHasPopup = "dialog", r.ariaControls = "commentPopup", r.setAttribute("data-l10n-id", "pdfjs-show-comment-button"), this.#B(), this.#I(), r.addEventListener("keydown", this.#e, {
        signal: t
      }), r.addEventListener("click", s, {
        signal: t
      }), r.addEventListener("pointerenter", i, {
        signal: t
      }), r.addEventListener("pointerleave", n, {
        signal: t
      }), a.after(r);
    }
  }
  #I() {
    if (this.#E.extraPopupElement && !this.#E.editor)
      return;
    this.renderCommentButton();
    const [t, e] = this.#v, {
      style: s
    } = this.#g;
    s.left = `calc(${t}%)`, s.top = `calc(${e}% - var(--comment-button-dim))`;
  }
  #B() {
    this.#E.extraPopupElement || (this.renderCommentButton(), this.#g.style.backgroundColor = this.commentButtonColor || "");
  }
  get commentButtonColor() {
    const {
      color: t,
      opacity: e
    } = this.#E.commentData;
    return t ? this.#u._commentManager.makeCommentColor(t, e) : null;
  }
  focusCommentButton() {
    setTimeout(() => {
      this.#g?.focus();
    }, 0);
  }
  getData() {
    const {
      richText: t,
      color: e,
      opacity: s,
      creationDate: i,
      modificationDate: n
    } = this.#E.commentData;
    return {
      contentsObj: {
        str: this.comment
      },
      richText: t,
      color: e,
      opacity: s,
      creationDate: i,
      modificationDate: n
    };
  }
  get elementBeforePopup() {
    return this.#g;
  }
  get comment() {
    return this.#x ||= this.#E.commentText, this.#x;
  }
  set comment(t) {
    t !== this.comment && (this.#E.commentText = this.#x = t);
  }
  get parentBoundingClientRect() {
    return this.#E.layer.getBoundingClientRect();
  }
  setCommentButtonStates({
    selected: t,
    hasPopup: e
  }) {
    this.#g && (this.#g.classList.toggle("selected", t), this.#g.ariaExpanded = e);
  }
  setSelectedCommentButton(t) {
    this.#g.classList.toggle("selected", t);
  }
  get commentPopupPosition() {
    if (this.#b)
      return this.#b;
    const {
      x: t,
      y: e,
      height: s
    } = this.#g.getBoundingClientRect(), {
      x: i,
      y: n,
      width: r,
      height: a
    } = this.#E.layer.getBoundingClientRect();
    return [(t - i) / r, (e + s - n) / a];
  }
  set commentPopupPosition(t) {
    this.#b = t;
  }
  hasDefaultPopupPosition() {
    return this.#b === null;
  }
  get commentButtonPosition() {
    return this.#v;
  }
  get commentButtonWidth() {
    return this.#g.getBoundingClientRect().width / this.parentBoundingClientRect.width;
  }
  editComment(t) {
    const [e, s] = this.#b || this.commentButtonPosition.map((l) => l / 100), i = this.parentBoundingClientRect, {
      x: n,
      y: r,
      width: a,
      height: o
    } = i;
    this.#t.showDialog(null, this, n + e * a, r + s * o, {
      ...t,
      parentDimensions: i
    });
  }
  render() {
    if (this.#m)
      return;
    const t = this.#m = document.createElement("div");
    if (t.className = "popup", this.#n) {
      const s = t.style.outlineColor = B.makeHexColor(...this.#n);
      t.style.backgroundColor = `color-mix(in srgb, ${s} 30%, white)`;
    }
    const e = document.createElement("span");
    if (e.className = "header", this.#S?.str) {
      const s = document.createElement("span");
      s.className = "title", e.append(s), {
        dir: s.dir,
        str: s.textContent
      } = this.#S;
    }
    if (t.append(e), this.#h) {
      const s = document.createElement("time");
      s.className = "popupDate", s.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), s.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: this.#h.valueOf()
      })), s.dateTime = this.#h.toISOString(), e.append(s);
    }
    Ys({
      html: this.#L || this.#o.str,
      dir: this.#o?.dir,
      className: "popupContent"
    }, t), this.#r.append(t);
  }
  get #L() {
    const t = this.#T, e = this.#o;
    return t?.str && (!e?.str || e.str === t.str) && this.#T.html || null;
  }
  get #k() {
    return this.#L?.attributes?.style?.fontSize || 0;
  }
  get #_() {
    return this.#L?.attributes?.style?.color || null;
  }
  #F(t) {
    const e = [], s = {
      str: t,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [{
          name: "p",
          children: e
        }]
      }
    }, i = {
      style: {
        color: this.#_,
        fontSize: this.#k ? `calc(${this.#k}px * var(--total-scale-factor))` : ""
      }
    };
    for (const n of t.split(`
`))
      e.push({
        name: "span",
        value: n,
        attributes: i
      });
    return s;
  }
  #V(t) {
    t.altKey || t.shiftKey || t.ctrlKey || t.metaKey || (t.key === "Enter" || t.key === "Escape" && this.#f) && this.#w();
  }
  updateEdited({
    rect: t,
    popup: e,
    deleted: s
  }) {
    if (this.#t) {
      s ? (this.remove(), this.#x = null) : e && (e.deleted ? this.remove() : (this.#B(), this.#x = e.text)), t && (this.#v = null, this.#R(), this.#I());
      return;
    }
    if (s || e?.deleted) {
      this.remove();
      return;
    }
    this.#M(), this.#A ||= {
      contentsObj: this.#o,
      richText: this.#T
    }, t && (this.#c = null), e && e.text && (this.#T = this.#F(e.text), this.#h = Pe.toDateObject(e.date), this.#o = null), this.#m?.remove(), this.#m = null;
  }
  resetEdited() {
    this.#A && ({
      contentsObj: this.#o,
      richText: this.#T
    } = this.#A, this.#A = null, this.#m?.remove(), this.#m = null, this.#c = null);
  }
  remove() {
    if (this.#p?.abort(), this.#p = null, this.#m?.remove(), this.#m = null, this.#P = !1, this.#f = !1, this.#g?.remove(), this.#g = null, this.trigger)
      for (const t of this.trigger)
        t.classList.remove("popupTriggerArea");
  }
  #C() {
    if (this.#c !== null)
      return;
    const {
      page: {
        view: t
      },
      viewport: {
        rawDims: {
          pageWidth: e,
          pageHeight: s,
          pageX: i,
          pageY: n
        }
      }
    } = this.#u;
    let r = !!this.#d, a = r ? this.#d : this.#y;
    for (const g of this.#l)
      if (!a || B.intersect(g.data.rect, a) !== null) {
        a = g.data.rect, r = !0;
        break;
      }
    const o = B.normalizeRect([a[0], t[3] - a[1] + t[1], a[2], t[3] - a[3] + t[1]]), c = r ? a[2] - a[0] + 5 : 0, d = o[0] + c, u = o[1];
    this.#c = [100 * (d - i) / e, 100 * (u - n) / s];
    const {
      style: f
    } = this.#r;
    f.left = `${this.#c[0]}%`, f.top = `${this.#c[1]}%`;
  }
  #w() {
    if (this.#t) {
      this.#t.toggleCommentPopup(this, !1);
      return;
    }
    this.#f = !this.#f, this.#f ? (this.#O(), this.#r.addEventListener("click", this.#a), this.#r.addEventListener("keydown", this.#e)) : (this.#U(), this.#r.removeEventListener("click", this.#a), this.#r.removeEventListener("keydown", this.#e));
  }
  #O() {
    this.#m || this.render(), this.isVisible ? this.#f && this.#r.classList.add("focused") : (this.#C(), this.#r.hidden = !1, this.#r.style.zIndex = parseInt(this.#r.style.zIndex) + 1e3);
  }
  #U() {
    this.#r.classList.remove("focused"), !(this.#f || !this.isVisible) && (this.#r.hidden = !0, this.#r.style.zIndex = parseInt(this.#r.style.zIndex) - 1e3);
  }
  forceHide() {
    this.#P = this.isVisible, this.#P && (this.#r.hidden = !0);
  }
  maybeShow() {
    this.#t || (this.#M(), this.#P && (this.#m || this.#O(), this.#P = !1, this.#r.hidden = !1));
  }
  get isVisible() {
    return this.#t ? !1 : this.#r.hidden === !1;
  }
}
class An extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = t.data.textContent, this.textPosition = t.data.textPosition, this.annotationEditorType = G.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const t = document.createElement("div");
      t.classList.add("annotationTextContent"), t.setAttribute("role", "comment");
      for (const e of this.textContent) {
        const s = document.createElement("span");
        s.textContent = e, t.append(s);
      }
      this.container.append(t);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
class ta extends dt {
  #t = null;
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const {
      data: t,
      width: e,
      height: s
    } = this, i = this.svgFactory.create(e, s, !0), n = this.#t = this.svgFactory.createElement("svg:line");
    return n.setAttribute("x1", t.rect[2] - t.lineCoordinates[0]), n.setAttribute("y1", t.rect[3] - t.lineCoordinates[1]), n.setAttribute("x2", t.rect[2] - t.lineCoordinates[2]), n.setAttribute("y2", t.rect[3] - t.lineCoordinates[3]), n.setAttribute("stroke-width", t.borderStyle.width || 1), n.setAttribute("stroke", "transparent"), n.setAttribute("fill", "transparent"), i.append(n), this.container.append(i), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#t;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class ea extends dt {
  #t = null;
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const {
      data: t,
      width: e,
      height: s
    } = this, i = this.svgFactory.create(e, s, !0), n = t.borderStyle.width, r = this.#t = this.svgFactory.createElement("svg:rect");
    return r.setAttribute("x", n / 2), r.setAttribute("y", n / 2), r.setAttribute("width", e - n), r.setAttribute("height", s - n), r.setAttribute("stroke-width", n || 1), r.setAttribute("stroke", "transparent"), r.setAttribute("fill", "transparent"), i.append(r), this.container.append(i), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#t;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class sa extends dt {
  #t = null;
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const {
      data: t,
      width: e,
      height: s
    } = this, i = this.svgFactory.create(e, s, !0), n = t.borderStyle.width, r = this.#t = this.svgFactory.createElement("svg:ellipse");
    return r.setAttribute("cx", e / 2), r.setAttribute("cy", s / 2), r.setAttribute("rx", e / 2 - n / 2), r.setAttribute("ry", s / 2 - n / 2), r.setAttribute("stroke-width", n || 1), r.setAttribute("stroke", "transparent"), r.setAttribute("fill", "transparent"), i.append(r), this.container.append(i), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#t;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class wn extends dt {
  #t = null;
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        vertices: e,
        borderStyle: s,
        popupRef: i
      },
      width: n,
      height: r
    } = this;
    if (!e)
      return this.container;
    const a = this.svgFactory.create(n, r, !0);
    let o = [];
    for (let c = 0, d = e.length; c < d; c += 2) {
      const u = e[c] - t[0], f = t[3] - e[c + 1];
      o.push(`${u},${f}`);
    }
    o = o.join(" ");
    const l = this.#t = this.svgFactory.createElement(this.svgElementName);
    return l.setAttribute("points", o), l.setAttribute("stroke-width", s.width || 1), l.setAttribute("stroke", "transparent"), l.setAttribute("fill", "transparent"), a.append(l), this.container.append(a), !i && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return this.#t;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class ia extends wn {
  constructor(t) {
    super(t), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class na extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
class ri extends dt {
  #t = null;
  #e = [];
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = this.data.it === "InkHighlight" ? G.HIGHLIGHT : G.INK;
  }
  #i(t, e) {
    switch (t) {
      case 90:
        return {
          transform: `rotate(90) translate(${-e[0]},${e[1]}) scale(1,-1)`,
          width: e[3] - e[1],
          height: e[2] - e[0]
        };
      case 180:
        return {
          transform: `rotate(180) translate(${-e[2]},${e[1]}) scale(1,-1)`,
          width: e[2] - e[0],
          height: e[3] - e[1]
        };
      case 270:
        return {
          transform: `rotate(270) translate(${-e[2]},${e[3]}) scale(1,-1)`,
          width: e[3] - e[1],
          height: e[2] - e[0]
        };
      default:
        return {
          transform: `translate(${-e[0]},${e[3]}) scale(1,-1)`,
          width: e[2] - e[0],
          height: e[3] - e[1]
        };
    }
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        rotation: e,
        inkLists: s,
        borderStyle: i,
        popupRef: n
      }
    } = this, {
      transform: r,
      width: a,
      height: o
    } = this.#i(e, t), l = this.svgFactory.create(a, o, !0), c = this.#t = this.svgFactory.createElement("svg:g");
    l.append(c), c.setAttribute("stroke-width", i.width || 1), c.setAttribute("stroke-linecap", "round"), c.setAttribute("stroke-linejoin", "round"), c.setAttribute("stroke-miterlimit", 10), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), c.setAttribute("transform", r);
    for (let d = 0, u = s.length; d < u; d++) {
      const f = this.svgFactory.createElement(this.svgElementName);
      this.#e.push(f), f.setAttribute("points", s[d].join(",")), c.append(f);
    }
    return !n && this.hasPopupData && this._createPopup(), this.container.append(l), this._editOnDoubleClick(), this.container;
  }
  updateEdited(t) {
    super.updateEdited(t);
    const {
      thickness: e,
      points: s,
      rect: i
    } = t, n = this.#t;
    if (e >= 0 && n.setAttribute("stroke-width", e || 1), s)
      for (let r = 0, a = this.#e.length; r < a; r++)
        this.#e[r].setAttribute("points", s[r].join(","));
    if (i) {
      const {
        transform: r,
        width: a,
        height: o
      } = this.#i(this.data.rotation, i);
      n.parentElement.setAttribute("viewBox", `0 0 ${a} ${o}`), n.setAttribute("transform", r);
    }
  }
  getElementsToTriggerPopup() {
    return this.#e;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class En extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    }), this.annotationEditorType = G.HIGHLIGHT;
  }
  render() {
    const {
      data: {
        overlaidText: t,
        popupRef: e
      }
    } = this;
    if (!e && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), t) {
      const s = document.createElement("mark");
      s.classList.add("overlaidText"), s.textContent = t, this.container.append(s);
    }
    return this.container;
  }
}
class ra extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    const {
      data: {
        overlaidText: t,
        popupRef: e
      }
    } = this;
    if (!e && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), t) {
      const s = document.createElement("u");
      s.classList.add("overlaidText"), s.textContent = t, this.container.append(s);
    }
    return this.container;
  }
}
class aa extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    const {
      data: {
        overlaidText: t,
        popupRef: e
      }
    } = this;
    if (!e && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), t) {
      const s = document.createElement("u");
      s.classList.add("overlaidText"), s.textContent = t, this.container.append(s);
    }
    return this.container;
  }
}
class oa extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    const {
      data: {
        overlaidText: t,
        popupRef: e
      }
    } = this;
    if (!e && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), t) {
      const s = document.createElement("s");
      s.classList.add("overlaidText"), s.textContent = t, this.container.append(s);
    }
    return this.container;
  }
}
class Sn extends dt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.annotationEditorType = G.STAMP;
  }
  render() {
    return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
class la extends dt {
  #t = null;
  constructor(t) {
    super(t, {
      isRenderable: !0
    });
    const {
      file: e
    } = this.data;
    this.filename = e.filename, this.content = e.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      ...e
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: t,
      data: e
    } = this;
    let s;
    e.hasAppearance || e.fillAlpha === 0 ? s = document.createElement("div") : (s = document.createElement("img"), s.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(e.name) ? "paperclip" : "pushpin"}.svg`, e.fillAlpha && e.fillAlpha < 1 && (s.style = `filter: opacity(${Math.round(e.fillAlpha * 100)}%);`)), s.addEventListener("dblclick", this.#e.bind(this)), this.#t = s;
    const {
      isMac: i
    } = wt.platform;
    return t.addEventListener("keydown", (n) => {
      n.key === "Enter" && (i ? n.metaKey : n.ctrlKey) && this.#e();
    }), !e.popupRef && this.hasPopupData ? this._createPopup() : s.classList.add("popupTriggerArea"), t.append(s), t;
  }
  getElementsToTriggerPopup() {
    return this.#t;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #e() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  }
}
class As {
  #t = null;
  #e = null;
  #i = null;
  #s = /* @__PURE__ */ new Map();
  #a = null;
  #n = null;
  constructor({
    div: t,
    accessibilityManager: e,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: n,
    viewport: r,
    structTreeLayer: a,
    commentManager: o,
    linkService: l,
    annotationStorage: c
  }) {
    this.div = t, this.#t = e, this.#e = s, this.#a = a || null, this.#n = l || null, this.#i = c || new Qs(), this.page = n, this.viewport = r, this.zIndex = 0, this._annotationEditorUIManager = i, this._commentManager = o || null;
  }
  hasEditableAnnotations() {
    return this.#s.size > 0;
  }
  async #r(t, e, s) {
    const i = t.firstChild || t, n = i.id = `${Ws}${e}`, r = await this.#a?.getAriaAttributes(n);
    if (r)
      for (const [a, o] of r)
        i.setAttribute(a, o);
    s ? s.at(-1).container.after(t) : (this.div.append(t), this.#t?.moveElementInDOM(this.div, t, i, !1));
  }
  async render(t) {
    const {
      annotations: e
    } = t, s = this.div;
    ae(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), n = {
      data: null,
      layer: s,
      linkService: this.#n,
      downloadManager: t.downloadManager,
      imageResourcesPath: t.imageResourcesPath || "",
      renderForms: t.renderForms !== !1,
      svgFactory: new Ve(),
      annotationStorage: this.#i,
      enableComment: t.enableComment === !0,
      enableScripting: t.enableScripting === !0,
      hasJSActions: t.hasJSActions,
      fieldObjects: t.fieldObjects,
      parent: this,
      elements: null
    };
    for (const r of e) {
      if (r.noHTML)
        continue;
      const a = r.annotationType === ft.POPUP;
      if (a) {
        const c = i.get(r.id);
        if (!c)
          continue;
        n.elements = c;
      } else if (r.rect[2] === r.rect[0] || r.rect[3] === r.rect[1])
        continue;
      n.data = r;
      const o = Ui.create(n);
      if (!o.isRenderable)
        continue;
      if (!a && r.popupRef) {
        const c = i.get(r.popupRef);
        c ? c.push(o) : i.set(r.popupRef, [o]);
      }
      const l = o.render();
      r.hidden && (l.style.visibility = "hidden"), await this.#r(l, r.id, n.elements), o.extraPopupElement?.popup?.renderCommentButton(), o._isEditable && (this.#s.set(o.data.id, o), this._annotationEditorUIManager?.renderAnnotationElement(o));
    }
    this.#o();
  }
  async addLinkAnnotations(t) {
    const e = {
      data: null,
      layer: this.div,
      linkService: this.#n,
      svgFactory: new Ve(),
      parent: this
    };
    for (const s of t) {
      s.borderStyle ||= As._defaultBorderStyle, e.data = s;
      const i = Ui.create(e);
      if (!i.isRenderable)
        continue;
      const n = i.render();
      await this.#r(n, s.id, null);
    }
  }
  update({
    viewport: t
  }) {
    const e = this.div;
    this.viewport = t, ae(e, {
      rotation: t.rotation
    }), this.#o(), e.hidden = !1;
  }
  #o() {
    if (!this.#e)
      return;
    const t = this.div;
    for (const [e, s] of this.#e) {
      const i = t.querySelector(`[data-annotation-id="${e}"]`);
      if (!i)
        continue;
      s.className = "annotationContent";
      const {
        firstChild: n
      } = i;
      n ? n.nodeName === "CANVAS" ? n.replaceWith(s) : n.classList.contains("annotationContent") ? n.after(s) : n.before(s) : i.append(s);
      const r = this.#s.get(e);
      r && (r._hasNoCanvas ? (this._annotationEditorUIManager?.setMissingCanvas(e, i.id, s), r._hasNoCanvas = !1) : r.canvas = s);
    }
    this.#e.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#s.values());
  }
  getEditableAnnotation(t) {
    return this.#s.get(t);
  }
  addFakeAnnotation(t) {
    const {
      div: e
    } = this, {
      id: s,
      rotation: i
    } = t, n = new Wr({
      data: {
        id: s,
        rect: t.getPDFRect(),
        rotation: i
      },
      editor: t,
      layer: e,
      parent: this,
      enableComment: !!this._commentManager,
      linkService: this.#n,
      annotationStorage: this.#i
    }), r = n.render();
    return e.append(r), this.#t?.moveElementInDOM(e, r, r, !1), n.createOrUpdatePopup(), n;
  }
  static get _defaultBorderStyle() {
    return K(this, "_defaultBorderStyle", Object.freeze({
      width: 1,
      rawWidth: 1,
      style: be.SOLID,
      dashArray: [3],
      horizontalCornerRadius: 0,
      verticalCornerRadius: 0
    }));
  }
}
const os = /\r\n?|\n/g;
class yt extends U {
  #t = "";
  #e = `${this.id}-editor`;
  #i = null;
  #s;
  _colorPicker = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const t = yt.prototype, e = (n) => n.isEmpty(), s = ne.TRANSLATE_SMALL, i = ne.TRANSLATE_BIG;
    return K(this, "_keyboardManager", new Ye([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t._translateEmpty, {
      args: [-s, 0],
      checker: e
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t._translateEmpty, {
      args: [-i, 0],
      checker: e
    }], [["ArrowRight", "mac+ArrowRight"], t._translateEmpty, {
      args: [s, 0],
      checker: e
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t._translateEmpty, {
      args: [i, 0],
      checker: e
    }], [["ArrowUp", "mac+ArrowUp"], t._translateEmpty, {
      args: [0, -s],
      checker: e
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t._translateEmpty, {
      args: [0, -i],
      checker: e
    }], [["ArrowDown", "mac+ArrowDown"], t._translateEmpty, {
      args: [0, s],
      checker: e
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t._translateEmpty, {
      args: [0, i],
      checker: e
    }]]));
  }
  static _type = "freetext";
  static _editorType = G.FREETEXT;
  constructor(t) {
    super({
      ...t,
      name: "freeTextEditor"
    }), this.color = t.color || yt._defaultColor || U._defaultLineColor, this.#s = t.fontSize || yt._defaultFontSize, this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
  }
  static initialize(t, e) {
    U.initialize(t, e);
    const s = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(s.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t, e) {
    switch (t) {
      case J.FREETEXT_SIZE:
        yt._defaultFontSize = e;
        break;
      case J.FREETEXT_COLOR:
        yt._defaultColor = e;
        break;
    }
  }
  updateParams(t, e) {
    switch (t) {
      case J.FREETEXT_SIZE:
        this.#a(e);
        break;
      case J.FREETEXT_COLOR:
        this.#n(e);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[J.FREETEXT_SIZE, yt._defaultFontSize], [J.FREETEXT_COLOR, yt._defaultColor || U._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[J.FREETEXT_SIZE, this.#s], [J.FREETEXT_COLOR, this.color]];
  }
  get toolbarButtons() {
    return this._colorPicker ||= new ze(this), [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return J.FREETEXT_COLOR;
  }
  #a(t) {
    const e = (i) => {
      this.editorDiv.style.fontSize = `calc(${i}px * var(--total-scale-factor))`, this.translate(0, -(i - this.#s) * this.parentScale), this.#s = i, this.#o();
    }, s = this.#s;
    this.addCommands({
      cmd: e.bind(this, t),
      undo: e.bind(this, s),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: J.FREETEXT_SIZE,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }
  onUpdatedColor() {
    this.editorDiv.style.color = this.color, this._colorPicker?.update(this.color), super.onUpdatedColor();
  }
  #n(t) {
    const e = (i) => {
      this.color = i, this.onUpdatedColor();
    }, s = this.color;
    this.addCommands({
      cmd: e.bind(this, t),
      undo: e.bind(this, s),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: J.FREETEXT_COLOR,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }
  _translateEmpty(t, e) {
    this._uiManager.translateSelectedEditors(t, e, !0);
  }
  getInitialTranslation() {
    const t = this.parentScale;
    return [-yt._internalPadding * t, -(yt._internalPadding + this.#s) * t];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (!super.enableEditMode())
      return !1;
    this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.#i = new AbortController();
    const t = this._uiManager.combinedSignal(this.#i);
    return this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal: t
    }), !0;
  }
  disableEditMode() {
    return super.disableEditMode() ? (this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", this.#e), this._isDraggable = !0, this.#i?.abort(), this.#i = null, this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"), !0) : !1;
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), t.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded(t) {
    this.width || (this.enableEditMode(), t && this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  #r() {
    const t = [];
    this.editorDiv.normalize();
    let e = null;
    for (const s of this.editorDiv.childNodes)
      e?.nodeType === Node.TEXT_NODE && s.nodeName === "BR" || (t.push(yt.#h(s)), e = s);
    return t.join(`
`);
  }
  #o() {
    const [t, e] = this.parentDimensions;
    let s;
    if (this.isAttachedToDOM)
      s = this.div.getBoundingClientRect();
    else {
      const {
        currentLayer: i,
        div: n
      } = this, r = n.style.display, a = n.classList.contains("hidden");
      n.classList.remove("hidden"), n.style.display = "hidden", i.div.append(this.div), s = n.getBoundingClientRect(), n.remove(), n.style.display = r, n.classList.toggle("hidden", a);
    }
    this.rotation % 180 === this.parentRotation % 180 ? (this.width = s.width / t, this.height = s.height / e) : (this.width = s.height / t, this.height = s.width / e), this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const t = this.#t, e = this.#t = this.#r().trimEnd();
    if (t === e)
      return;
    const s = (i) => {
      if (this.#t = i, !i) {
        this.remove();
        return;
      }
      this.#l(), this._uiManager.rebuild(this), this.#o();
    };
    this.addCommands({
      cmd: () => {
        s(e);
      },
      undo: () => {
        s(t);
      },
      mustExec: !1
    }), this.#o();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  keydown(t) {
    t.target === this.div && t.key === "Enter" && (this.enterInEditMode(), t.preventDefault());
  }
  editorDivKeydown(t) {
    yt._keyboardManager.exec(this, t);
  }
  editorDivFocus(t) {
    this.isEditing = !0;
  }
  editorDivBlur(t) {
    this.isEditing = !1;
  }
  editorDivInput(t) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  get canChangeContent() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, e;
    (this._isCopy || this.annotationElementId) && (t = this.x, e = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#e), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = !0;
    const {
      style: s
    } = this.editorDiv;
    if (s.fontSize = `calc(${this.#s}px * var(--total-scale-factor))`, s.color = this.color, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), this._isCopy || this.annotationElementId) {
      const [i, n] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: r
        } = this._initialData;
        let [a, o] = this.getInitialTranslation();
        [a, o] = this.pageTranslationToScreen(a, o);
        const [l, c] = this.pageDimensions, [d, u] = this.pageTranslation;
        let f, g;
        switch (this.rotation) {
          case 0:
            f = t + (r[0] - d) / l, g = e + this.height - (r[1] - u) / c;
            break;
          case 90:
            f = t + (r[0] - d) / l, g = e - (r[1] - u) / c, [a, o] = [o, -a];
            break;
          case 180:
            f = t - this.width + (r[0] - d) / l, g = e - (r[1] - u) / c, [a, o] = [-a, -o];
            break;
          case 270:
            f = t + (r[0] - d - this.height * c) / l, g = e + (r[1] - u - this.width * l) / c, [a, o] = [-o, a];
            break;
        }
        this.setAt(f * i, g * n, a, o);
      } else
        this._moveAfterPaste(t, e);
      this.#l(), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  static #h(t) {
    return (t.nodeType === Node.TEXT_NODE ? t.nodeValue : t.innerText).replaceAll(os, "");
  }
  editorDivPaste(t) {
    const e = t.clipboardData || window.clipboardData, {
      types: s
    } = e;
    if (s.length === 1 && s[0] === "text/plain")
      return;
    t.preventDefault();
    const i = yt.#d(e.getData("text") || "").replaceAll(os, `
`);
    if (!i)
      return;
    const n = window.getSelection();
    if (!n.rangeCount)
      return;
    this.editorDiv.normalize(), n.deleteFromDocument();
    const r = n.getRangeAt(0);
    if (!i.includes(`
`)) {
      r.insertNode(document.createTextNode(i)), this.editorDiv.normalize(), n.collapseToStart();
      return;
    }
    const {
      startContainer: a,
      startOffset: o
    } = r, l = [], c = [];
    if (a.nodeType === Node.TEXT_NODE) {
      const f = a.parentElement;
      if (c.push(a.nodeValue.slice(o).replaceAll(os, "")), f !== this.editorDiv) {
        let g = l;
        for (const p of this.editorDiv.childNodes) {
          if (p === f) {
            g = c;
            continue;
          }
          g.push(yt.#h(p));
        }
      }
      l.push(a.nodeValue.slice(0, o).replaceAll(os, ""));
    } else if (a === this.editorDiv) {
      let f = l, g = 0;
      for (const p of this.editorDiv.childNodes)
        g++ === o && (f = c), f.push(yt.#h(p));
    }
    this.#t = `${l.join(`
`)}${i}${c.join(`
`)}`, this.#l();
    const d = new Range();
    let u = Math.sumPrecise(l.map((f) => f.length));
    for (const {
      firstChild: f
    } of this.editorDiv.childNodes)
      if (f.nodeType === Node.TEXT_NODE) {
        const g = f.nodeValue.length;
        if (u <= g) {
          d.setStart(f, u), d.setEnd(f, u);
          break;
        }
        u -= g;
      }
    n.removeAllRanges(), n.addRange(d);
  }
  #l() {
    if (this.editorDiv.replaceChildren(), !!this.#t)
      for (const t of this.#t.split(`
`)) {
        const e = document.createElement("div");
        e.append(t ? document.createTextNode(t) : document.createElement("br")), this.editorDiv.append(e);
      }
  }
  #u() {
    return this.#t.replaceAll(" ", " ");
  }
  static #d(t) {
    return t.replaceAll(" ", " ");
  }
  get contentDiv() {
    return this.editorDiv;
  }
  getPDFRect() {
    const t = yt._internalPadding * this.parentScale;
    return this.getRect(t, t);
  }
  static async deserialize(t, e, s) {
    let i = null;
    if (t instanceof An) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: r,
            fontColor: a
          },
          rect: o,
          rotation: l,
          id: c,
          popupRef: d,
          richText: u,
          contentsObj: f,
          creationDate: g,
          modificationDate: p
        },
        textContent: v,
        textPosition: m,
        parent: {
          page: {
            pageNumber: b
          }
        }
      } = t;
      if (!v || v.length === 0)
        return null;
      i = t = {
        annotationType: G.FREETEXT,
        color: Array.from(a),
        fontSize: r,
        value: v.join(`
`),
        position: m,
        pageIndex: b - 1,
        rect: o.slice(0),
        rotation: l,
        annotationElementId: c,
        id: c,
        deleted: !1,
        popupRef: d,
        comment: f?.str || null,
        richText: u,
        creationDate: g,
        modificationDate: p
      };
    }
    const n = await super.deserialize(t, e, s);
    return n.#s = t.fontSize, n.color = B.makeHexColor(...t.color), n.#t = yt.#d(t.value), n._initialData = i, t.comment && n.setCommentData(t), n;
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const e = U._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color), s = Object.assign(super.serialize(t), {
      color: e,
      fontSize: this.#s,
      value: this.#u()
    });
    return this.addComment(s), t ? (s.isCopy = !0, s) : this.annotationElementId && !this.#f(s) ? null : (s.id = this.annotationElementId, s);
  }
  #f(t) {
    const {
      value: e,
      fontSize: s,
      color: i,
      pageIndex: n
    } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || t.value !== e || t.fontSize !== s || t.color.some((r, a) => r !== i[a]) || t.pageIndex !== n;
  }
  renderAnnotationElement(t) {
    const e = super.renderAnnotationElement(t);
    if (!e)
      return null;
    const {
      style: s
    } = e;
    s.fontSize = `calc(${this.#s}px * var(--total-scale-factor))`, s.color = this.color, e.replaceChildren();
    for (const i of this.#t.split(`
`)) {
      const n = document.createElement("div");
      n.append(i ? document.createTextNode(i) : document.createElement("br")), e.append(n);
    }
    return t.updateEdited({
      rect: this.getPDFRect(),
      popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
        text: this.#t
      }
    }), e;
  }
  resetAnnotationElement(t) {
    super.resetAnnotationElement(t), t.resetEdited();
  }
}
class _ {
  static PRECISION = 1e-4;
  toSVGPath() {
    it("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    it("Abstract getter `box` must be implemented.");
  }
  serialize(t, e) {
    it("Abstract method `serialize` must be implemented.");
  }
  static _rescale(t, e, s, i, n, r) {
    r ||= new Float32Array(t.length);
    for (let a = 0, o = t.length; a < o; a += 2)
      r[a] = e + t[a] * i, r[a + 1] = s + t[a + 1] * n;
    return r;
  }
  static _rescaleAndSwap(t, e, s, i, n, r) {
    r ||= new Float32Array(t.length);
    for (let a = 0, o = t.length; a < o; a += 2)
      r[a] = e + t[a + 1] * i, r[a + 1] = s + t[a] * n;
    return r;
  }
  static _translate(t, e, s, i) {
    i ||= new Float32Array(t.length);
    for (let n = 0, r = t.length; n < r; n += 2)
      i[n] = e + t[n], i[n + 1] = s + t[n + 1];
    return i;
  }
  static svgRound(t) {
    return Math.round(t * 1e4);
  }
  static _normalizePoint(t, e, s, i, n) {
    switch (n) {
      case 90:
        return [1 - e / s, t / i];
      case 180:
        return [1 - t / s, 1 - e / i];
      case 270:
        return [e / s, 1 - t / i];
      default:
        return [t / s, e / i];
    }
  }
  static _normalizePagePoint(t, e, s) {
    switch (s) {
      case 90:
        return [1 - e, t];
      case 180:
        return [1 - t, 1 - e];
      case 270:
        return [e, 1 - t];
      default:
        return [t, e];
    }
  }
  static createBezierPoints(t, e, s, i, n, r) {
    return [(t + 5 * s) / 6, (e + 5 * i) / 6, (5 * s + n) / 6, (5 * i + r) / 6, (s + n) / 2, (i + r) / 2];
  }
}
class he {
  #t;
  #e = [];
  #i;
  #s;
  #a = [];
  #n = new Float32Array(18);
  #r;
  #o;
  #h;
  #l;
  #u;
  #d;
  #f = [];
  static #m = 8;
  static #p = 2;
  static #c = he.#m + he.#p;
  constructor({
    x: t,
    y: e
  }, s, i, n, r, a = 0) {
    this.#t = s, this.#d = n * i, this.#s = r, this.#n.set([NaN, NaN, NaN, NaN, t, e], 6), this.#i = a, this.#l = he.#m * i, this.#h = he.#c * i, this.#u = i, this.#f.push(t, e);
  }
  isEmpty() {
    return isNaN(this.#n[8]);
  }
  #g() {
    const t = this.#n.subarray(4, 6), e = this.#n.subarray(16, 18), [s, i, n, r] = this.#t;
    return [(this.#r + (t[0] - e[0]) / 2 - s) / n, (this.#o + (t[1] - e[1]) / 2 - i) / r, (this.#r + (e[0] - t[0]) / 2 - s) / n, (this.#o + (e[1] - t[1]) / 2 - i) / r];
  }
  add({
    x: t,
    y: e
  }) {
    this.#r = t, this.#o = e;
    const [s, i, n, r] = this.#t;
    let [a, o, l, c] = this.#n.subarray(8, 12);
    const d = t - l, u = e - c, f = Math.hypot(d, u);
    if (f < this.#h)
      return !1;
    const g = f - this.#l, p = g / f, v = p * d, m = p * u;
    let b = a, y = o;
    a = l, o = c, l += v, c += m, this.#f?.push(t, e);
    const E = -m / g, A = v / g, w = E * this.#d, S = A * this.#d;
    return this.#n.set(this.#n.subarray(2, 8), 0), this.#n.set([l + w, c + S], 4), this.#n.set(this.#n.subarray(14, 18), 12), this.#n.set([l - w, c - S], 16), isNaN(this.#n[6]) ? (this.#a.length === 0 && (this.#n.set([a + w, o + S], 2), this.#a.push(NaN, NaN, NaN, NaN, (a + w - s) / n, (o + S - i) / r), this.#n.set([a - w, o - S], 14), this.#e.push(NaN, NaN, NaN, NaN, (a - w - s) / n, (o - S - i) / r)), this.#n.set([b, y, a, o, l, c], 6), !this.isEmpty()) : (this.#n.set([b, y, a, o, l, c], 6), Math.abs(Math.atan2(y - o, b - a) - Math.atan2(m, v)) < Math.PI / 2 ? ([a, o, l, c] = this.#n.subarray(2, 6), this.#a.push(NaN, NaN, NaN, NaN, ((a + l) / 2 - s) / n, ((o + c) / 2 - i) / r), [a, o, b, y] = this.#n.subarray(14, 18), this.#e.push(NaN, NaN, NaN, NaN, ((b + a) / 2 - s) / n, ((y + o) / 2 - i) / r), !0) : ([b, y, a, o, l, c] = this.#n.subarray(0, 6), this.#a.push(((b + 5 * a) / 6 - s) / n, ((y + 5 * o) / 6 - i) / r, ((5 * a + l) / 6 - s) / n, ((5 * o + c) / 6 - i) / r, ((a + l) / 2 - s) / n, ((o + c) / 2 - i) / r), [l, c, a, o, b, y] = this.#n.subarray(12, 18), this.#e.push(((b + 5 * a) / 6 - s) / n, ((y + 5 * o) / 6 - i) / r, ((5 * a + l) / 6 - s) / n, ((5 * o + c) / 6 - i) / r, ((a + l) / 2 - s) / n, ((o + c) / 2 - i) / r), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const t = this.#a, e = this.#e;
    if (isNaN(this.#n[6]) && !this.isEmpty())
      return this.#v();
    const s = [];
    s.push(`M${t[4]} ${t[5]}`);
    for (let i = 6; i < t.length; i += 6)
      isNaN(t[i]) ? s.push(`L${t[i + 4]} ${t[i + 5]}`) : s.push(`C${t[i]} ${t[i + 1]} ${t[i + 2]} ${t[i + 3]} ${t[i + 4]} ${t[i + 5]}`);
    this.#y(s);
    for (let i = e.length - 6; i >= 6; i -= 6)
      isNaN(e[i]) ? s.push(`L${e[i + 4]} ${e[i + 5]}`) : s.push(`C${e[i]} ${e[i + 1]} ${e[i + 2]} ${e[i + 3]} ${e[i + 4]} ${e[i + 5]}`);
    return this.#b(s), s.join(" ");
  }
  #v() {
    const [t, e, s, i] = this.#t, [n, r, a, o] = this.#g();
    return `M${(this.#n[2] - t) / s} ${(this.#n[3] - e) / i} L${(this.#n[4] - t) / s} ${(this.#n[5] - e) / i} L${n} ${r} L${a} ${o} L${(this.#n[16] - t) / s} ${(this.#n[17] - e) / i} L${(this.#n[14] - t) / s} ${(this.#n[15] - e) / i} Z`;
  }
  #b(t) {
    const e = this.#e;
    t.push(`L${e[4]} ${e[5]} Z`);
  }
  #y(t) {
    const [e, s, i, n] = this.#t, r = this.#n.subarray(4, 6), a = this.#n.subarray(16, 18), [o, l, c, d] = this.#g();
    t.push(`L${(r[0] - e) / i} ${(r[1] - s) / n} L${o} ${l} L${c} ${d} L${(a[0] - e) / i} ${(a[1] - s) / n}`);
  }
  newFreeDrawOutline(t, e, s, i, n, r) {
    return new xn(t, e, s, i, n, r);
  }
  getOutlines() {
    const t = this.#a, e = this.#e, s = this.#n, [i, n, r, a] = this.#t, o = new Float32Array((this.#f?.length ?? 0) + 2);
    for (let d = 0, u = o.length - 2; d < u; d += 2)
      o[d] = (this.#f[d] - i) / r, o[d + 1] = (this.#f[d + 1] - n) / a;
    if (o[o.length - 2] = (this.#r - i) / r, o[o.length - 1] = (this.#o - n) / a, isNaN(s[6]) && !this.isEmpty())
      return this.#T(o);
    const l = new Float32Array(this.#a.length + 24 + this.#e.length);
    let c = t.length;
    for (let d = 0; d < c; d += 2) {
      if (isNaN(t[d])) {
        l[d] = l[d + 1] = NaN;
        continue;
      }
      l[d] = t[d], l[d + 1] = t[d + 1];
    }
    c = this.#A(l, c);
    for (let d = e.length - 6; d >= 6; d -= 6)
      for (let u = 0; u < 6; u += 2) {
        if (isNaN(e[d + u])) {
          l[c] = l[c + 1] = NaN, c += 2;
          continue;
        }
        l[c] = e[d + u], l[c + 1] = e[d + u + 1], c += 2;
      }
    return this.#S(l, c), this.newFreeDrawOutline(l, o, this.#t, this.#u, this.#i, this.#s);
  }
  #T(t) {
    const e = this.#n, [s, i, n, r] = this.#t, [a, o, l, c] = this.#g(), d = new Float32Array(36);
    return d.set([NaN, NaN, NaN, NaN, (e[2] - s) / n, (e[3] - i) / r, NaN, NaN, NaN, NaN, (e[4] - s) / n, (e[5] - i) / r, NaN, NaN, NaN, NaN, a, o, NaN, NaN, NaN, NaN, l, c, NaN, NaN, NaN, NaN, (e[16] - s) / n, (e[17] - i) / r, NaN, NaN, NaN, NaN, (e[14] - s) / n, (e[15] - i) / r], 0), this.newFreeDrawOutline(d, t, this.#t, this.#u, this.#i, this.#s);
  }
  #S(t, e) {
    const s = this.#e;
    return t.set([NaN, NaN, NaN, NaN, s[4], s[5]], e), e += 6;
  }
  #A(t, e) {
    const s = this.#n.subarray(4, 6), i = this.#n.subarray(16, 18), [n, r, a, o] = this.#t, [l, c, d, u] = this.#g();
    return t.set([NaN, NaN, NaN, NaN, (s[0] - n) / a, (s[1] - r) / o, NaN, NaN, NaN, NaN, l, c, NaN, NaN, NaN, NaN, d, u, NaN, NaN, NaN, NaN, (i[0] - n) / a, (i[1] - r) / o], e), e += 24;
  }
}
class xn extends _ {
  #t;
  #e = new Float32Array(4);
  #i;
  #s;
  #a;
  #n;
  #r;
  constructor(t, e, s, i, n, r) {
    super(), this.#r = t, this.#a = e, this.#t = s, this.#n = i, this.#i = n, this.#s = r, this.firstPoint = [NaN, NaN], this.lastPoint = [NaN, NaN], this.#o(r);
    const [a, o, l, c] = this.#e;
    for (let d = 0, u = t.length; d < u; d += 2)
      t[d] = (t[d] - a) / l, t[d + 1] = (t[d + 1] - o) / c;
    for (let d = 0, u = e.length; d < u; d += 2)
      e[d] = (e[d] - a) / l, e[d + 1] = (e[d + 1] - o) / c;
  }
  toSVGPath() {
    const t = [`M${this.#r[4]} ${this.#r[5]}`];
    for (let e = 6, s = this.#r.length; e < s; e += 6) {
      if (isNaN(this.#r[e])) {
        t.push(`L${this.#r[e + 4]} ${this.#r[e + 5]}`);
        continue;
      }
      t.push(`C${this.#r[e]} ${this.#r[e + 1]} ${this.#r[e + 2]} ${this.#r[e + 3]} ${this.#r[e + 4]} ${this.#r[e + 5]}`);
    }
    return t.push("Z"), t.join(" ");
  }
  serialize([t, e, s, i], n) {
    const r = s - t, a = i - e;
    let o, l;
    switch (n) {
      case 0:
        o = _._rescale(this.#r, t, i, r, -a), l = _._rescale(this.#a, t, i, r, -a);
        break;
      case 90:
        o = _._rescaleAndSwap(this.#r, t, e, r, a), l = _._rescaleAndSwap(this.#a, t, e, r, a);
        break;
      case 180:
        o = _._rescale(this.#r, s, e, -r, a), l = _._rescale(this.#a, s, e, -r, a);
        break;
      case 270:
        o = _._rescaleAndSwap(this.#r, s, i, -r, -a), l = _._rescaleAndSwap(this.#a, s, i, -r, -a);
        break;
    }
    return {
      outline: Array.from(o),
      points: [Array.from(l)]
    };
  }
  #o(t) {
    const e = this.#r;
    let s = e[4], i = e[5];
    const n = [s, i, s, i];
    let r = s, a = i, o = s, l = i;
    const c = t ? Math.max : Math.min, d = new Float32Array(4);
    for (let f = 6, g = e.length; f < g; f += 6) {
      const p = e[f + 4], v = e[f + 5];
      isNaN(e[f]) ? (B.pointBoundingBox(p, v, n), a > v ? (r = p, a = v) : a === v && (r = c(r, p)), l < v ? (o = p, l = v) : l === v && (o = c(o, p))) : (d[0] = d[1] = 1 / 0, d[2] = d[3] = -1 / 0, B.bezierBoundingBox(s, i, ...e.slice(f, f + 6), d), B.rectBoundingBox(d[0], d[1], d[2], d[3], n), a > d[1] ? (r = d[0], a = d[1]) : a === d[1] && (r = c(r, d[0])), l < d[3] ? (o = d[2], l = d[3]) : l === d[3] && (o = c(o, d[2]))), s = p, i = v;
    }
    const u = this.#e;
    u[0] = n[0] - this.#i, u[1] = n[1] - this.#i, u[2] = n[2] - n[0] + 2 * this.#i, u[3] = n[3] - n[1] + 2 * this.#i, this.firstPoint = [r, a], this.lastPoint = [o, l];
  }
  get box() {
    return this.#e;
  }
  newOutliner(t, e, s, i, n, r = 0) {
    return new he(t, e, s, i, n, r);
  }
  getNewOutline(t, e) {
    const [s, i, n, r] = this.#e, [a, o, l, c] = this.#t, d = n * l, u = r * c, f = s * l + a, g = i * c + o, p = this.newOutliner({
      x: this.#a[0] * d + f,
      y: this.#a[1] * u + g
    }, this.#t, this.#n, t, this.#s, e ?? this.#i);
    for (let v = 2; v < this.#a.length; v += 2)
      p.add({
        x: this.#a[v] * d + f,
        y: this.#a[v + 1] * u + g
      });
    return p.getOutlines();
  }
}
class Hs {
  #t;
  #e;
  #i;
  #s = [];
  #a = [];
  constructor(t, e = 0, s = 0, i = !0) {
    const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = 10 ** -4;
    for (const {
      x: p,
      y: v,
      width: m,
      height: b
    } of t) {
      const y = Math.floor((p - e) / r) * r, E = Math.ceil((p + m + e) / r) * r, A = Math.floor((v - e) / r) * r, w = Math.ceil((v + b + e) / r) * r, S = [y, A, w, !0], x = [E, A, w, !1];
      this.#s.push(S, x), B.rectBoundingBox(y, A, E, w, n);
    }
    const a = n[2] - n[0] + 2 * s, o = n[3] - n[1] + 2 * s, l = n[0] - s, c = n[1] - s;
    let d = i ? -1 / 0 : 1 / 0, u = 1 / 0;
    const f = this.#s.at(i ? -1 : -2), g = [f[0], f[2]];
    for (const p of this.#s) {
      const [v, m, b, y] = p;
      !y && i ? m < u ? (u = m, d = v) : m === u && (d = Math.max(d, v)) : y && !i && (m < u ? (u = m, d = v) : m === u && (d = Math.min(d, v))), p[0] = (v - l) / a, p[1] = (m - c) / o, p[2] = (b - c) / o;
    }
    this.#t = new Float32Array([l, c, a, o]), this.#e = [d, u], this.#i = g;
  }
  getOutlines() {
    this.#s.sort((e, s) => e[0] - s[0] || e[1] - s[1] || e[2] - s[2]);
    const t = [];
    for (const e of this.#s)
      e[3] ? (t.push(...this.#l(e)), this.#o(e)) : (this.#h(e), t.push(...this.#l(e)));
    return this.#n(t);
  }
  #n(t) {
    const e = [], s = /* @__PURE__ */ new Set();
    for (const r of t) {
      const [a, o, l] = r;
      e.push([a, o, r], [a, l, r]);
    }
    e.sort((r, a) => r[1] - a[1] || r[0] - a[0]);
    for (let r = 0, a = e.length; r < a; r += 2) {
      const o = e[r][2], l = e[r + 1][2];
      o.push(l), l.push(o), s.add(o), s.add(l);
    }
    const i = [];
    let n;
    for (; s.size > 0; ) {
      const r = s.values().next().value;
      let [a, o, l, c, d] = r;
      s.delete(r);
      let u = a, f = o;
      for (n = [a, l], i.push(n); ; ) {
        let g;
        if (s.has(c))
          g = c;
        else if (s.has(d))
          g = d;
        else
          break;
        s.delete(g), [a, o, l, c, d] = g, u !== a && (n.push(u, f, a, f === o ? o : l), u = a), f = f === o ? l : o;
      }
      n.push(u, f);
    }
    return new ha(i, this.#t, this.#e, this.#i);
  }
  #r(t) {
    const e = this.#a;
    let s = 0, i = e.length - 1;
    for (; s <= i; ) {
      const n = s + i >> 1, r = e[n][0];
      if (r === t)
        return n;
      r < t ? s = n + 1 : i = n - 1;
    }
    return i + 1;
  }
  #o([, t, e]) {
    const s = this.#r(t);
    this.#a.splice(s, 0, [t, e]);
  }
  #h([, t, e]) {
    const s = this.#r(t);
    for (let i = s; i < this.#a.length; i++) {
      const [n, r] = this.#a[i];
      if (n !== t)
        break;
      if (n === t && r === e) {
        this.#a.splice(i, 1);
        return;
      }
    }
    for (let i = s - 1; i >= 0; i--) {
      const [n, r] = this.#a[i];
      if (n !== t)
        break;
      if (n === t && r === e) {
        this.#a.splice(i, 1);
        return;
      }
    }
  }
  #l(t) {
    const [e, s, i] = t, n = [[e, s, i]], r = this.#r(i);
    for (let a = 0; a < r; a++) {
      const [o, l] = this.#a[a];
      for (let c = 0, d = n.length; c < d; c++) {
        const [, u, f] = n[c];
        if (!(l <= u || f <= o)) {
          if (u >= o) {
            if (f > l)
              n[c][1] = l;
            else {
              if (d === 1)
                return [];
              n.splice(c, 1), c--, d--;
            }
            continue;
          }
          n[c][2] = o, f > l && n.push([e, l, f]);
        }
      }
    }
    return n;
  }
}
class ha extends _ {
  #t;
  #e;
  constructor(t, e, s, i) {
    super(), this.#e = t, this.#t = e, this.firstPoint = s, this.lastPoint = i;
  }
  toSVGPath() {
    const t = [];
    for (const e of this.#e) {
      let [s, i] = e;
      t.push(`M${s} ${i}`);
      for (let n = 2; n < e.length; n += 2) {
        const r = e[n], a = e[n + 1];
        r === s ? (t.push(`V${a}`), i = a) : a === i && (t.push(`H${r}`), s = r);
      }
      t.push("Z");
    }
    return t.join(" ");
  }
  serialize([t, e, s, i], n) {
    const r = [], a = s - t, o = i - e;
    for (const l of this.#e) {
      const c = new Array(l.length);
      for (let d = 0; d < l.length; d += 2)
        c[d] = t + l[d] * a, c[d + 1] = i - l[d + 1] * o;
      r.push(c);
    }
    return r;
  }
  get box() {
    return this.#t;
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
}
class $s extends he {
  newFreeDrawOutline(t, e, s, i, n, r) {
    return new ca(t, e, s, i, n, r);
  }
}
class ca extends xn {
  newOutliner(t, e, s, i, n, r = 0) {
    return new $s(t, e, s, i, n, r);
  }
}
class pt extends U {
  #t = null;
  #e = 0;
  #i;
  #s = null;
  #a = null;
  #n = null;
  #r = null;
  #o = 0;
  #h = null;
  #l = null;
  #u = null;
  #d = !1;
  #f = null;
  #m = null;
  #p = null;
  #c = "";
  #g;
  #v = "";
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 12;
  static _type = "highlight";
  static _editorType = G.HIGHLIGHT;
  static _freeHighlightId = -1;
  static _freeHighlight = null;
  static _freeHighlightClipId = "";
  static get _keyboardManager() {
    const t = pt.prototype;
    return K(this, "_keyboardManager", new Ye([[["ArrowLeft", "mac+ArrowLeft"], t._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], t._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], t._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], t._moveCaret, {
      args: [3]
    }]]));
  }
  constructor(t) {
    super({
      ...t,
      name: "highlightEditor"
    }), this.color = t.color || pt._defaultColor, this.#g = t.thickness || pt._defaultThickness, this.opacity = t.opacity || pt._defaultOpacity, this.#i = t.boxes || null, this.#v = t.methodOfCreation || "", this.#c = t.text || "", this._isDraggable = !1, this.defaultL10nId = "pdfjs-editor-highlight-editor", t.highlightId > -1 ? (this.#d = !0, this.#y(t), this.#E()) : this.#i && (this.#t = t.anchorNode, this.#e = t.anchorOffset, this.#r = t.focusNode, this.#o = t.focusOffset, this.#b(), this.#E(), this.rotate(this.rotation)), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: this.#d ? "free_highlight" : "highlight",
      color: this._uiManager.getNonHCMColorName(this.color),
      thickness: this.#g,
      methodOfCreation: this.#v
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.getNonHCMColorName(this.color)
    };
  }
  static computeTelemetryFinalData(t) {
    return {
      numberOfColors: t.get("color").size
    };
  }
  #b() {
    const t = new Hs(this.#i, 1e-3);
    this.#l = t.getOutlines(), [this.x, this.y, this.width, this.height] = this.#l.box;
    const e = new Hs(this.#i, 25e-4, 1e-3, this._uiManager.direction === "ltr");
    this.#n = e.getOutlines();
    const {
      firstPoint: s
    } = this.#l;
    this.#f = [(s[0] - this.x) / this.width, (s[1] - this.y) / this.height];
    const {
      lastPoint: i
    } = this.#n;
    this.#m = [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height];
  }
  #y({
    highlightOutlines: t,
    highlightId: e,
    clipPathId: s
  }) {
    this.#l = t;
    const i = 1.5;
    if (this.#n = t.getNewOutline(this.#g / 2 + i, 25e-4), e >= 0)
      this.#u = e, this.#s = s, this.parent.drawLayer.finalizeDraw(e, {
        bbox: t.box,
        path: {
          d: t.toSVGPath()
        }
      }), this.#p = this.parent.drawLayer.drawOutline({
        rootClass: {
          highlightOutline: !0,
          free: !0
        },
        bbox: this.#n.box,
        path: {
          d: this.#n.toSVGPath()
        }
      }, !0);
    else if (this.parent) {
      const d = this.parent.viewport.rotation;
      this.parent.drawLayer.updateProperties(this.#u, {
        bbox: pt.#x(this.#l.box, (d - this.rotation + 360) % 360),
        path: {
          d: t.toSVGPath()
        }
      }), this.parent.drawLayer.updateProperties(this.#p, {
        bbox: pt.#x(this.#n.box, d),
        path: {
          d: this.#n.toSVGPath()
        }
      });
    }
    const [n, r, a, o] = t.box;
    switch (this.rotation) {
      case 0:
        this.x = n, this.y = r, this.width = a, this.height = o;
        break;
      case 90: {
        const [d, u] = this.parentDimensions;
        this.x = r, this.y = 1 - n, this.width = a * u / d, this.height = o * d / u;
        break;
      }
      case 180:
        this.x = 1 - n, this.y = 1 - r, this.width = a, this.height = o;
        break;
      case 270: {
        const [d, u] = this.parentDimensions;
        this.x = 1 - r, this.y = n, this.width = a * u / d, this.height = o * d / u;
        break;
      }
    }
    const {
      firstPoint: l
    } = t;
    this.#f = [(l[0] - n) / a, (l[1] - r) / o];
    const {
      lastPoint: c
    } = this.#n;
    this.#m = [(c[0] - n) / a, (c[1] - r) / o];
  }
  static initialize(t, e) {
    U.initialize(t, e), pt._defaultColor ||= e.highlightColors?.values().next().value || "#fff066";
  }
  static updateDefaultParams(t, e) {
    switch (t) {
      case J.HIGHLIGHT_COLOR:
        pt._defaultColor = e;
        break;
      case J.HIGHLIGHT_THICKNESS:
        pt._defaultThickness = e;
        break;
    }
  }
  translateInPage(t, e) {
  }
  get toolbarPosition() {
    return this.#m;
  }
  get commentButtonPosition() {
    return this.#f;
  }
  updateParams(t, e) {
    switch (t) {
      case J.HIGHLIGHT_COLOR:
        this.#T(e);
        break;
      case J.HIGHLIGHT_THICKNESS:
        this.#S(e);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[J.HIGHLIGHT_COLOR, pt._defaultColor], [J.HIGHLIGHT_THICKNESS, pt._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[J.HIGHLIGHT_COLOR, this.color || pt._defaultColor], [J.HIGHLIGHT_THICKNESS, this.#g || pt._defaultThickness], [J.HIGHLIGHT_FREE, this.#d]];
  }
  onUpdatedColor() {
    this.parent?.drawLayer.updateProperties(this.#u, {
      root: {
        fill: this.color,
        "fill-opacity": this.opacity
      }
    }), this.#a?.updateColor(this.color), super.onUpdatedColor();
  }
  #T(t) {
    const e = (n, r) => {
      this.color = n, this.opacity = r, this.onUpdatedColor();
    }, s = this.color, i = this.opacity;
    this.addCommands({
      cmd: e.bind(this, t, pt._defaultOpacity),
      undo: e.bind(this, s, i),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: J.HIGHLIGHT_COLOR,
      overwriteIfSameType: !0,
      keepUndo: !0
    }), this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.getNonHCMColorName(t)
    }, !0);
  }
  #S(t) {
    const e = this.#g, s = (i) => {
      this.#g = i, this.#A(i);
    };
    this.addCommands({
      cmd: s.bind(this, t),
      undo: s.bind(this, e),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: J.INK_THICKNESS,
      overwriteIfSameType: !0,
      keepUndo: !0
    }), this._reportTelemetry({
      action: "thickness_changed",
      thickness: t
    }, !0);
  }
  get toolbarButtons() {
    return this._uiManager.highlightColors ? [["colorPicker", this.#a = new Ft({
      editor: this
    })]] : super.toolbarButtons;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(this.#I());
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t, e) {
    return super.getRect(t, e, this.#I());
  }
  onceAdded(t) {
    this.annotationElementId || this.parent.addUndoableEditor(this), t && this.div.focus();
  }
  remove() {
    this.#P(), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.#E(), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    let e = !1;
    this.parent && !t ? this.#P() : t && (this.#E(t), e = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(t), this.show(this._isVisible), e && this.select();
  }
  #A(t) {
    this.#d && (this.#y({
      highlightOutlines: this.#l.getNewOutline(t / 2)
    }), this.fixAndSetPosition(), this.setDims(this.width, this.height));
  }
  #P() {
    this.#u === null || !this.parent || (this.parent.drawLayer.remove(this.#u), this.#u = null, this.parent.drawLayer.remove(this.#p), this.#p = null);
  }
  #E(t = this.parent) {
    this.#u === null && ({
      id: this.#u,
      clipPathId: this.#s
    } = t.drawLayer.draw({
      bbox: this.#l.box,
      root: {
        viewBox: "0 0 1 1",
        fill: this.color,
        "fill-opacity": this.opacity
      },
      rootClass: {
        highlight: !0,
        free: this.#d
      },
      path: {
        d: this.#l.toSVGPath()
      }
    }, !1, !0), this.#p = t.drawLayer.drawOutline({
      rootClass: {
        highlightOutline: !0,
        free: this.#d
      },
      bbox: this.#n.box,
      path: {
        d: this.#n.toSVGPath()
      }
    }, this.#d), this.#h && (this.#h.style.clipPath = this.#s));
  }
  static #x([t, e, s, i], n) {
    switch (n) {
      case 90:
        return [1 - e - i, t, i, s];
      case 180:
        return [1 - t - s, 1 - e - i, s, i];
      case 270:
        return [e, 1 - t - s, i, s];
    }
    return [t, e, s, i];
  }
  rotate(t) {
    const {
      drawLayer: e
    } = this.parent;
    let s;
    this.#d ? (t = (t - this.rotation + 360) % 360, s = pt.#x(this.#l.box, t)) : s = pt.#x([this.x, this.y, this.width, this.height], t), e.updateProperties(this.#u, {
      bbox: s,
      root: {
        "data-main-rotation": t
      }
    }), e.updateProperties(this.#p, {
      bbox: pt.#x(this.#n.box, t),
      root: {
        "data-main-rotation": t
      }
    });
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    this.#c && (t.setAttribute("aria-label", this.#c), t.setAttribute("role", "mark")), this.#d ? t.classList.add("free") : this.div.addEventListener("keydown", this.#M.bind(this), {
      signal: this._uiManager._signal
    });
    const e = this.#h = document.createElement("div");
    return t.append(e), e.setAttribute("aria-hidden", "true"), e.className = "internal", e.style.clipPath = this.#s, this.setDims(this.width, this.height), Zi(this, this.#h, ["pointerover", "pointerleave"]), this.enableEditing(), t;
  }
  pointerover() {
    this.isSelected || this.parent?.drawLayer.updateProperties(this.#p, {
      rootClass: {
        hovered: !0
      }
    });
  }
  pointerleave() {
    this.isSelected || this.parent?.drawLayer.updateProperties(this.#p, {
      rootClass: {
        hovered: !1
      }
    });
  }
  #M(t) {
    pt._keyboardManager.exec(this, t);
  }
  _moveCaret(t) {
    switch (this.parent.unselect(this), t) {
      case 0:
      case 2:
        this.#R(!0);
        break;
      case 1:
      case 3:
        this.#R(!1);
        break;
    }
  }
  #R(t) {
    if (!this.#t)
      return;
    const e = window.getSelection();
    t ? e.setPosition(this.#t, this.#e) : e.setPosition(this.#r, this.#o);
  }
  select() {
    super.select(), this.#p && this.parent?.drawLayer.updateProperties(this.#p, {
      rootClass: {
        hovered: !1,
        selected: !0
      }
    });
  }
  unselect() {
    super.unselect(), this.#p && (this.parent?.drawLayer.updateProperties(this.#p, {
      rootClass: {
        selected: !1
      }
    }), this.#d || this.#R(!1));
  }
  get _mustFixPosition() {
    return !this.#d;
  }
  show(t = this._isVisible) {
    super.show(t), this.parent && (this.parent.drawLayer.updateProperties(this.#u, {
      rootClass: {
        hidden: !t
      }
    }), this.parent.drawLayer.updateProperties(this.#p, {
      rootClass: {
        hidden: !t
      }
    }));
  }
  #I() {
    return this.#d ? this.rotation : 0;
  }
  #B() {
    if (this.#d)
      return null;
    const [t, e] = this.pageDimensions, [s, i] = this.pageTranslation, n = this.#i, r = new Float32Array(n.length * 8);
    let a = 0;
    for (const {
      x: o,
      y: l,
      width: c,
      height: d
    } of n) {
      const u = o * t + s, f = (1 - l) * e + i;
      r[a] = r[a + 4] = u, r[a + 1] = r[a + 3] = f, r[a + 2] = r[a + 6] = u + c * t, r[a + 5] = r[a + 7] = f - d * e, a += 8;
    }
    return r;
  }
  #L(t) {
    return this.#l.serialize(t, this.#I());
  }
  static startHighlighting(t, e, {
    target: s,
    x: i,
    y: n
  }) {
    const {
      x: r,
      y: a,
      width: o,
      height: l
    } = s.getBoundingClientRect(), c = new AbortController(), d = t.combinedSignal(c), u = (f) => {
      c.abort(), this.#_(t, f);
    };
    window.addEventListener("blur", u, {
      signal: d
    }), window.addEventListener("pointerup", u, {
      signal: d
    }), window.addEventListener("pointerdown", ct, {
      capture: !0,
      passive: !1,
      signal: d
    }), window.addEventListener("contextmenu", Bt, {
      signal: d
    }), s.addEventListener("pointermove", this.#k.bind(this, t), {
      signal: d
    }), this._freeHighlight = new $s({
      x: i,
      y: n
    }, [r, a, o, l], t.scale, this._defaultThickness / 2, e, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = t.drawLayer.draw({
      bbox: [0, 0, 1, 1],
      root: {
        viewBox: "0 0 1 1",
        fill: this._defaultColor,
        "fill-opacity": this._defaultOpacity
      },
      rootClass: {
        highlight: !0,
        free: !0
      },
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    }, !0, !0);
  }
  static #k(t, e) {
    this._freeHighlight.add(e) && t.drawLayer.updateProperties(this._freeHighlightId, {
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    });
  }
  static #_(t, e) {
    this._freeHighlight.isEmpty() ? t.drawLayer.remove(this._freeHighlightId) : t.createAndAddNewEditor(e, !1, {
      highlightId: this._freeHighlightId,
      highlightOutlines: this._freeHighlight.getOutlines(),
      clipPathId: this._freeHighlightClipId,
      methodOfCreation: "main_toolbar"
    }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
  }
  static async deserialize(t, e, s) {
    let i = null;
    if (t instanceof En) {
      const {
        data: {
          quadPoints: g,
          rect: p,
          rotation: v,
          id: m,
          color: b,
          opacity: y,
          popupRef: E,
          richText: A,
          contentsObj: w,
          creationDate: S,
          modificationDate: x
        },
        parent: {
          page: {
            pageNumber: T
          }
        }
      } = t;
      i = t = {
        annotationType: G.HIGHLIGHT,
        color: Array.from(b),
        opacity: y,
        quadPoints: g,
        boxes: null,
        pageIndex: T - 1,
        rect: p.slice(0),
        rotation: v,
        annotationElementId: m,
        id: m,
        deleted: !1,
        popupRef: E,
        richText: A,
        comment: w?.str || null,
        creationDate: S,
        modificationDate: x
      };
    } else if (t instanceof ri) {
      const {
        data: {
          inkLists: g,
          rect: p,
          rotation: v,
          id: m,
          color: b,
          borderStyle: {
            rawWidth: y
          },
          popupRef: E,
          richText: A,
          contentsObj: w,
          creationDate: S,
          modificationDate: x
        },
        parent: {
          page: {
            pageNumber: T
          }
        }
      } = t;
      i = t = {
        annotationType: G.HIGHLIGHT,
        color: Array.from(b),
        thickness: y,
        inkLists: g,
        boxes: null,
        pageIndex: T - 1,
        rect: p.slice(0),
        rotation: v,
        annotationElementId: m,
        id: m,
        deleted: !1,
        popupRef: E,
        richText: A,
        comment: w?.str || null,
        creationDate: S,
        modificationDate: x
      };
    }
    const {
      color: n,
      quadPoints: r,
      inkLists: a,
      opacity: o
    } = t, l = await super.deserialize(t, e, s);
    l.color = B.makeHexColor(...n), l.opacity = o || 1, a && (l.#g = t.thickness), l._initialData = i, t.comment && l.setCommentData(t);
    const [c, d] = l.pageDimensions, [u, f] = l.pageTranslation;
    if (r) {
      const g = l.#i = [];
      for (let p = 0; p < r.length; p += 8)
        g.push({
          x: (r[p] - u) / c,
          y: 1 - (r[p + 1] - f) / d,
          width: (r[p + 2] - r[p]) / c,
          height: (r[p + 1] - r[p + 5]) / d
        });
      l.#b(), l.#E(), l.rotate(l.rotation);
    } else if (a) {
      l.#d = !0;
      const g = a[0], p = {
        x: g[0] - u,
        y: d - (g[1] - f)
      }, v = new $s(p, [0, 0, c, d], 1, l.#g / 2, !0, 1e-3);
      for (let y = 0, E = g.length; y < E; y += 2)
        p.x = g[y] - u, p.y = d - (g[y + 1] - f), v.add(p);
      const {
        id: m,
        clipPathId: b
      } = e.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: l.color,
          "fill-opacity": l._defaultOpacity
        },
        rootClass: {
          highlight: !0,
          free: !0
        },
        path: {
          d: v.toSVGPath()
        }
      }, !0, !0);
      l.#y({
        highlightOutlines: v.getOutlines(),
        highlightId: m,
        clipPathId: b
      }), l.#E(), l.rotate(l.parentRotation);
    }
    return l;
  }
  serialize(t = !1) {
    if (this.isEmpty() || t)
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const e = U._colorManager.convert(this._uiManager.getNonHCMColor(this.color)), s = super.serialize(t);
    return Object.assign(s, {
      color: e,
      opacity: this.opacity,
      thickness: this.#g,
      quadPoints: this.#B(),
      outlines: this.#L(s.rect)
    }), this.addComment(s), this.annotationElementId && !this.#F(s) ? null : (s.id = this.annotationElementId, s);
  }
  #F(t) {
    const {
      color: e
    } = this._initialData;
    return this.hasEditedComment || t.color.some((s, i) => s !== e[i]);
  }
  renderAnnotationElement(t) {
    return this.deleted ? (t.hide(), null) : (t.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    }), null);
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
}
class Tn {
  #t = /* @__PURE__ */ Object.create(null);
  updateProperty(t, e) {
    this[t] = e, this.updateSVGProperty(t, e);
  }
  updateProperties(t) {
    if (t)
      for (const [e, s] of Object.entries(t))
        e.startsWith("_") || this.updateProperty(e, s);
  }
  updateSVGProperty(t, e) {
    this.#t[t] = e;
  }
  toSVGProperties() {
    const t = this.#t;
    return this.#t = /* @__PURE__ */ Object.create(null), {
      root: t
    };
  }
  reset() {
    this.#t = /* @__PURE__ */ Object.create(null);
  }
  updateAll(t = this) {
    this.updateProperties(t);
  }
  clone() {
    it("Not implemented");
  }
}
class j extends U {
  #t = null;
  #e;
  _colorPicker = null;
  _drawId = null;
  static _currentDrawId = -1;
  static _currentParent = null;
  static #i = null;
  static #s = null;
  static #a = null;
  static #n = NaN;
  static #r = null;
  static #o = null;
  static #h = NaN;
  static _INNER_MARGIN = 3;
  constructor(t) {
    super(t), this.#e = t.mustBeCommitted || !1, this._addOutlines(t);
  }
  onUpdatedColor() {
    this._colorPicker?.update(this.color), super.onUpdatedColor();
  }
  _addOutlines(t) {
    t.drawOutlines && (this.#l(t), this.#f());
  }
  #l({
    drawOutlines: t,
    drawId: e,
    drawingOptions: s
  }) {
    this.#t = t, this._drawingOptions ||= s, this.annotationElementId || this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`), e >= 0 ? (this._drawId = e, this.parent.drawLayer.finalizeDraw(e, t.defaultProperties)) : this._drawId = this.#u(t, this.parent), this.#c(t.box);
  }
  #u(t, e) {
    const {
      id: s
    } = e.drawLayer.draw(j._mergeSVGProperties(this._drawingOptions.toSVGProperties(), t.defaultSVGProperties), !1, !1);
    return s;
  }
  static _mergeSVGProperties(t, e) {
    const s = new Set(Object.keys(t));
    for (const [i, n] of Object.entries(e))
      s.has(i) ? Object.assign(t[i], n) : t[i] = n;
    return t;
  }
  static getDefaultDrawingOptions(t) {
    it("Not implemented");
  }
  static get typesMap() {
    it("Not implemented");
  }
  static get isDrawer() {
    return !0;
  }
  static get supportMultipleDrawings() {
    return !1;
  }
  static updateDefaultParams(t, e) {
    const s = this.typesMap.get(t);
    s && this._defaultDrawingOptions.updateProperty(s, e), this._currentParent && (j.#i.updateProperty(s, e), this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  updateParams(t, e) {
    const s = this.constructor.typesMap.get(t);
    s && this._updateProperty(t, s, e);
  }
  static get defaultPropertiesToUpdate() {
    const t = [], e = this._defaultDrawingOptions;
    for (const [s, i] of this.typesMap)
      t.push([s, e[i]]);
    return t;
  }
  get propertiesToUpdate() {
    const t = [], {
      _drawingOptions: e
    } = this;
    for (const [s, i] of this.constructor.typesMap)
      t.push([s, e[i]]);
    return t;
  }
  _updateProperty(t, e, s) {
    const i = this._drawingOptions, n = i[e], r = (a) => {
      i.updateProperty(e, a);
      const o = this.#t.updateProperty(e, a);
      o && this.#c(o), this.parent?.drawLayer.updateProperties(this._drawId, i.toSVGProperties()), t === this.colorType && this.onUpdatedColor();
    };
    this.addCommands({
      cmd: r.bind(this, s),
      undo: r.bind(this, n),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: !0,
      type: t,
      overwriteIfSameType: !0,
      keepUndo: !0
    });
  }
  _onResizing() {
    this.parent?.drawLayer.updateProperties(this._drawId, j._mergeSVGProperties(this.#t.getPathResizingSVGProperties(this.#p()), {
      bbox: this.#g()
    }));
  }
  _onResized() {
    this.parent?.drawLayer.updateProperties(this._drawId, j._mergeSVGProperties(this.#t.getPathResizedSVGProperties(this.#p()), {
      bbox: this.#g()
    }));
  }
  _onTranslating(t, e) {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      bbox: this.#g()
    });
  }
  _onTranslated() {
    this.parent?.drawLayer.updateProperties(this._drawId, j._mergeSVGProperties(this.#t.getPathTranslatedSVGProperties(this.#p(), this.parentDimensions), {
      bbox: this.#g()
    }));
  }
  _onStartDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: !0
      }
    });
  }
  _onStopDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: !1
      }
    });
  }
  commit() {
    super.commit(), this.disableEditMode(), this.disableEditing();
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return !0;
  }
  onceAdded(t) {
    this.annotationElementId || this.parent.addUndoableEditor(this), this._isDraggable = !0, this.#e && (this.#e = !1, this.commit(), this.parent.setSelected(this), t && this.isOnScreen && this.div.focus());
  }
  remove() {
    this.#d(), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.#f(), this.#c(this.#t.box), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    let e = !1;
    this.parent && !t ? (this._uiManager.removeShouldRescale(this), this.#d()) : t && (this._uiManager.addShouldRescale(this), this.#f(t), e = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(t), e && this.select();
  }
  #d() {
    this._drawId === null || !this.parent || (this.parent.drawLayer.remove(this._drawId), this._drawId = null, this._drawingOptions.reset());
  }
  #f(t = this.parent) {
    if (!(this._drawId !== null && this.parent === t)) {
      if (this._drawId !== null) {
        this.parent.drawLayer.updateParent(this._drawId, t.drawLayer);
        return;
      }
      this._drawingOptions.updateAll(), this._drawId = this.#u(this.#t, t);
    }
  }
  #m([t, e, s, i]) {
    const {
      parentDimensions: [n, r],
      rotation: a
    } = this;
    switch (a) {
      case 90:
        return [e, 1 - t, s * (r / n), i * (n / r)];
      case 180:
        return [1 - t, 1 - e, s, i];
      case 270:
        return [1 - e, t, s * (r / n), i * (n / r)];
      default:
        return [t, e, s, i];
    }
  }
  #p() {
    const {
      x: t,
      y: e,
      width: s,
      height: i,
      parentDimensions: [n, r],
      rotation: a
    } = this;
    switch (a) {
      case 90:
        return [1 - e, t, s * (n / r), i * (r / n)];
      case 180:
        return [1 - t, 1 - e, s, i];
      case 270:
        return [e, 1 - t, s * (n / r), i * (r / n)];
      default:
        return [t, e, s, i];
    }
  }
  #c(t) {
    [this.x, this.y, this.width, this.height] = this.#m(t), this.div && (this.fixAndSetPosition(), this.setDims()), this._onResized();
  }
  #g() {
    const {
      x: t,
      y: e,
      width: s,
      height: i,
      rotation: n,
      parentRotation: r,
      parentDimensions: [a, o]
    } = this;
    switch ((n * 4 + r) / 90) {
      case 1:
        return [1 - e - i, t, i, s];
      case 2:
        return [1 - t - s, 1 - e - i, s, i];
      case 3:
        return [e, 1 - t - s, i, s];
      case 4:
        return [t, e - s * (a / o), i * (o / a), s * (a / o)];
      case 5:
        return [1 - e, t, s * (a / o), i * (o / a)];
      case 6:
        return [1 - t - i * (o / a), 1 - e, i * (o / a), s * (a / o)];
      case 7:
        return [e - s * (a / o), 1 - t - i * (o / a), s * (a / o), i * (o / a)];
      case 8:
        return [t - s, e - i, s, i];
      case 9:
        return [1 - e, t - s, i, s];
      case 10:
        return [1 - t, 1 - e, s, i];
      case 11:
        return [e - i, 1 - t, i, s];
      case 12:
        return [t - i * (o / a), e, i * (o / a), s * (a / o)];
      case 13:
        return [1 - e - s * (a / o), t - i * (o / a), s * (a / o), i * (o / a)];
      case 14:
        return [1 - t, 1 - e - s * (a / o), i * (o / a), s * (a / o)];
      case 15:
        return [e, 1 - t, s * (a / o), i * (o / a)];
      default:
        return [t, e, s, i];
    }
  }
  rotate() {
    this.parent && this.parent.drawLayer.updateProperties(this._drawId, j._mergeSVGProperties({
      bbox: this.#g()
    }, this.#t.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    this.parent && this.#c(this.#t.updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div)
      return this.div;
    let t, e;
    this._isCopy && (t = this.x, e = this.y);
    const s = super.render();
    s.classList.add("draw");
    const i = document.createElement("div");
    return s.append(i), i.setAttribute("aria-hidden", "true"), i.className = "internal", this.setDims(), this._uiManager.addShouldRescale(this), this.disableEditing(), this._isCopy && this._moveAfterPaste(t, e), s;
  }
  static createDrawerInstance(t, e, s, i, n) {
    it("Not implemented");
  }
  static startDrawing(t, e, s, i) {
    const {
      target: n,
      offsetX: r,
      offsetY: a,
      pointerId: o,
      pointerType: l
    } = i;
    if (j.#r && j.#r !== l)
      return;
    const {
      viewport: {
        rotation: c
      }
    } = t, {
      width: d,
      height: u
    } = n.getBoundingClientRect(), f = j.#s = new AbortController(), g = t.combinedSignal(f);
    if (j.#n ||= o, j.#r ??= l, window.addEventListener("pointerup", (p) => {
      j.#n === p.pointerId ? this._endDraw(p) : j.#o?.delete(p.pointerId);
    }, {
      signal: g
    }), window.addEventListener("pointercancel", (p) => {
      j.#n === p.pointerId ? this._currentParent.endDrawingSession() : j.#o?.delete(p.pointerId);
    }, {
      signal: g
    }), window.addEventListener("pointerdown", (p) => {
      j.#r === p.pointerType && ((j.#o ||= /* @__PURE__ */ new Set()).add(p.pointerId), j.#i.isCancellable() && (j.#i.removeLastElement(), j.#i.isEmpty() ? this._currentParent.endDrawingSession(!0) : this._endDraw(null)));
    }, {
      capture: !0,
      passive: !1,
      signal: g
    }), window.addEventListener("contextmenu", Bt, {
      signal: g
    }), n.addEventListener("pointermove", this._drawMove.bind(this), {
      signal: g
    }), n.addEventListener("touchmove", (p) => {
      p.timeStamp === j.#h && ct(p);
    }, {
      signal: g
    }), t.toggleDrawing(), e._editorUndoBar?.hide(), j.#i) {
      t.drawLayer.updateProperties(this._currentDrawId, j.#i.startNew(r, a, d, u, c));
      return;
    }
    e.updateUIForDefaultProperties(this), j.#i = this.createDrawerInstance(r, a, d, u, c), j.#a = this.getDefaultDrawingOptions(), this._currentParent = t, {
      id: this._currentDrawId
    } = t.drawLayer.draw(this._mergeSVGProperties(j.#a.toSVGProperties(), j.#i.defaultSVGProperties), !0, !1);
  }
  static _drawMove(t) {
    if (j.#h = -1, !j.#i)
      return;
    const {
      offsetX: e,
      offsetY: s,
      pointerId: i
    } = t;
    if (j.#n === i) {
      if (j.#o?.size >= 1) {
        this._endDraw(t);
        return;
      }
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, j.#i.add(e, s)), j.#h = t.timeStamp, ct(t);
    }
  }
  static _cleanup(t) {
    t && (this._currentDrawId = -1, this._currentParent = null, j.#i = null, j.#a = null, j.#r = null, j.#h = NaN), j.#s && (j.#s.abort(), j.#s = null, j.#n = NaN, j.#o = null);
  }
  static _endDraw(t) {
    const e = this._currentParent;
    if (e) {
      if (e.toggleDrawing(!0), this._cleanup(!1), t?.target === e.div && e.drawLayer.updateProperties(this._currentDrawId, j.#i.end(t.offsetX, t.offsetY)), this.supportMultipleDrawings) {
        const s = j.#i, i = this._currentDrawId, n = s.getLastElement();
        e.addCommands({
          cmd: () => {
            e.drawLayer.updateProperties(i, s.setLastElement(n));
          },
          undo: () => {
            e.drawLayer.updateProperties(i, s.removeLastElement());
          },
          mustExec: !1,
          type: J.DRAW_STEP
        });
        return;
      }
      this.endDrawing(!1);
    }
  }
  static endDrawing(t) {
    const e = this._currentParent;
    if (!e)
      return null;
    if (e.toggleDrawing(!0), e.cleanUndoStack(J.DRAW_STEP), !j.#i.isEmpty()) {
      const {
        pageDimensions: [s, i],
        scale: n
      } = e, r = e.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, !1, {
        drawId: this._currentDrawId,
        drawOutlines: j.#i.getOutlines(s * n, i * n, n, this._INNER_MARGIN),
        drawingOptions: j.#a,
        mustBeCommitted: !t
      });
      return this._cleanup(!0), r;
    }
    return e.drawLayer.remove(this._currentDrawId), this._cleanup(!0), null;
  }
  createDrawingOptions(t) {
  }
  static deserializeDraw(t, e, s, i, n, r) {
    it("Not implemented");
  }
  static async deserialize(t, e, s) {
    const {
      rawDims: {
        pageWidth: i,
        pageHeight: n,
        pageX: r,
        pageY: a
      }
    } = e.viewport, o = this.deserializeDraw(r, a, i, n, this._INNER_MARGIN, t), l = await super.deserialize(t, e, s);
    return l.createDrawingOptions(t), l.#l({
      drawOutlines: o
    }), l.#f(), l.onScaleChanging(), l.rotate(), l;
  }
  serializeDraw(t) {
    const [e, s] = this.pageTranslation, [i, n] = this.pageDimensions;
    return this.#t.serialize([e, s, i, n], t);
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getPDFRect()
    }), null;
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
}
class da {
  #t = new Float64Array(6);
  #e;
  #i;
  #s;
  #a;
  #n;
  #r = "";
  #o = 0;
  #h = new Qe();
  #l;
  #u;
  constructor(t, e, s, i, n, r) {
    this.#l = s, this.#u = i, this.#s = n, this.#a = r, [t, e] = this.#d(t, e);
    const a = this.#e = [NaN, NaN, NaN, NaN, t, e];
    this.#n = [t, e], this.#i = [{
      line: a,
      points: this.#n
    }], this.#t.set(a, 0);
  }
  updateProperty(t, e) {
    t === "stroke-width" && (this.#a = e);
  }
  #d(t, e) {
    return _._normalizePoint(t, e, this.#l, this.#u, this.#s);
  }
  isEmpty() {
    return !this.#i || this.#i.length === 0;
  }
  isCancellable() {
    return this.#n.length <= 10;
  }
  add(t, e) {
    [t, e] = this.#d(t, e);
    const [s, i, n, r] = this.#t.subarray(2, 6), a = t - n, o = e - r;
    return Math.hypot(this.#l * a, this.#u * o) <= 2 ? null : (this.#n.push(t, e), isNaN(s) ? (this.#t.set([n, r, t, e], 2), this.#e.push(NaN, NaN, NaN, NaN, t, e), {
      path: {
        d: this.toSVGPath()
      }
    }) : (isNaN(this.#t[0]) && this.#e.splice(6, 6), this.#t.set([s, i, n, r, t, e], 0), this.#e.push(..._.createBezierPoints(s, i, n, r, t, e)), {
      path: {
        d: this.toSVGPath()
      }
    }));
  }
  end(t, e) {
    const s = this.add(t, e);
    return s || (this.#n.length === 2 ? {
      path: {
        d: this.toSVGPath()
      }
    } : null);
  }
  startNew(t, e, s, i, n) {
    this.#l = s, this.#u = i, this.#s = n, [t, e] = this.#d(t, e);
    const r = this.#e = [NaN, NaN, NaN, NaN, t, e];
    this.#n = [t, e];
    const a = this.#i.at(-1);
    return a && (a.line = new Float32Array(a.line), a.points = new Float32Array(a.points)), this.#i.push({
      line: r,
      points: this.#n
    }), this.#t.set(r, 0), this.#o = 0, this.toSVGPath(), null;
  }
  getLastElement() {
    return this.#i.at(-1);
  }
  setLastElement(t) {
    return this.#i ? (this.#i.push(t), this.#e = t.line, this.#n = t.points, this.#o = 0, {
      path: {
        d: this.toSVGPath()
      }
    }) : this.#h.setLastElement(t);
  }
  removeLastElement() {
    if (!this.#i)
      return this.#h.removeLastElement();
    this.#i.pop(), this.#r = "";
    for (let t = 0, e = this.#i.length; t < e; t++) {
      const {
        line: s,
        points: i
      } = this.#i[t];
      this.#e = s, this.#n = i, this.#o = 0, this.toSVGPath();
    }
    return {
      path: {
        d: this.#r
      }
    };
  }
  toSVGPath() {
    const t = _.svgRound(this.#e[4]), e = _.svgRound(this.#e[5]);
    if (this.#n.length === 2)
      return this.#r = `${this.#r} M ${t} ${e} Z`, this.#r;
    if (this.#n.length <= 6) {
      const i = this.#r.lastIndexOf("M");
      this.#r = `${this.#r.slice(0, i)} M ${t} ${e}`, this.#o = 6;
    }
    if (this.#n.length === 4) {
      const i = _.svgRound(this.#e[10]), n = _.svgRound(this.#e[11]);
      return this.#r = `${this.#r} L ${i} ${n}`, this.#o = 12, this.#r;
    }
    const s = [];
    this.#o === 0 && (s.push(`M ${t} ${e}`), this.#o = 6);
    for (let i = this.#o, n = this.#e.length; i < n; i += 6) {
      const [r, a, o, l, c, d] = this.#e.slice(i, i + 6).map(_.svgRound);
      s.push(`C${r} ${a} ${o} ${l} ${c} ${d}`);
    }
    return this.#r += s.join(" "), this.#o = this.#e.length, this.#r;
  }
  getOutlines(t, e, s, i) {
    const n = this.#i.at(-1);
    return n.line = new Float32Array(n.line), n.points = new Float32Array(n.points), this.#h.build(this.#i, t, e, s, this.#s, this.#a, i), this.#t = null, this.#e = null, this.#i = null, this.#r = null, this.#h;
  }
  get defaultSVGProperties() {
    return {
      root: {
        viewBox: "0 0 10000 10000"
      },
      rootClass: {
        draw: !0
      },
      bbox: [0, 0, 1, 1]
    };
  }
}
class Qe extends _ {
  #t;
  #e = 0;
  #i;
  #s;
  #a;
  #n;
  #r;
  #o;
  #h;
  build(t, e, s, i, n, r, a) {
    this.#a = e, this.#n = s, this.#r = i, this.#o = n, this.#h = r, this.#i = a ?? 0, this.#s = t, this.#d();
  }
  get thickness() {
    return this.#h;
  }
  setLastElement(t) {
    return this.#s.push(t), {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    return this.#s.pop(), {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  toSVGPath() {
    const t = [];
    for (const {
      line: e
    } of this.#s) {
      if (t.push(`M${_.svgRound(e[4])} ${_.svgRound(e[5])}`), e.length === 6) {
        t.push("Z");
        continue;
      }
      if (e.length === 12 && isNaN(e[6])) {
        t.push(`L${_.svgRound(e[10])} ${_.svgRound(e[11])}`);
        continue;
      }
      for (let s = 6, i = e.length; s < i; s += 6) {
        const [n, r, a, o, l, c] = e.subarray(s, s + 6).map(_.svgRound);
        t.push(`C${n} ${r} ${a} ${o} ${l} ${c}`);
      }
    }
    return t.join("");
  }
  serialize([t, e, s, i], n) {
    const r = [], a = [], [o, l, c, d] = this.#u();
    let u, f, g, p, v, m, b, y, E;
    switch (this.#o) {
      case 0:
        E = _._rescale, u = t, f = e + i, g = s, p = -i, v = t + o * s, m = e + (1 - l - d) * i, b = t + (o + c) * s, y = e + (1 - l) * i;
        break;
      case 90:
        E = _._rescaleAndSwap, u = t, f = e, g = s, p = i, v = t + l * s, m = e + o * i, b = t + (l + d) * s, y = e + (o + c) * i;
        break;
      case 180:
        E = _._rescale, u = t + s, f = e, g = -s, p = i, v = t + (1 - o - c) * s, m = e + l * i, b = t + (1 - o) * s, y = e + (l + d) * i;
        break;
      case 270:
        E = _._rescaleAndSwap, u = t + s, f = e + i, g = -s, p = -i, v = t + (1 - l - d) * s, m = e + (1 - o - c) * i, b = t + (1 - l) * s, y = e + (1 - o) * i;
        break;
    }
    for (const {
      line: A,
      points: w
    } of this.#s)
      r.push(E(A, u, f, g, p, n ? new Array(A.length) : null)), a.push(E(w, u, f, g, p, n ? new Array(w.length) : null));
    return {
      lines: r,
      points: a,
      rect: [v, m, b, y]
    };
  }
  static deserialize(t, e, s, i, n, {
    paths: {
      lines: r,
      points: a
    },
    rotation: o,
    thickness: l
  }) {
    const c = [];
    let d, u, f, g, p;
    switch (o) {
      case 0:
        p = _._rescale, d = -t / s, u = e / i + 1, f = 1 / s, g = -1 / i;
        break;
      case 90:
        p = _._rescaleAndSwap, d = -e / i, u = -t / s, f = 1 / i, g = 1 / s;
        break;
      case 180:
        p = _._rescale, d = t / s + 1, u = -e / i, f = -1 / s, g = 1 / i;
        break;
      case 270:
        p = _._rescaleAndSwap, d = e / i + 1, u = t / s + 1, f = -1 / i, g = -1 / s;
        break;
    }
    if (!r) {
      r = [];
      for (const m of a) {
        const b = m.length;
        if (b === 2) {
          r.push(new Float32Array([NaN, NaN, NaN, NaN, m[0], m[1]]));
          continue;
        }
        if (b === 4) {
          r.push(new Float32Array([NaN, NaN, NaN, NaN, m[0], m[1], NaN, NaN, NaN, NaN, m[2], m[3]]));
          continue;
        }
        const y = new Float32Array(3 * (b - 2));
        r.push(y);
        let [E, A, w, S] = m.subarray(0, 4);
        y.set([NaN, NaN, NaN, NaN, E, A], 0);
        for (let x = 4; x < b; x += 2) {
          const T = m[x], C = m[x + 1];
          y.set(_.createBezierPoints(E, A, w, S, T, C), (x - 2) * 3), [E, A, w, S] = [w, S, T, C];
        }
      }
    }
    for (let m = 0, b = r.length; m < b; m++)
      c.push({
        line: p(r[m].map((y) => y ?? NaN), d, u, f, g),
        points: p(a[m].map((y) => y ?? NaN), d, u, f, g)
      });
    const v = new this.prototype.constructor();
    return v.build(c, s, i, 1, o, l, n), v;
  }
  #l(t = this.#h) {
    const e = this.#i + t / 2 * this.#r;
    return this.#o % 180 === 0 ? [e / this.#a, e / this.#n] : [e / this.#n, e / this.#a];
  }
  #u() {
    const [t, e, s, i] = this.#t, [n, r] = this.#l(0);
    return [t + n, e + r, s - 2 * n, i - 2 * r];
  }
  #d() {
    const t = this.#t = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
    for (const {
      line: i
    } of this.#s) {
      if (i.length <= 12) {
        for (let a = 4, o = i.length; a < o; a += 6)
          B.pointBoundingBox(i[a], i[a + 1], t);
        continue;
      }
      let n = i[4], r = i[5];
      for (let a = 6, o = i.length; a < o; a += 6) {
        const [l, c, d, u, f, g] = i.subarray(a, a + 6);
        B.bezierBoundingBox(n, r, l, c, d, u, f, g, t), n = f, r = g;
      }
    }
    const [e, s] = this.#l();
    t[0] = Ct(t[0] - e, 0, 1), t[1] = Ct(t[1] - s, 0, 1), t[2] = Ct(t[2] + e, 0, 1), t[3] = Ct(t[3] + s, 0, 1), t[2] -= t[0], t[3] -= t[1];
  }
  get box() {
    return this.#t;
  }
  updateProperty(t, e) {
    return t === "stroke-width" ? this.#f(e) : null;
  }
  #f(t) {
    const [e, s] = this.#l();
    this.#h = t;
    const [i, n] = this.#l(), [r, a] = [i - e, n - s], o = this.#t;
    return o[0] -= r, o[1] -= a, o[2] += 2 * r, o[3] += 2 * a, o;
  }
  updateParentDimensions([t, e], s) {
    const [i, n] = this.#l();
    this.#a = t, this.#n = e, this.#r = s;
    const [r, a] = this.#l(), o = r - i, l = a - n, c = this.#t;
    return c[0] -= o, c[1] -= l, c[2] += 2 * o, c[3] += 2 * l, c;
  }
  updateRotation(t) {
    return this.#e = t, {
      path: {
        transform: this.rotationTransform
      }
    };
  }
  get viewBox() {
    return this.#t.map(_.svgRound).join(" ");
  }
  get defaultProperties() {
    const [t, e] = this.#t;
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${_.svgRound(t)} ${_.svgRound(e)}`
      }
    };
  }
  get rotationTransform() {
    const [, , t, e] = this.#t;
    let s = 0, i = 0, n = 0, r = 0, a = 0, o = 0;
    switch (this.#e) {
      case 90:
        i = e / t, n = -t / e, a = t;
        break;
      case 180:
        s = -1, r = -1, a = t, o = e;
        break;
      case 270:
        i = -e / t, n = t / e, o = e;
        break;
      default:
        return "";
    }
    return `matrix(${s} ${i} ${n} ${r} ${_.svgRound(a)} ${_.svgRound(o)})`;
  }
  getPathResizingSVGProperties([t, e, s, i]) {
    const [n, r] = this.#l(), [a, o, l, c] = this.#t;
    if (Math.abs(l - n) <= _.PRECISION || Math.abs(c - r) <= _.PRECISION) {
      const p = t + s / 2 - (a + l / 2), v = e + i / 2 - (o + c / 2);
      return {
        path: {
          "transform-origin": `${_.svgRound(t)} ${_.svgRound(e)}`,
          transform: `${this.rotationTransform} translate(${p} ${v})`
        }
      };
    }
    const d = (s - 2 * n) / (l - 2 * n), u = (i - 2 * r) / (c - 2 * r), f = l / s, g = c / i;
    return {
      path: {
        "transform-origin": `${_.svgRound(a)} ${_.svgRound(o)}`,
        transform: `${this.rotationTransform} scale(${f} ${g}) translate(${_.svgRound(n)} ${_.svgRound(r)}) scale(${d} ${u}) translate(${_.svgRound(-n)} ${_.svgRound(-r)})`
      }
    };
  }
  getPathResizedSVGProperties([t, e, s, i]) {
    const [n, r] = this.#l(), a = this.#t, [o, l, c, d] = a;
    if (a[0] = t, a[1] = e, a[2] = s, a[3] = i, Math.abs(c - n) <= _.PRECISION || Math.abs(d - r) <= _.PRECISION) {
      const v = t + s / 2 - (o + c / 2), m = e + i / 2 - (l + d / 2);
      for (const {
        line: b,
        points: y
      } of this.#s)
        _._translate(b, v, m, b), _._translate(y, v, m, y);
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${_.svgRound(t)} ${_.svgRound(e)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    const u = (s - 2 * n) / (c - 2 * n), f = (i - 2 * r) / (d - 2 * r), g = -u * (o + n) + t + n, p = -f * (l + r) + e + r;
    if (u !== 1 || f !== 1 || g !== 0 || p !== 0)
      for (const {
        line: v,
        points: m
      } of this.#s)
        _._rescale(v, g, p, u, f, v), _._rescale(m, g, p, u, f, m);
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${_.svgRound(t)} ${_.svgRound(e)}`,
        transform: this.rotationTransform || null,
        d: this.toSVGPath()
      }
    };
  }
  getPathTranslatedSVGProperties([t, e], s) {
    const [i, n] = s, r = this.#t, a = t - r[0], o = e - r[1];
    if (this.#a === i && this.#n === n)
      for (const {
        line: l,
        points: c
      } of this.#s)
        _._translate(l, a, o, l), _._translate(c, a, o, c);
    else {
      const l = this.#a / i, c = this.#n / n;
      this.#a = i, this.#n = n;
      for (const {
        line: d,
        points: u
      } of this.#s)
        _._rescale(d, a, o, l, c, d), _._rescale(u, a, o, l, c, u);
      r[2] *= l, r[3] *= c;
    }
    return r[0] = t, r[1] = e, {
      root: {
        viewBox: this.viewBox
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${_.svgRound(t)} ${_.svgRound(e)}`
      }
    };
  }
  get defaultSVGProperties() {
    const t = this.#t;
    return {
      root: {
        viewBox: this.viewBox
      },
      rootClass: {
        draw: !0
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${_.svgRound(t[0])} ${_.svgRound(t[1])}`,
        transform: this.rotationTransform || null
      },
      bbox: t
    };
  }
}
class ws extends Tn {
  constructor(t) {
    super(), this._viewParameters = t, super.updateProperties({
      fill: "none",
      stroke: U._defaultLineColor,
      "stroke-opacity": 1,
      "stroke-width": 1,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-miterlimit": 10
    });
  }
  updateSVGProperty(t, e) {
    t === "stroke-width" && (e ??= this["stroke-width"], e *= this._viewParameters.realScale), super.updateSVGProperty(t, e);
  }
  clone() {
    const t = new ws(this._viewParameters);
    return t.updateAll(this), t;
  }
}
class ai extends j {
  static _type = "ink";
  static _editorType = G.INK;
  static _defaultDrawingOptions = null;
  constructor(t) {
    super({
      ...t,
      name: "inkEditor"
    }), this._willKeepAspectRatio = !0, this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(t, e) {
    U.initialize(t, e), this._defaultDrawingOptions = new ws(e.viewParameters);
  }
  static getDefaultDrawingOptions(t) {
    const e = this._defaultDrawingOptions.clone();
    return e.updateProperties(t), e;
  }
  static get supportMultipleDrawings() {
    return !0;
  }
  static get typesMap() {
    return K(this, "typesMap", /* @__PURE__ */ new Map([[J.INK_THICKNESS, "stroke-width"], [J.INK_COLOR, "stroke"], [J.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(t, e, s, i, n) {
    return new da(t, e, s, i, n, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(t, e, s, i, n, r) {
    return Qe.deserialize(t, e, s, i, n, r);
  }
  static async deserialize(t, e, s) {
    let i = null;
    if (t instanceof ri) {
      const {
        data: {
          inkLists: r,
          rect: a,
          rotation: o,
          id: l,
          color: c,
          opacity: d,
          borderStyle: {
            rawWidth: u
          },
          popupRef: f,
          richText: g,
          contentsObj: p,
          creationDate: v,
          modificationDate: m
        },
        parent: {
          page: {
            pageNumber: b
          }
        }
      } = t;
      i = t = {
        annotationType: G.INK,
        color: Array.from(c),
        thickness: u,
        opacity: d,
        paths: {
          points: r
        },
        boxes: null,
        pageIndex: b - 1,
        rect: a.slice(0),
        rotation: o,
        annotationElementId: l,
        id: l,
        deleted: !1,
        popupRef: f,
        richText: g,
        comment: p?.str || null,
        creationDate: v,
        modificationDate: m
      };
    }
    const n = await super.deserialize(t, e, s);
    return n._initialData = i, t.comment && n.setCommentData(t), n;
  }
  get toolbarButtons() {
    return this._colorPicker ||= new ze(this), [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return J.INK_COLOR;
  }
  get color() {
    return this._drawingOptions.stroke;
  }
  get opacity() {
    return this._drawingOptions["stroke-opacity"];
  }
  onScaleChanging() {
    if (!this.parent)
      return;
    super.onScaleChanging();
    const {
      _drawId: t,
      _drawingOptions: e,
      parent: s
    } = this;
    e.updateSVGProperty("stroke-width"), s.drawLayer.updateProperties(t, e.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const t = this._currentParent;
    t && (super.onScaleChangingWhenDrawing(), this._defaultDrawingOptions.updateSVGProperty("stroke-width"), t.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties()));
  }
  createDrawingOptions({
    color: t,
    thickness: e,
    opacity: s
  }) {
    this._drawingOptions = ai.getDefaultDrawingOptions({
      stroke: B.makeHexColor(...t),
      "stroke-width": e,
      "stroke-opacity": s
    });
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const {
      lines: e,
      points: s
    } = this.serializeDraw(t), {
      _drawingOptions: {
        stroke: i,
        "stroke-opacity": n,
        "stroke-width": r
      }
    } = this, a = Object.assign(super.serialize(t), {
      color: U._colorManager.convert(i),
      opacity: n,
      thickness: r,
      paths: {
        lines: e,
        points: s
      }
    });
    return this.addComment(a), t ? (a.isCopy = !0, a) : this.annotationElementId && !this.#t(a) ? null : (a.id = this.annotationElementId, a);
  }
  #t(t) {
    const {
      color: e,
      thickness: s,
      opacity: i,
      pageIndex: n
    } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || t.color.some((r, a) => r !== e[a]) || t.thickness !== s || t.opacity !== i || t.pageIndex !== n;
  }
  renderAnnotationElement(t) {
    if (this.deleted)
      return t.hide(), null;
    const {
      points: e,
      rect: s
    } = this.serializeDraw(!1);
    return t.updateEdited({
      rect: s,
      thickness: this._drawingOptions["stroke-width"],
      points: e,
      popup: this.comment
    }), null;
  }
}
class js extends Qe {
  toSVGPath() {
    let t = super.toSVGPath();
    return t.endsWith("Z") || (t += "Z"), t;
  }
}
const ls = 8, Fe = 3;
class le {
  static #t = {
    maxDim: 512,
    sigmaSFactor: 0.02,
    sigmaR: 25,
    kernelSize: 16
  };
  static #e(t, e, s, i) {
    return s -= t, i -= e, s === 0 ? i > 0 ? 0 : 4 : s === 1 ? i + 6 : 2 - i;
  }
  static #i = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
  static #s(t, e, s, i, n, r, a) {
    const o = this.#e(s, i, n, r);
    for (let l = 0; l < 8; l++) {
      const c = (-l + o - a + 16) % 8, d = this.#i[2 * c], u = this.#i[2 * c + 1];
      if (t[(s + d) * e + (i + u)] !== 0)
        return c;
    }
    return -1;
  }
  static #a(t, e, s, i, n, r, a) {
    const o = this.#e(s, i, n, r);
    for (let l = 0; l < 8; l++) {
      const c = (l + o + a + 16) % 8, d = this.#i[2 * c], u = this.#i[2 * c + 1];
      if (t[(s + d) * e + (i + u)] !== 0)
        return c;
    }
    return -1;
  }
  static #n(t, e, s, i) {
    const n = t.length, r = new Int32Array(n);
    for (let c = 0; c < n; c++)
      r[c] = t[c] <= i ? 1 : 0;
    for (let c = 1; c < s - 1; c++)
      r[c * e] = r[c * e + e - 1] = 0;
    for (let c = 0; c < e; c++)
      r[c] = r[e * s - 1 - c] = 0;
    let a = 1, o;
    const l = [];
    for (let c = 1; c < s - 1; c++) {
      o = 1;
      for (let d = 1; d < e - 1; d++) {
        const u = c * e + d, f = r[u];
        if (f === 0)
          continue;
        let g = c, p = d;
        if (f === 1 && r[u - 1] === 0)
          a += 1, p -= 1;
        else if (f >= 1 && r[u + 1] === 0)
          a += 1, p += 1, f > 1 && (o = f);
        else {
          f !== 1 && (o = Math.abs(f));
          continue;
        }
        const v = [d, c], m = p === d + 1, b = {
          isHole: m,
          points: v,
          id: a,
          parent: 0
        };
        l.push(b);
        let y;
        for (const P of l)
          if (P.id === o) {
            y = P;
            break;
          }
        y ? y.isHole ? b.parent = m ? y.parent : o : b.parent = m ? o : y.parent : b.parent = m ? o : 0;
        const E = this.#s(r, e, c, d, g, p, 0);
        if (E === -1) {
          r[u] = -a, r[u] !== 1 && (o = Math.abs(r[u]));
          continue;
        }
        let A = this.#i[2 * E], w = this.#i[2 * E + 1];
        const S = c + A, x = d + w;
        g = S, p = x;
        let T = c, C = d;
        for (; ; ) {
          const P = this.#a(r, e, T, C, g, p, 1);
          A = this.#i[2 * P], w = this.#i[2 * P + 1];
          const O = T + A, D = C + w;
          v.push(D, O);
          const k = T * e + C;
          if (r[k + 1] === 0 ? r[k] = -a : r[k] === 1 && (r[k] = a), O === c && D === d && T === S && C === x) {
            r[u] !== 1 && (o = Math.abs(r[u]));
            break;
          } else
            g = T, p = C, T = O, C = D;
        }
      }
    }
    return l;
  }
  static #r(t, e, s, i) {
    if (s - e <= 4) {
      for (let S = e; S < s - 2; S += 2)
        i.push(t[S], t[S + 1]);
      return;
    }
    const n = t[e], r = t[e + 1], a = t[s - 4] - n, o = t[s - 3] - r, l = Math.hypot(a, o), c = a / l, d = o / l, u = c * r - d * n, f = o / a, g = 1 / l, p = Math.atan(f), v = Math.cos(p), m = Math.sin(p), b = g * (Math.abs(v) + Math.abs(m)), y = g * (1 - b + b ** 2), E = Math.max(Math.atan(Math.abs(m + v) * y), Math.atan(Math.abs(m - v) * y));
    let A = 0, w = e;
    for (let S = e + 2; S < s - 2; S += 2) {
      const x = Math.abs(u - c * t[S + 1] + d * t[S]);
      x > A && (w = S, A = x);
    }
    A > (l * E) ** 2 ? (this.#r(t, e, w + 2, i), this.#r(t, w, s, i)) : i.push(n, r);
  }
  static #o(t) {
    const e = [], s = t.length;
    return this.#r(t, 0, s, e), e.push(t[s - 2], t[s - 1]), e.length <= 4 ? null : e;
  }
  static #h(t, e, s, i, n, r) {
    const a = new Float32Array(r ** 2), o = -2 * i ** 2, l = r >> 1;
    for (let p = 0; p < r; p++) {
      const v = (p - l) ** 2;
      for (let m = 0; m < r; m++)
        a[p * r + m] = Math.exp((v + (m - l) ** 2) / o);
    }
    const c = new Float32Array(256), d = -2 * n ** 2;
    for (let p = 0; p < 256; p++)
      c[p] = Math.exp(p ** 2 / d);
    const u = t.length, f = new Uint8Array(u), g = new Uint32Array(256);
    for (let p = 0; p < s; p++)
      for (let v = 0; v < e; v++) {
        const m = p * e + v, b = t[m];
        let y = 0, E = 0;
        for (let w = 0; w < r; w++) {
          const S = p + w - l;
          if (!(S < 0 || S >= s))
            for (let x = 0; x < r; x++) {
              const T = v + x - l;
              if (T < 0 || T >= e)
                continue;
              const C = t[S * e + T], P = a[w * r + x] * c[Math.abs(C - b)];
              y += C * P, E += P;
            }
        }
        const A = f[m] = Math.round(y / E);
        g[A]++;
      }
    return [f, g];
  }
  static #l(t) {
    const e = new Uint32Array(256);
    for (const s of t)
      e[s]++;
    return e;
  }
  static #u(t) {
    const e = t.length, s = new Uint8ClampedArray(e >> 2);
    let i = -1 / 0, n = 1 / 0;
    for (let a = 0, o = s.length; a < o; a++) {
      const l = s[a] = t[a << 2];
      i = Math.max(i, l), n = Math.min(n, l);
    }
    const r = 255 / (i - n);
    for (let a = 0, o = s.length; a < o; a++)
      s[a] = (s[a] - n) * r;
    return s;
  }
  static #d(t) {
    let e, s = -1 / 0, i = -1 / 0;
    const n = t.findIndex((o) => o !== 0);
    let r = n, a = n;
    for (e = n; e < 256; e++) {
      const o = t[e];
      o > s && (e - r > i && (i = e - r, a = e - 1), s = o, r = e);
    }
    for (e = a - 1; e >= 0 && !(t[e] > t[e + 1]); e--)
      ;
    return e;
  }
  static #f(t) {
    const e = t, {
      width: s,
      height: i
    } = t, {
      maxDim: n
    } = this.#t;
    let r = s, a = i;
    if (s > n || i > n) {
      let u = s, f = i, g = Math.log2(Math.max(s, i) / n);
      const p = Math.floor(g);
      g = g === p ? p - 1 : p;
      for (let m = 0; m < g; m++) {
        r = Math.ceil(u / 2), a = Math.ceil(f / 2);
        const b = new OffscreenCanvas(r, a);
        b.getContext("2d").drawImage(t, 0, 0, u, f, 0, 0, r, a), u = r, f = a, t !== e && t.close(), t = b.transferToImageBitmap();
      }
      const v = Math.min(n / r, n / a);
      r = Math.round(r * v), a = Math.round(a * v);
    }
    const l = new OffscreenCanvas(r, a).getContext("2d", {
      willReadFrequently: !0
    });
    l.fillStyle = "white", l.fillRect(0, 0, r, a), l.filter = "grayscale(1)", l.drawImage(t, 0, 0, t.width, t.height, 0, 0, r, a);
    const c = l.getImageData(0, 0, r, a).data;
    return [this.#u(c), r, a];
  }
  static extractContoursFromText(t, {
    fontFamily: e,
    fontStyle: s,
    fontWeight: i
  }, n, r, a, o) {
    let l = new OffscreenCanvas(1, 1), c = l.getContext("2d", {
      alpha: !1
    });
    const d = 200, u = c.font = `${s} ${i} ${d}px ${e}`, {
      actualBoundingBoxLeft: f,
      actualBoundingBoxRight: g,
      actualBoundingBoxAscent: p,
      actualBoundingBoxDescent: v,
      fontBoundingBoxAscent: m,
      fontBoundingBoxDescent: b,
      width: y
    } = c.measureText(t), E = 1.5, A = Math.ceil(Math.max(Math.abs(f) + Math.abs(g) || 0, y) * E), w = Math.ceil(Math.max(Math.abs(p) + Math.abs(v) || d, Math.abs(m) + Math.abs(b) || d) * E);
    l = new OffscreenCanvas(A, w), c = l.getContext("2d", {
      alpha: !0,
      willReadFrequently: !0
    }), c.font = u, c.filter = "grayscale(1)", c.fillStyle = "white", c.fillRect(0, 0, A, w), c.fillStyle = "black", c.fillText(t, A * (E - 1) / 2, w * (3 - E) / 2);
    const S = this.#u(c.getImageData(0, 0, A, w).data), x = this.#l(S), T = this.#d(x), C = this.#n(S, A, w, T);
    return this.processDrawnLines({
      lines: {
        curves: C,
        width: A,
        height: w
      },
      pageWidth: n,
      pageHeight: r,
      rotation: a,
      innerMargin: o,
      mustSmooth: !0,
      areContours: !0
    });
  }
  static process(t, e, s, i, n) {
    const [r, a, o] = this.#f(t), [l, c] = this.#h(r, a, o, Math.hypot(a, o) * this.#t.sigmaSFactor, this.#t.sigmaR, this.#t.kernelSize), d = this.#d(c), u = this.#n(l, a, o, d);
    return this.processDrawnLines({
      lines: {
        curves: u,
        width: a,
        height: o
      },
      pageWidth: e,
      pageHeight: s,
      rotation: i,
      innerMargin: n,
      mustSmooth: !0,
      areContours: !0
    });
  }
  static processDrawnLines({
    lines: t,
    pageWidth: e,
    pageHeight: s,
    rotation: i,
    innerMargin: n,
    mustSmooth: r,
    areContours: a
  }) {
    i % 180 !== 0 && ([e, s] = [s, e]);
    const {
      curves: o,
      width: l,
      height: c
    } = t, d = t.thickness ?? 0, u = [], f = Math.min(e / l, s / c), g = f / e, p = f / s, v = [];
    for (const {
      points: b
    } of o) {
      const y = r ? this.#o(b) : b;
      if (!y)
        continue;
      v.push(y);
      const E = y.length, A = new Float32Array(E), w = new Float32Array(3 * (E === 2 ? 2 : E - 2));
      if (u.push({
        line: w,
        points: A
      }), E === 2) {
        A[0] = y[0] * g, A[1] = y[1] * p, w.set([NaN, NaN, NaN, NaN, A[0], A[1]], 0);
        continue;
      }
      let [S, x, T, C] = y;
      S *= g, x *= p, T *= g, C *= p, A.set([S, x, T, C], 0), w.set([NaN, NaN, NaN, NaN, S, x], 0);
      for (let P = 4; P < E; P += 2) {
        const O = A[P] = y[P] * g, D = A[P + 1] = y[P + 1] * p;
        w.set(_.createBezierPoints(S, x, T, C, O, D), (P - 2) * 3), [S, x, T, C] = [T, C, O, D];
      }
    }
    if (u.length === 0)
      return null;
    const m = a ? new js() : new Qe();
    return m.build(u, e, s, 1, i, a ? 0 : d, n), {
      outline: m,
      newCurves: v,
      areContours: a,
      thickness: d,
      width: l,
      height: c
    };
  }
  static async compressSignature({
    outlines: t,
    areContours: e,
    thickness: s,
    width: i,
    height: n
  }) {
    let r = 1 / 0, a = -1 / 0, o = 0;
    for (const y of t) {
      o += y.length;
      for (let E = 2, A = y.length; E < A; E++) {
        const w = y[E] - y[E - 2];
        r = Math.min(r, w), a = Math.max(a, w);
      }
    }
    let l;
    r >= -128 && a <= 127 ? l = Int8Array : r >= -32768 && a <= 32767 ? l = Int16Array : l = Int32Array;
    const c = t.length, d = ls + Fe * c, u = new Uint32Array(d);
    let f = 0;
    u[f++] = d * Uint32Array.BYTES_PER_ELEMENT + (o - 2 * c) * l.BYTES_PER_ELEMENT, u[f++] = 0, u[f++] = i, u[f++] = n, u[f++] = e ? 0 : 1, u[f++] = Math.max(0, Math.floor(s ?? 0)), u[f++] = c, u[f++] = l.BYTES_PER_ELEMENT;
    for (const y of t)
      u[f++] = y.length - 2, u[f++] = y[0], u[f++] = y[1];
    const g = new CompressionStream("deflate-raw"), p = g.writable.getWriter();
    await p.ready, p.write(u);
    const v = l.prototype.constructor;
    for (const y of t) {
      const E = new v(y.length - 2);
      for (let A = 2, w = y.length; A < w; A++)
        E[A - 2] = y[A] - y[A - 2];
      p.write(E);
    }
    p.close();
    const m = await new Response(g.readable).arrayBuffer(), b = new Uint8Array(m);
    return Gi(b);
  }
  static async decompressSignature(t) {
    try {
      const e = Nn(t), {
        readable: s,
        writable: i
      } = new DecompressionStream("deflate-raw"), n = i.getWriter();
      await n.ready, n.write(e).then(async () => {
        await n.ready, await n.close();
      }).catch(() => {
      });
      let r = null, a = 0;
      for await (const y of s)
        r ||= new Uint8Array(new Uint32Array(y.buffer, 0, 4)[0]), r.set(y, a), a += y.length;
      const o = new Uint32Array(r.buffer, 0, r.length >> 2), l = o[1];
      if (l !== 0)
        throw new Error(`Invalid version: ${l}`);
      const c = o[2], d = o[3], u = o[4] === 0, f = o[5], g = o[6], p = o[7], v = [], m = (ls + Fe * g) * Uint32Array.BYTES_PER_ELEMENT;
      let b;
      switch (p) {
        case Int8Array.BYTES_PER_ELEMENT:
          b = new Int8Array(r.buffer, m);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          b = new Int16Array(r.buffer, m);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          b = new Int32Array(r.buffer, m);
          break;
      }
      a = 0;
      for (let y = 0; y < g; y++) {
        const E = o[Fe * y + ls], A = new Float32Array(E + 2);
        v.push(A);
        for (let w = 0; w < Fe - 1; w++)
          A[w] = o[Fe * y + ls + w + 1];
        for (let w = 0; w < E; w++)
          A[w + 2] = A[w] + b[a++];
      }
      return {
        areContours: u,
        thickness: f,
        outlines: v,
        width: c,
        height: d
      };
    } catch (e) {
      return z(`decompressSignature: ${e}`), null;
    }
  }
}
class oi extends Tn {
  constructor() {
    super(), super.updateProperties({
      fill: U._defaultLineColor,
      "stroke-width": 0
    });
  }
  clone() {
    const t = new oi();
    return t.updateAll(this), t;
  }
}
class li extends ws {
  constructor(t) {
    super(t), super.updateProperties({
      stroke: U._defaultLineColor,
      "stroke-width": 1
    });
  }
  clone() {
    const t = new li(this._viewParameters);
    return t.updateAll(this), t;
  }
}
class Jt extends j {
  #t = !1;
  #e = null;
  #i = null;
  #s = null;
  static _type = "signature";
  static _editorType = G.SIGNATURE;
  static _defaultDrawingOptions = null;
  constructor(t) {
    super({
      ...t,
      mustBeCommitted: !0,
      name: "signatureEditor"
    }), this._willKeepAspectRatio = !0, this.#i = t.signatureData || null, this.#e = null, this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(t, e) {
    U.initialize(t, e), this._defaultDrawingOptions = new oi(), this._defaultDrawnSignatureOptions = new li(e.viewParameters);
  }
  static getDefaultDrawingOptions(t) {
    const e = this._defaultDrawingOptions.clone();
    return e.updateProperties(t), e;
  }
  static get supportMultipleDrawings() {
    return !1;
  }
  static get typesMap() {
    return K(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return !1;
  }
  get telemetryFinalData() {
    return {
      type: "signature",
      hasDescription: !!this.#e
    };
  }
  static computeTelemetryFinalData(t) {
    const e = t.get("hasDescription");
    return {
      hasAltText: e.get(!0) ?? 0,
      hasNoAltText: e.get(!1) ?? 0
    };
  }
  get isResizable() {
    return !0;
  }
  onScaleChanging() {
    this._drawId !== null && super.onScaleChanging();
  }
  render() {
    if (this.div)
      return this.div;
    let t, e;
    const {
      _isCopy: s
    } = this;
    if (s && (this._isCopy = !1, t = this.x, e = this.y), super.render(), this._drawId === null)
      if (this.#i) {
        const {
          lines: i,
          mustSmooth: n,
          areContours: r,
          description: a,
          uuid: o,
          heightInPage: l
        } = this.#i, {
          rawDims: {
            pageWidth: c,
            pageHeight: d
          },
          rotation: u
        } = this.parent.viewport, f = le.processDrawnLines({
          lines: i,
          pageWidth: c,
          pageHeight: d,
          rotation: u,
          innerMargin: Jt._INNER_MARGIN,
          mustSmooth: n,
          areContours: r
        });
        this.addSignature(f, l, a, o);
      } else
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description: ""
        })), this.div.hidden = !0, this._uiManager.getSignature(this);
    else
      this.div.setAttribute("data-l10n-args", JSON.stringify({
        description: this.#e || ""
      }));
    return s && (this._isCopy = !0, this._moveAfterPaste(t, e)), this.div;
  }
  setUuid(t) {
    this.#s = t, this.addEditToolbar();
  }
  getUuid() {
    return this.#s;
  }
  get description() {
    return this.#e;
  }
  set description(t) {
    this.#e = t, this.div && (this.div.setAttribute("data-l10n-args", JSON.stringify({
      description: t
    })), super.addEditToolbar().then((e) => {
      e?.updateEditSignatureButton(t);
    }));
  }
  getSignaturePreview() {
    const {
      newCurves: t,
      areContours: e,
      thickness: s,
      width: i,
      height: n
    } = this.#i, r = Math.max(i, n), a = le.processDrawnLines({
      lines: {
        curves: t.map((o) => ({
          points: o
        })),
        thickness: s,
        width: i,
        height: n
      },
      pageWidth: r,
      pageHeight: r,
      rotation: 0,
      innerMargin: 0,
      mustSmooth: !1,
      areContours: e
    });
    return {
      areContours: e,
      outline: a.outline
    };
  }
  get toolbarButtons() {
    return this._uiManager.signatureManager ? [["editSignature", this._uiManager.signatureManager]] : super.toolbarButtons;
  }
  addSignature(t, e, s, i) {
    const {
      x: n,
      y: r
    } = this, {
      outline: a
    } = this.#i = t;
    this.#t = a instanceof js, this.description = s;
    let o;
    this.#t ? o = Jt.getDefaultDrawingOptions() : (o = Jt._defaultDrawnSignatureOptions.clone(), o.updateProperties({
      "stroke-width": a.thickness
    })), this._addOutlines({
      drawOutlines: a,
      drawingOptions: o
    });
    const [, l] = this.pageDimensions;
    let c = e / l;
    c = c >= 1 ? 0.5 : c, this.width *= c / this.height, this.width >= 1 && (c *= 0.9 / this.width, this.width = 0.9), this.height = c, this.setDims(), this.x = n, this.y = r, this.center(), this._onResized(), this.onScaleChanging(), this.rotate(), this._uiManager.addToAnnotationStorage(this), this.setUuid(i), this._reportTelemetry({
      action: "pdfjs.signature.inserted",
      data: {
        hasBeenSaved: !!i,
        hasDescription: !!s
      }
    }), this.div.hidden = !1;
  }
  getFromImage(t) {
    const {
      rawDims: {
        pageWidth: e,
        pageHeight: s
      },
      rotation: i
    } = this.parent.viewport;
    return le.process(t, e, s, i, Jt._INNER_MARGIN);
  }
  getFromText(t, e) {
    const {
      rawDims: {
        pageWidth: s,
        pageHeight: i
      },
      rotation: n
    } = this.parent.viewport;
    return le.extractContoursFromText(t, e, s, i, n, Jt._INNER_MARGIN);
  }
  getDrawnSignature(t) {
    const {
      rawDims: {
        pageWidth: e,
        pageHeight: s
      },
      rotation: i
    } = this.parent.viewport;
    return le.processDrawnLines({
      lines: t,
      pageWidth: e,
      pageHeight: s,
      rotation: i,
      innerMargin: Jt._INNER_MARGIN,
      mustSmooth: !1,
      areContours: !1
    });
  }
  createDrawingOptions({
    areContours: t,
    thickness: e
  }) {
    t ? this._drawingOptions = Jt.getDefaultDrawingOptions() : (this._drawingOptions = Jt._defaultDrawnSignatureOptions.clone(), this._drawingOptions.updateProperties({
      "stroke-width": e
    }));
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    const {
      lines: e,
      points: s
    } = this.serializeDraw(t), {
      _drawingOptions: {
        "stroke-width": i
      }
    } = this, n = Object.assign(super.serialize(t), {
      isSignature: !0,
      areContours: this.#t,
      color: [0, 0, 0],
      thickness: this.#t ? 0 : i
    });
    return this.addComment(n), t ? (n.paths = {
      lines: e,
      points: s
    }, n.uuid = this.#s, n.isCopy = !0) : n.lines = e, this.#e && (n.accessibilityData = {
      type: "Figure",
      alt: this.#e
    }), n;
  }
  static deserializeDraw(t, e, s, i, n, r) {
    return r.areContours ? js.deserialize(t, e, s, i, n, r) : Qe.deserialize(t, e, s, i, n, r);
  }
  static async deserialize(t, e, s) {
    const i = await super.deserialize(t, e, s);
    return i.#t = t.areContours, i.description = t.accessibilityData?.alt || "", i.#s = t.uuid, i;
  }
}
class ua extends U {
  #t = null;
  #e = null;
  #i = null;
  #s = null;
  #a = null;
  #n = "";
  #r = null;
  #o = !1;
  #h = null;
  #l = !1;
  #u = !1;
  static _type = "stamp";
  static _editorType = G.STAMP;
  constructor(t) {
    super({
      ...t,
      name: "stampEditor"
    }), this.#s = t.bitmapUrl, this.#a = t.bitmapFile, this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(t, e) {
    U.initialize(t, e);
  }
  static isHandlingMimeForPasting(t) {
    return us.includes(t);
  }
  static paste(t, e) {
    e.pasteEditor({
      mode: G.STAMP
    }, {
      bitmapFile: t.getAsFile()
    });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
  }
  get telemetryFinalData() {
    return {
      type: "stamp",
      hasAltText: !!this.altTextData?.altText
    };
  }
  static computeTelemetryFinalData(t) {
    const e = t.get("hasAltText");
    return {
      hasAltText: e.get(!0) ?? 0,
      hasNoAltText: e.get(!1) ?? 0
    };
  }
  #d(t, e = !1) {
    if (!t) {
      this.remove();
      return;
    }
    this.#t = t.bitmap, e || (this.#e = t.id, this.#l = t.isSvg), t.file && (this.#n = t.file.name), this.#p();
  }
  #f() {
    if (this.#i = null, this._uiManager.enableWaiting(!1), !!this.#r) {
      if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#t) {
        this.addEditToolbar().then(() => {
          this._editToolbar.hide(), this._uiManager.editAltText(this, !0);
        });
        return;
      }
      if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#t) {
        this._reportTelemetry({
          action: "pdfjs.image.image_added",
          data: {
            alt_text_modal: !1,
            alt_text_type: "empty"
          }
        });
        try {
          this.mlGuessAltText();
        } catch {
        }
      }
      this.div.focus();
    }
  }
  async mlGuessAltText(t = null, e = !0) {
    if (this.hasAltTextData())
      return null;
    const {
      mlManager: s
    } = this._uiManager;
    if (!s)
      throw new Error("No ML.");
    if (!await s.isEnabledFor("altText"))
      throw new Error("ML isn't enabled for alt text.");
    const {
      data: i,
      width: n,
      height: r
    } = t || this.copyCanvas(null, null, !0).imageData, a = await s.guess({
      name: "altText",
      request: {
        data: i,
        width: n,
        height: r,
        channels: i.length / (n * r)
      }
    });
    if (!a)
      throw new Error("No response from the AI service.");
    if (a.error)
      throw new Error("Error from the AI service.");
    if (a.cancel)
      return null;
    if (!a.output)
      throw new Error("No valid response from the AI service.");
    const o = a.output;
    return await this.setGuessedAltText(o), e && !this.hasAltTextData() && (this.altTextData = {
      alt: o,
      decorative: !1
    }), o;
  }
  #m() {
    if (this.#e) {
      this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(this.#e).then((s) => this.#d(s, !0)).finally(() => this.#f());
      return;
    }
    if (this.#s) {
      const s = this.#s;
      this.#s = null, this._uiManager.enableWaiting(!0), this.#i = this._uiManager.imageManager.getFromUrl(s).then((i) => this.#d(i)).finally(() => this.#f());
      return;
    }
    if (this.#a) {
      const s = this.#a;
      this.#a = null, this._uiManager.enableWaiting(!0), this.#i = this._uiManager.imageManager.getFromFile(s).then((i) => this.#d(i)).finally(() => this.#f());
      return;
    }
    const t = document.createElement("input");
    t.type = "file", t.accept = us.join(",");
    const e = this._uiManager._signal;
    this.#i = new Promise((s) => {
      t.addEventListener("change", async () => {
        if (!t.files || t.files.length === 0)
          this.remove();
        else {
          this._uiManager.enableWaiting(!0);
          const i = await this._uiManager.imageManager.getFromFile(t.files[0]);
          this._reportTelemetry({
            action: "pdfjs.image.image_selected",
            data: {
              alt_text_modal: this._uiManager.useNewAltTextFlow
            }
          }), this.#d(i);
        }
        s();
      }, {
        signal: e
      }), t.addEventListener("cancel", () => {
        this.remove(), s();
      }, {
        signal: e
      });
    }).finally(() => this.#f()), t.click();
  }
  remove() {
    this.#e && (this.#t = null, this._uiManager.imageManager.deleteId(this.#e), this.#r?.remove(), this.#r = null, this.#h && (clearTimeout(this.#h), this.#h = null)), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      this.#e && this.#m();
      return;
    }
    super.rebuild(), this.div !== null && (this.#e && this.#r === null && this.#m(), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded(t) {
    this._isDraggable = !0, t && this.div.focus();
  }
  isEmpty() {
    return !(this.#i || this.#t || this.#s || this.#a || this.#e || this.#o);
  }
  get toolbarButtons() {
    return [["altText", this.createAltText()]];
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, e;
    return this._isCopy && (t = this.x, e = this.y), super.render(), this.div.hidden = !0, this.createAltText(), this.#o || (this.#t ? this.#p() : this.#m()), this._isCopy && this._moveAfterPaste(t, e), this._uiManager.addShouldRescale(this), this.div;
  }
  setCanvas(t, e) {
    const {
      id: s,
      bitmap: i
    } = this._uiManager.imageManager.getFromCanvas(t, e);
    e.remove(), s && this._uiManager.imageManager.isValidId(s) && (this.#e = s, i && (this.#t = i), this.#o = !1, this.#p());
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent)
      return;
    this.#h !== null && clearTimeout(this.#h);
    const t = 200;
    this.#h = setTimeout(() => {
      this.#h = null, this.#g();
    }, t);
  }
  #p() {
    const {
      div: t
    } = this;
    let {
      width: e,
      height: s
    } = this.#t;
    const [i, n] = this.pageDimensions, r = 0.75;
    if (this.width)
      e = this.width * i, s = this.height * n;
    else if (e > r * i || s > r * n) {
      const o = Math.min(r * i / e, r * n / s);
      e *= o, s *= o;
    }
    this._uiManager.enableWaiting(!1);
    const a = this.#r = document.createElement("canvas");
    a.setAttribute("role", "img"), this.addContainer(a), this.width = e / i, this.height = s / n, this.setDims(), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) && (t.hidden = !1), this.#g(), this.#u || (this.parent.addUndoableEditor(this), this.#u = !0), this._reportTelemetry({
      action: "inserted_image"
    }), this.#n && this.div.setAttribute("aria-description", this.#n), this.annotationElementId || this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
  }
  copyCanvas(t, e, s = !1) {
    t || (t = 224);
    const {
      width: i,
      height: n
    } = this.#t, r = new Gt();
    let a = this.#t, o = i, l = n, c = null;
    if (e) {
      if (i > e || n > e) {
        const w = Math.min(e / i, e / n);
        o = Math.floor(i * w), l = Math.floor(n * w);
      }
      c = document.createElement("canvas");
      const u = c.width = Math.ceil(o * r.sx), f = c.height = Math.ceil(l * r.sy);
      this.#l || (a = this.#c(u, f));
      const g = c.getContext("2d");
      g.filter = this._uiManager.hcmFilter;
      let p = "white", v = "#cfcfd8";
      this._uiManager.hcmFilter !== "none" ? v = "black" : Un.isDarkMode && (p = "#8f8f9d", v = "#42414d");
      const m = 15, b = m * r.sx, y = m * r.sy, E = new OffscreenCanvas(b * 2, y * 2), A = E.getContext("2d");
      A.fillStyle = p, A.fillRect(0, 0, b * 2, y * 2), A.fillStyle = v, A.fillRect(0, 0, b, y), A.fillRect(b, y, b, y), g.fillStyle = g.createPattern(E, "repeat"), g.fillRect(0, 0, u, f), g.drawImage(a, 0, 0, a.width, a.height, 0, 0, u, f);
    }
    let d = null;
    if (s) {
      let u, f;
      if (r.symmetric && a.width < t && a.height < t)
        u = a.width, f = a.height;
      else if (a = this.#t, i > t || n > t) {
        const v = Math.min(t / i, t / n);
        u = Math.floor(i * v), f = Math.floor(n * v), this.#l || (a = this.#c(u, f));
      }
      const p = new OffscreenCanvas(u, f).getContext("2d", {
        willReadFrequently: !0
      });
      p.drawImage(a, 0, 0, a.width, a.height, 0, 0, u, f), d = {
        width: u,
        height: f,
        data: p.getImageData(0, 0, u, f).data
      };
    }
    return {
      canvas: c,
      width: o,
      height: l,
      imageData: d
    };
  }
  #c(t, e) {
    const {
      width: s,
      height: i
    } = this.#t;
    let n = s, r = i, a = this.#t;
    for (; n > 2 * t || r > 2 * e; ) {
      const o = n, l = r;
      n > 2 * t && (n = n >= 16384 ? Math.floor(n / 2) - 1 : Math.ceil(n / 2)), r > 2 * e && (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2));
      const c = new OffscreenCanvas(n, r);
      c.getContext("2d").drawImage(a, 0, 0, o, l, 0, 0, n, r), a = c.transferToImageBitmap();
    }
    return a;
  }
  #g() {
    const [t, e] = this.parentDimensions, {
      width: s,
      height: i
    } = this, n = new Gt(), r = Math.ceil(s * t * n.sx), a = Math.ceil(i * e * n.sy), o = this.#r;
    if (!o || o.width === r && o.height === a)
      return;
    o.width = r, o.height = a;
    const l = this.#l ? this.#t : this.#c(r, a), c = o.getContext("2d");
    c.filter = this._uiManager.hcmFilter, c.drawImage(l, 0, 0, l.width, l.height, 0, 0, r, a);
  }
  #v(t) {
    if (t) {
      if (this.#l) {
        const i = this._uiManager.imageManager.getSvgUrl(this.#e);
        if (i)
          return i;
      }
      const e = document.createElement("canvas");
      return {
        width: e.width,
        height: e.height
      } = this.#t, e.getContext("2d").drawImage(this.#t, 0, 0), e.toDataURL();
    }
    if (this.#l) {
      const [e, s] = this.pageDimensions, i = Math.round(this.width * e * fe.PDF_TO_CSS_UNITS), n = Math.round(this.height * s * fe.PDF_TO_CSS_UNITS), r = new OffscreenCanvas(i, n);
      return r.getContext("2d").drawImage(this.#t, 0, 0, this.#t.width, this.#t.height, 0, 0, i, n), r.transferToImageBitmap();
    }
    return structuredClone(this.#t);
  }
  static async deserialize(t, e, s) {
    let i = null, n = !1;
    if (t instanceof Sn) {
      const {
        data: {
          rect: p,
          rotation: v,
          id: m,
          structParent: b,
          popupRef: y,
          richText: E,
          contentsObj: A,
          creationDate: w,
          modificationDate: S
        },
        container: x,
        parent: {
          page: {
            pageNumber: T
          }
        },
        canvas: C
      } = t;
      let P, O;
      C ? (delete t.canvas, {
        id: P,
        bitmap: O
      } = s.imageManager.getFromCanvas(x.id, C), C.remove()) : (n = !0, t._hasNoCanvas = !0);
      const D = (await e._structTree.getAriaAttributes(`${Ws}${m}`))?.get("aria-label") || "";
      i = t = {
        annotationType: G.STAMP,
        bitmapId: P,
        bitmap: O,
        pageIndex: T - 1,
        rect: p.slice(0),
        rotation: v,
        annotationElementId: m,
        id: m,
        deleted: !1,
        accessibilityData: {
          decorative: !1,
          altText: D
        },
        isSvg: !1,
        structParent: b,
        popupRef: y,
        richText: E,
        comment: A?.str || null,
        creationDate: w,
        modificationDate: S
      };
    }
    const r = await super.deserialize(t, e, s), {
      rect: a,
      bitmap: o,
      bitmapUrl: l,
      bitmapId: c,
      isSvg: d,
      accessibilityData: u
    } = t;
    n ? (s.addMissingCanvas(t.id, r), r.#o = !0) : c && s.imageManager.isValidId(c) ? (r.#e = c, o && (r.#t = o)) : r.#s = l, r.#l = d;
    const [f, g] = r.pageDimensions;
    return r.width = (a[2] - a[0]) / f, r.height = (a[3] - a[1]) / g, u && (r.altTextData = u), r._initialData = i, t.comment && r.setCommentData(t), r.#u = !!i, r;
  }
  serialize(t = !1, e = null) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = Object.assign(super.serialize(t), {
      bitmapId: this.#e,
      isSvg: this.#l
    });
    if (this.addComment(s), t)
      return s.bitmapUrl = this.#v(!0), s.accessibilityData = this.serializeAltText(!0), s.isCopy = !0, s;
    const {
      decorative: i,
      altText: n
    } = this.serializeAltText(!1);
    if (!i && n && (s.accessibilityData = {
      type: "Figure",
      alt: n
    }), this.annotationElementId) {
      const a = this.#b(s);
      return a.isSame ? null : (a.isSameAltText ? delete s.accessibilityData : s.accessibilityData.structParent = this._initialData.structParent ?? -1, s.id = this.annotationElementId, delete s.bitmapId, s);
    }
    if (e === null)
      return s;
    e.stamps ||= /* @__PURE__ */ new Map();
    const r = this.#l ? (s.rect[2] - s.rect[0]) * (s.rect[3] - s.rect[1]) : null;
    if (!e.stamps.has(this.#e))
      e.stamps.set(this.#e, {
        area: r,
        serialized: s
      }), s.bitmap = this.#v(!1);
    else if (this.#l) {
      const a = e.stamps.get(this.#e);
      r > a.area && (a.area = r, a.serialized.bitmap.close(), a.serialized.bitmap = this.#v(!1));
    }
    return s;
  }
  #b(t) {
    const {
      pageIndex: e,
      accessibilityData: {
        altText: s
      }
    } = this._initialData, i = t.pageIndex === e, n = (t.accessibilityData?.alt || "") === s;
    return {
      isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && i && n,
      isSameAltText: n
    };
  }
  renderAnnotationElement(t) {
    return this.deleted ? (t.hide(), null) : (t.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    }), null);
  }
}
class Zt {
  #t;
  #e = !1;
  #i = null;
  #s = null;
  #a = null;
  #n = /* @__PURE__ */ new Map();
  #r = !1;
  #o = !1;
  #h = !1;
  #l = null;
  #u = null;
  #d = null;
  #f = null;
  #m = null;
  #p = -1;
  #c;
  static _initialized = !1;
  static #g = new Map([yt, ai, ua, pt, Jt].map((t) => [t._editorType, t]));
  constructor({
    uiManager: t,
    pageIndex: e,
    div: s,
    structTreeLayer: i,
    accessibilityManager: n,
    annotationLayer: r,
    drawLayer: a,
    textLayer: o,
    viewport: l,
    l10n: c
  }) {
    const d = [...Zt.#g.values()];
    if (!Zt._initialized) {
      Zt._initialized = !0;
      for (const u of d)
        u.initialize(c, t);
    }
    t.registerEditorTypes(d), this.#c = t, this.pageIndex = e, this.div = s, this.#t = n, this.#i = r, this.viewport = l, this.#d = o, this.drawLayer = a, this._structTree = i, this.#c.addLayer(this);
  }
  get isEmpty() {
    return this.#n.size === 0;
  }
  get isInvisible() {
    return this.isEmpty && this.#c.getMode() === G.NONE;
  }
  updateToolbar(t) {
    this.#c.updateToolbar(t);
  }
  updateMode(t = this.#c.getMode()) {
    switch (this.#A(), t) {
      case G.NONE:
        this.div.classList.toggle("nonEditing", !0), this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case G.INK:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
        break;
      case G.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: e
    } = this.div;
    if (e.toggle("nonEditing", !1), t === G.POPUP)
      e.toggle("commentEditing", !0);
    else {
      e.toggle("commentEditing", !1);
      for (const s of Zt.#g.values())
        e.toggle(`${s._type}Editing`, t === s._editorType);
    }
    this.div.hidden = !1;
  }
  hasTextLayer(t) {
    return t === this.#d?.div;
  }
  setEditingState(t) {
    this.#c.setEditingState(t);
  }
  addCommands(t) {
    this.#c.addCommands(t);
  }
  cleanUndoStack(t) {
    this.#c.cleanUndoStack(t);
  }
  toggleDrawing(t = !1) {
    this.div.classList.toggle("drawing", !t);
  }
  togglePointerEvents(t = !1) {
    this.div.classList.toggle("disabled", !t);
  }
  toggleAnnotationLayerPointerEvents(t = !1) {
    this.#i?.div.classList.toggle("disabled", !t);
  }
  get #v() {
    return this.#n.size !== 0 ? this.#n.values() : this.#c.getEditors(this.pageIndex);
  }
  async enable() {
    this.#h = !0, this.div.tabIndex = 0, this.togglePointerEvents(!0), this.div.classList.toggle("nonEditing", !1), this.#m?.abort(), this.#m = null;
    const t = /* @__PURE__ */ new Set();
    for (const s of this.#v)
      s.enableEditing(), s.show(!0), s.annotationElementId && (this.#c.removeChangedExistingAnnotation(s), t.add(s.annotationElementId));
    const e = this.#i;
    if (e)
      for (const s of e.getEditableAnnotations()) {
        if (s.hide(), this.#c.isDeletedAnnotationElement(s.data.id) || t.has(s.data.id))
          continue;
        const i = await this.deserialize(s);
        i && (this.addOrRebuild(i), i.enableEditing());
      }
    this.#h = !1, this.#c._eventBus.dispatch("editorsrendered", {
      source: this,
      pageNumber: this.pageIndex + 1
    });
  }
  disable() {
    if (this.#o = !0, this.div.tabIndex = -1, this.togglePointerEvents(!1), this.div.classList.toggle("nonEditing", !0), this.#d && !this.#m) {
      this.#m = new AbortController();
      const s = this.#c.combinedSignal(this.#m);
      this.#d.div.addEventListener("pointerdown", (i) => {
        const {
          clientX: r,
          clientY: a,
          timeStamp: o
        } = i, l = this.#p;
        if (o - l > 500) {
          this.#p = o;
          return;
        }
        this.#p = -1;
        const {
          classList: c
        } = this.div;
        c.toggle("getElements", !0);
        const d = document.elementsFromPoint(r, a);
        if (c.toggle("getElements", !1), !this.div.contains(d[0]))
          return;
        let u;
        const f = new RegExp(`^${He}[0-9]+$`);
        for (const p of d)
          if (f.test(p.id)) {
            u = p.id;
            break;
          }
        if (!u)
          return;
        const g = this.#n.get(u);
        g?.annotationElementId === null && (i.stopPropagation(), i.preventDefault(), g.dblclick(i));
      }, {
        signal: s,
        capture: !0
      });
    }
    const t = this.#i;
    if (t) {
      const s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
      for (const r of this.#v) {
        if (r.disableEditing(), !r.annotationElementId) {
          r.updateFakeAnnotationElement(t);
          continue;
        }
        if (r.serialize() !== null) {
          s.set(r.annotationElementId, r);
          continue;
        } else
          i.set(r.annotationElementId, r);
        this.getEditableAnnotation(r.annotationElementId)?.show(), r.remove();
      }
      const n = t.getEditableAnnotations();
      for (const r of n) {
        const {
          id: a
        } = r.data;
        if (this.#c.isDeletedAnnotationElement(a)) {
          r.updateEdited({
            deleted: !0
          });
          continue;
        }
        let o = i.get(a);
        if (o) {
          o.resetAnnotationElement(r), o.show(!1), r.show();
          continue;
        }
        o = s.get(a), o && (this.#c.addChangedExistingAnnotation(o), o.renderAnnotationElement(r) && o.show(!1)), r.show();
      }
    }
    this.#A(), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: e
    } = this.div;
    for (const s of Zt.#g.values())
      e.remove(`${s._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), this.#o = !1;
  }
  getEditableAnnotation(t) {
    return this.#i?.getEditableAnnotation(t) || null;
  }
  setActiveEditor(t) {
    this.#c.getActive() !== t && this.#c.setActiveEditor(t);
  }
  enableTextSelection() {
    if (this.div.tabIndex = -1, this.#d?.div && !this.#f) {
      this.#f = new AbortController();
      const t = this.#c.combinedSignal(this.#f);
      this.#d.div.addEventListener("pointerdown", this.#b.bind(this), {
        signal: t
      }), this.#d.div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    this.div.tabIndex = 0, this.#d?.div && this.#f && (this.#f.abort(), this.#f = null, this.#d.div.classList.remove("highlighting"));
  }
  #b(t) {
    this.#c.unselectAll();
    const {
      target: e
    } = t;
    if (e === this.#d.div || (e.getAttribute("role") === "img" || e.classList.contains("endOfContent")) && this.#d.div.contains(e)) {
      const {
        isMac: s
      } = wt.platform;
      if (t.button !== 0 || t.ctrlKey && s)
        return;
      this.#c.showAllEditors("highlight", !0, !0), this.#d.div.classList.add("free"), this.toggleDrawing(), pt.startHighlighting(this, this.#c.direction === "ltr", {
        target: this.#d.div,
        x: t.x,
        y: t.y
      }), this.#d.div.addEventListener("pointerup", () => {
        this.#d.div.classList.remove("free"), this.toggleDrawing(!0);
      }, {
        once: !0,
        signal: this.#c._signal
      }), t.preventDefault();
    }
  }
  enableClick() {
    if (this.#s)
      return;
    this.#s = new AbortController();
    const t = this.#c.combinedSignal(this.#s);
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal: t
    });
    const e = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", e, {
      signal: t
    }), this.div.addEventListener("pointercancel", e, {
      signal: t
    });
  }
  disableClick() {
    this.#s?.abort(), this.#s = null;
  }
  attach(t) {
    this.#n.set(t.id, t);
    const {
      annotationElementId: e
    } = t;
    e && this.#c.isDeletedAnnotationElement(e) && this.#c.removeDeletedAnnotationElement(t);
  }
  detach(t) {
    this.#n.delete(t.id), this.#t?.removePointerInTextLayer(t.contentDiv), !this.#o && t.annotationElementId && this.#c.addDeletedAnnotationElement(t);
  }
  remove(t) {
    this.detach(t), this.#c.removeEditor(t), t.div.remove(), t.isAttachedToDOM = !1;
  }
  changeParent(t) {
    t.parent !== this && (t.parent && t.annotationElementId && (this.#c.addDeletedAnnotationElement(t.annotationElementId), U.deleteAnnotationElement(t), t.annotationElementId = null), this.attach(t), t.parent?.detach(t), t.setParent(this), t.div && t.isAttachedToDOM && (t.div.remove(), this.div.append(t.div)));
  }
  add(t) {
    if (!(t.parent === this && t.isAttachedToDOM)) {
      if (this.changeParent(t), this.#c.addEditor(t), this.attach(t), !t.isAttachedToDOM) {
        const e = t.render();
        this.div.append(e), t.isAttachedToDOM = !0;
      }
      t.fixAndSetPosition(), t.onceAdded(!this.#h), this.#c.addToAnnotationStorage(t), t._reportTelemetry(t.telemetryInitialData);
    }
  }
  moveEditorInDOM(t) {
    if (!t.isAttachedToDOM)
      return;
    const {
      activeElement: e
    } = document;
    t.div.contains(e) && !this.#a && (t._focusEventsAllowed = !1, this.#a = setTimeout(() => {
      this.#a = null, t.div.contains(document.activeElement) ? t._focusEventsAllowed = !0 : (t.div.addEventListener("focusin", () => {
        t._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: this.#c._signal
      }), e.focus());
    }, 0)), t._structTreeParentId = this.#t?.moveElementInDOM(this.div, t.div, t.contentDiv, !0);
  }
  addOrRebuild(t) {
    t.needsToBeRebuilt() ? (t.parent ||= this, t.rebuild(), t.show()) : this.add(t);
  }
  addUndoableEditor(t) {
    const e = () => t._uiManager.rebuild(t), s = () => {
      t.remove();
    };
    this.addCommands({
      cmd: e,
      undo: s,
      mustExec: !1
    });
  }
  getEditorByUID(t) {
    for (const e of this.#n.values())
      if (e.uid === t)
        return e;
    return null;
  }
  getNextId() {
    return this.#c.getId();
  }
  get #y() {
    return Zt.#g.get(this.#c.getMode());
  }
  combinedSignal(t) {
    return this.#c.combinedSignal(t);
  }
  #T(t) {
    const e = this.#y;
    return e ? new e.prototype.constructor(t) : null;
  }
  canCreateNewEmptyEditor() {
    return this.#y?.canCreateNewEmptyEditor();
  }
  async pasteEditor(t, e) {
    this.updateToolbar(t), await this.#c.updateMode(t.mode);
    const {
      offsetX: s,
      offsetY: i
    } = this.#S(), n = this.getNextId(), r = this.#T({
      parent: this,
      id: n,
      x: s,
      y: i,
      uiManager: this.#c,
      isCentered: !0,
      ...e
    });
    r && this.add(r);
  }
  async deserialize(t) {
    return await Zt.#g.get(t.annotationType ?? t.annotationEditorType)?.deserialize(t, this, this.#c) || null;
  }
  createAndAddNewEditor(t, e, s = {}) {
    const i = this.getNextId(), n = this.#T({
      parent: this,
      id: i,
      x: t.offsetX,
      y: t.offsetY,
      uiManager: this.#c,
      isCentered: e,
      ...s
    });
    return n && this.add(n), n;
  }
  get boundingClientRect() {
    return this.div.getBoundingClientRect();
  }
  #S() {
    const {
      x: t,
      y: e,
      width: s,
      height: i
    } = this.boundingClientRect, n = Math.max(0, t), r = Math.max(0, e), a = Math.min(window.innerWidth, t + s), o = Math.min(window.innerHeight, e + i), l = (n + a) / 2 - t, c = (r + o) / 2 - e, [d, u] = this.viewport.rotation % 180 === 0 ? [l, c] : [c, l];
    return {
      offsetX: d,
      offsetY: u
    };
  }
  addNewEditor(t = {}) {
    this.createAndAddNewEditor(this.#S(), !0, t);
  }
  setSelected(t) {
    this.#c.setSelected(t);
  }
  toggleSelected(t) {
    this.#c.toggleSelected(t);
  }
  unselect(t) {
    this.#c.unselect(t);
  }
  pointerup(t) {
    const {
      isMac: e
    } = wt.platform;
    if (t.button !== 0 || t.ctrlKey && e || t.target !== this.div || !this.#r || (this.#r = !1, this.#y?.isDrawer && this.#y.supportMultipleDrawings))
      return;
    if (!this.#e) {
      this.#e = !0;
      return;
    }
    const s = this.#c.getMode();
    if (s === G.STAMP || s === G.SIGNATURE) {
      this.#c.unselectAll();
      return;
    }
    this.createAndAddNewEditor(t, !1);
  }
  pointerdown(t) {
    if (this.#c.getMode() === G.HIGHLIGHT && this.enableTextSelection(), this.#r) {
      this.#r = !1;
      return;
    }
    const {
      isMac: e
    } = wt.platform;
    if (t.button !== 0 || t.ctrlKey && e || t.target !== this.div)
      return;
    if (this.#r = !0, this.#y?.isDrawer) {
      this.startDrawingSession(t);
      return;
    }
    const s = this.#c.getActive();
    this.#e = !s || s.isEmpty();
  }
  startDrawingSession(t) {
    if (this.div.focus({
      preventScroll: !0
    }), this.#l) {
      this.#y.startDrawing(this, this.#c, !1, t);
      return;
    }
    this.#c.setCurrentDrawingSession(this), this.#l = new AbortController();
    const e = this.#c.combinedSignal(this.#l);
    this.div.addEventListener("blur", ({
      relatedTarget: s
    }) => {
      s && !this.div.contains(s) && (this.#u = null, this.commitOrRemove());
    }, {
      signal: e
    }), this.#y.startDrawing(this, this.#c, !1, t);
  }
  pause(t) {
    if (t) {
      const {
        activeElement: e
      } = document;
      this.div.contains(e) && (this.#u = e);
      return;
    }
    this.#u && setTimeout(() => {
      this.#u?.focus(), this.#u = null;
    }, 0);
  }
  endDrawingSession(t = !1) {
    return this.#l ? (this.#c.setCurrentDrawingSession(null), this.#l.abort(), this.#l = null, this.#u = null, this.#y.endDrawing(t)) : null;
  }
  findNewParent(t, e, s) {
    const i = this.#c.findParent(e, s);
    return i === null || i === this ? !1 : (i.changeParent(t), !0);
  }
  commitOrRemove() {
    return this.#l ? (this.endDrawingSession(), !0) : !1;
  }
  onScaleChanging() {
    this.#l && this.#y.onScaleChangingWhenDrawing(this);
  }
  destroy() {
    this.commitOrRemove(), this.#c.getActive()?.parent === this && (this.#c.commitOrRemove(), this.#c.setActiveEditor(null)), this.#a && (clearTimeout(this.#a), this.#a = null);
    for (const t of this.#n.values())
      this.#t?.removePointerInTextLayer(t.contentDiv), t.setParent(null), t.isAttachedToDOM = !1, t.div.remove();
    this.div = null, this.#n.clear(), this.#c.removeLayer(this);
  }
  #A() {
    for (const t of this.#n.values())
      t.isEmpty() && t.remove();
  }
  render({
    viewport: t
  }) {
    this.viewport = t, ae(this.div, t);
    for (const e of this.#c.getEditors(this.pageIndex))
      this.add(e), e.rebuild();
    this.updateMode();
  }
  update({
    viewport: t
  }) {
    this.#c.commitOrRemove(), this.#A();
    const e = this.viewport.rotation, s = t.rotation;
    if (this.viewport = t, ae(this.div, {
      rotation: s
    }), e !== s)
      for (const i of this.#n.values())
        i.rotate(s);
  }
  get pageDimensions() {
    const {
      pageWidth: t,
      pageHeight: e
    } = this.viewport.rawDims;
    return [t, e];
  }
  get scale() {
    return this.#c.viewParameters.realScale;
  }
}
class bt {
  #t = null;
  #e = /* @__PURE__ */ new Map();
  #i = /* @__PURE__ */ new Map();
  static #s = 0;
  constructor({
    pageIndex: t
  }) {
    this.pageIndex = t;
  }
  setParent(t) {
    if (!this.#t) {
      this.#t = t;
      return;
    }
    if (this.#t !== t) {
      if (this.#e.size > 0)
        for (const e of this.#e.values())
          e.remove(), t.append(e);
      this.#t = t;
    }
  }
  static get _svgFactory() {
    return K(this, "_svgFactory", new Ve());
  }
  static #a(t, [e, s, i, n]) {
    const {
      style: r
    } = t;
    r.top = `${100 * s}%`, r.left = `${100 * e}%`, r.width = `${100 * i}%`, r.height = `${100 * n}%`;
  }
  #n() {
    const t = bt._svgFactory.create(1, 1, !0);
    return this.#t.append(t), t.setAttribute("aria-hidden", !0), t;
  }
  #r(t, e) {
    const s = bt._svgFactory.createElement("clipPath");
    t.append(s);
    const i = `clip_${e}`;
    s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
    const n = bt._svgFactory.createElement("use");
    return s.append(n), n.setAttribute("href", `#${e}`), n.classList.add("clip"), i;
  }
  #o(t, e) {
    for (const [s, i] of Object.entries(e))
      i === null ? t.removeAttribute(s) : t.setAttribute(s, i);
  }
  draw(t, e = !1, s = !1) {
    const i = bt.#s++, n = this.#n(), r = bt._svgFactory.createElement("defs");
    n.append(r);
    const a = bt._svgFactory.createElement("path");
    r.append(a);
    const o = `path_p${this.pageIndex}_${i}`;
    a.setAttribute("id", o), a.setAttribute("vector-effect", "non-scaling-stroke"), e && this.#i.set(i, a);
    const l = s ? this.#r(r, o) : null, c = bt._svgFactory.createElement("use");
    return n.append(c), c.setAttribute("href", `#${o}`), this.updateProperties(n, t), this.#e.set(i, n), {
      id: i,
      clipPathId: `url(#${l})`
    };
  }
  drawOutline(t, e) {
    const s = bt.#s++, i = this.#n(), n = bt._svgFactory.createElement("defs");
    i.append(n);
    const r = bt._svgFactory.createElement("path");
    n.append(r);
    const a = `path_p${this.pageIndex}_${s}`;
    r.setAttribute("id", a), r.setAttribute("vector-effect", "non-scaling-stroke");
    let o;
    if (e) {
      const d = bt._svgFactory.createElement("mask");
      n.append(d), o = `mask_p${this.pageIndex}_${s}`, d.setAttribute("id", o), d.setAttribute("maskUnits", "objectBoundingBox");
      const u = bt._svgFactory.createElement("rect");
      d.append(u), u.setAttribute("width", "1"), u.setAttribute("height", "1"), u.setAttribute("fill", "white");
      const f = bt._svgFactory.createElement("use");
      d.append(f), f.setAttribute("href", `#${a}`), f.setAttribute("stroke", "none"), f.setAttribute("fill", "black"), f.setAttribute("fill-rule", "nonzero"), f.classList.add("mask");
    }
    const l = bt._svgFactory.createElement("use");
    i.append(l), l.setAttribute("href", `#${a}`), o && l.setAttribute("mask", `url(#${o})`);
    const c = l.cloneNode();
    return i.append(c), l.classList.add("mainOutline"), c.classList.add("secondaryOutline"), this.updateProperties(i, t), this.#e.set(s, i), s;
  }
  finalizeDraw(t, e) {
    this.#i.delete(t), this.updateProperties(t, e);
  }
  updateProperties(t, e) {
    if (!e)
      return;
    const {
      root: s,
      bbox: i,
      rootClass: n,
      path: r
    } = e, a = typeof t == "number" ? this.#e.get(t) : t;
    if (a) {
      if (s && this.#o(a, s), i && bt.#a(a, i), n) {
        const {
          classList: o
        } = a;
        for (const [l, c] of Object.entries(n))
          o.toggle(l, c);
      }
      if (r) {
        const l = a.firstChild.firstChild;
        this.#o(l, r);
      }
    }
  }
  updateParent(t, e) {
    if (e === this)
      return;
    const s = this.#e.get(t);
    s && (e.#t.append(s), this.#e.delete(t), e.#e.set(t, s));
  }
  remove(t) {
    this.#i.delete(t), this.#t !== null && (this.#e.get(t).remove(), this.#e.delete(t));
  }
  destroy() {
    this.#t = null;
    for (const t of this.#e.values())
      t.remove();
    this.#e.clear(), this.#i.clear();
  }
}
globalThis._pdfjsTestingUtils = {
  HighlightOutliner: Hs
};
globalThis.pdfjsLib = {
  AbortException: ie,
  AnnotationEditorLayer: Zt,
  AnnotationEditorParamsType: J,
  AnnotationEditorType: G,
  AnnotationEditorUIManager: ne,
  AnnotationLayer: As,
  AnnotationMode: se,
  AnnotationType: ft,
  applyOpacity: Ji,
  build: yn,
  ColorPicker: Ft,
  createValidAbsoluteUrl: zs,
  CSSConstants: Ki,
  DOMSVGFactory: Ve,
  DrawLayer: bt,
  FeatureTest: wt,
  fetchData: Me,
  findContrastColor: Qi,
  getDocument: ei,
  getFilenameFromUrl: Wi,
  getPdfFilenameFromUrl: Xi,
  getRGB: De,
  getUuid: Gs,
  getXfaPageViewport: Yi,
  GlobalWorkerOptions: $t,
  ImageKind: Vt,
  InvalidPDFException: ds,
  isDataScheme: Xe,
  isPdfFile: ys,
  isValidExplicitDest: en,
  MathClamp: Ct,
  noContextMenu: Bt,
  normalizeUnicode: Vi,
  OPS: It,
  OutputScale: Gt,
  PasswordResponses: ji,
  PDFDataRangeTransport: ii,
  PDFDateString: Pe,
  PDFWorker: Re,
  PermissionFlag: $i,
  PixelsPerInch: fe,
  RenderingCancelledException: vs,
  renderRichText: Ys,
  ResponseException: $e,
  setLayerDimensions: ae,
  shadow: K,
  SignatureExtractor: le,
  stopEvent: ct,
  SupportedImageMimeTypes: us,
  TextLayer: Tt,
  TouchManager: Ke,
  updateUrlHash: Vs,
  Util: B,
  VerbosityLevel: Ie,
  version: vn,
  XfaLayer: Xs
};
const fa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortException: ie,
  AnnotationEditorLayer: Zt,
  AnnotationEditorParamsType: J,
  AnnotationEditorType: G,
  AnnotationEditorUIManager: ne,
  AnnotationLayer: As,
  AnnotationMode: se,
  AnnotationType: ft,
  CSSConstants: Ki,
  ColorPicker: Ft,
  DOMSVGFactory: Ve,
  DrawLayer: bt,
  FeatureTest: wt,
  GlobalWorkerOptions: $t,
  ImageKind: Vt,
  InvalidPDFException: ds,
  MathClamp: Ct,
  OPS: It,
  OutputScale: Gt,
  PDFDataRangeTransport: ii,
  PDFDateString: Pe,
  PDFWorker: Re,
  PasswordResponses: ji,
  PermissionFlag: $i,
  PixelsPerInch: fe,
  RenderingCancelledException: vs,
  ResponseException: $e,
  SignatureExtractor: le,
  SupportedImageMimeTypes: us,
  TextLayer: Tt,
  TouchManager: Ke,
  Util: B,
  VerbosityLevel: Ie,
  XfaLayer: Xs,
  applyOpacity: Ji,
  build: yn,
  createValidAbsoluteUrl: zs,
  fetchData: Me,
  findContrastColor: Qi,
  getDocument: ei,
  getFilenameFromUrl: Wi,
  getPdfFilenameFromUrl: Xi,
  getRGB: De,
  getUuid: Gs,
  getXfaPageViewport: Yi,
  isDataScheme: Xe,
  isPdfFile: ys,
  isValidExplicitDest: en,
  noContextMenu: Bt,
  normalizeUnicode: Vi,
  renderRichText: Ys,
  setLayerDimensions: ae,
  shadow: K,
  stopEvent: ct,
  updateUrlHash: Vs,
  version: vn
}, Symbol.toStringTag, { value: "Module" }));
class mt {
  static tolerance = 2;
  static applyTransform(t, e) {
    const s = t[0] * e[0] + t[1] * e[2] + e[4], i = t[0] * e[1] + t[1] * e[3] + e[5];
    return [s, i];
  }
}
class Y extends mt {
  x;
  y;
  constructor(t, e) {
    super(), this.x = t, this.y = e;
  }
  equal(t) {
    return t.x === this.x && t.y === this.y;
  }
  transform(t) {
    const e = mt.applyTransform([this.x, this.y], t);
    return this.x = e[0], this.y = e[1], this;
  }
}
var jt = /* @__PURE__ */ ((h) => (h[h.None = 0] = "None", h[h.Horizontal = 1] = "Horizontal", h[h.Vertical = 2] = "Vertical", h))(jt || {});
class At extends mt {
  from;
  to;
  direction = 0;
  length = 0;
  intersections = [];
  gaps = [];
  constructor(t, e) {
    super(), this.from = t, this.to = e, this.init();
  }
  init() {
    let t = this.from, e = this.to;
    if (Math.abs(t.y - e.y) < mt.tolerance) {
      if (this.direction = 1, e.y = t.y, t.x > e.x) {
        const s = t;
        t = e, e = s;
      }
      this.length = e.x - t.x;
    } else if (Math.abs(t.x - e.x) < mt.tolerance) {
      if (this.direction = 2, e.x = t.x, t.y > e.y) {
        const s = t;
        t = e, e = s;
      }
      this.length = e.y - t.y;
    }
    this.from = t, this.to = e;
  }
  _valid = void 0;
  get valid() {
    return this._valid === void 0 && (this._valid = this.direction !== 0 && this.length > mt.tolerance), this._valid;
  }
  get normalized() {
    return this.direction === 1 ? new At(new Y(this.from.x - mt.tolerance, this.from.y), new Y(this.to.x + mt.tolerance, this.from.y)) : this.direction === 2 ? new At(new Y(this.from.x, this.from.y - mt.tolerance), new Y(this.from.x, this.to.y + mt.tolerance)) : this;
  }
  addGap(t) {
    this.gaps.push(t);
  }
  containsPoint(t) {
    return this.direction === 2 ? this.from.x === t.x && t.y >= this.from.y && t.y <= this.to.y : this.direction === 1 ? this.from.y === t.y && t.x >= this.from.x && t.x <= this.to.x : !1;
  }
  // // todo implement
  // public containsLine(l:Line):boolean{
  //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){
  //         return this.from.x === l.from.x
  //     }
  //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){
  //         return this.from.y === l.from.y
  //     }
  //     return false
  // }
  addIntersectionPoint(t) {
    for (const e of this.intersections)
      if (e.equal(t)) return;
    this.intersections.push(t);
  }
  intersection(t) {
    let e;
    if (!this.valid || !t.valid)
      return e;
    const s = this.normalized, i = t.normalized;
    if (this.direction === 1 && t.direction === 2) {
      const n = i.from.x, r = s.from.y;
      if (n > s.from.x && n < s.to.x && r > i.from.y && r < i.to.y) {
        const o = new Y(n, r);
        this.addIntersectionPoint(o), t.addIntersectionPoint(o), e = o;
      }
    } else if (this.direction === 2 && t.direction === 1) {
      const n = s.from.x, r = i.from.y;
      if (n > i.from.x && n < i.to.x && r > s.from.y && r < s.to.y) {
        const o = new Y(n, r);
        this.addIntersectionPoint(o), t.addIntersectionPoint(o), e = o;
      }
    }
    return e;
  }
  transform(t) {
    const e = this.from.transform(t), s = this.to.transform(t), i = Math.min(e.x, s.x), n = Math.min(e.y, s.y), r = Math.abs(e.x - s.x), a = Math.abs(e.y - s.y);
    return this.from = new Y(i, n), this.to = new Y(i + r, n + a), this.init(), this;
  }
}
class pa {
  minXY;
  maxXY;
  rows;
  rowPivots;
  colPivots;
  constructor(t, e, s, i) {
    this.minXY = t, this.maxXY = e, this.rows = [], this.rowPivots = s, this.colPivots = i;
  }
  findCell(t, e) {
    if (t >= this.minXY.x && e >= this.minXY.y && t <= this.maxXY.x && e <= this.maxXY.y) {
      for (const s of this.rows)
        for (const i of s)
          if (i.minXY.x <= t && i.minXY.y <= e && i.maxXY.x >= t && i.maxXY.y >= e)
            return i;
    }
  }
  get cellCount() {
    return this.rows.reduce((t, e) => t + e.length, 0);
  }
  get rowCount() {
    return this.rows.length;
  }
  check() {
    const t = (this.colPivots.length - 1) * (this.rowPivots.length - 1);
    let e = 0;
    for (const s of this.rows)
      for (const i of s) {
        const n = (i.colspan || 1) * (i.rowspan || 1);
        e += n;
      }
    return t === e;
  }
  toArray() {
    const t = [];
    for (const e of this.rows) {
      const s = [];
      for (const i of e) {
        let n = i.text.join("");
        n = n.replace(/^[\s]+|[\s]+$/g, ""), n = n.trim(), s.push(n);
      }
      t.push(s);
    }
    return t;
  }
}
class Hi {
  hLines = [];
  vLines = [];
  constructor(t) {
    t.direction === jt.Horizontal ? this.hLines.push(t) : t.direction === jt.Vertical && this.vLines.push(t);
  }
  get isValid() {
    return this.hLines.length + this.vLines.length > 4;
  }
  get rowPivots() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.hLines)
      t.add(e.from.y);
    return [...t].sort((e, s) => e - s);
  }
  get colPivots() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.vLines)
      t.add(e.from.x);
    return [...t].sort((e, s) => e - s);
  }
  add(t) {
    if (this.intersection(t)) {
      if (t.direction === jt.Horizontal)
        return this.hLines.push(t), !0;
      if (t.direction === jt.Vertical)
        return this.vLines.push(t), !0;
    }
    return !1;
  }
  intersection(t) {
    let e = !1;
    if (!t.valid) return e;
    if (t.direction === jt.Horizontal)
      for (const s of this.vLines)
        t.intersection(s) && (e = !0);
    else if (t.direction === jt.Vertical)
      for (const s of this.hLines)
        t.intersection(s) && (e = !0);
    return e;
  }
  getSameHorizontal(t) {
    const e = [t], s = [];
    for (; this.hLines.length > 0; ) {
      const i = this.hLines.shift();
      i && (i.from.y === t.from.y ? e.push(i) : s.push(i));
    }
    return this.hLines = s, e;
  }
  getSameVertical(t) {
    const e = [t], s = [];
    for (; this.vLines.length > 0; ) {
      const i = this.vLines.shift();
      i && (i.from.x === t.from.x ? e.push(i) : s.push(i));
    }
    return this.vLines = s, e;
  }
  mergeHorizontalLines(t) {
    t.sort((n, r) => n.from.x - r.from.x);
    const e = t[0].from.x, s = t[t.length - 1].to.x, i = new At(new Y(e, t[0].from.y), new Y(s, t[0].from.y));
    for (let n = 1; n < t.length; n++) {
      const r = t[n - 1], a = t[n];
      if (Math.abs(r.to.x - a.from.x) > mt.tolerance) {
        const o = new At(new Y(r.to.x, r.from.y), new Y(a.from.x, a.from.y));
        i.addGap(o);
      }
    }
    return i;
  }
  mergeVerticalLines(t) {
    t.sort((n, r) => n.from.y - r.from.y);
    const e = t[0].from.y, s = t[t.length - 1].to.y, i = new At(new Y(t[0].from.x, e), new Y(t[0].from.x, s));
    for (let n = 1; n < t.length; n++) {
      const r = t[n - 1], a = t[n];
      if (Math.abs(r.to.y - a.from.y) > mt.tolerance) {
        const o = new At(new Y(r.to.x, r.to.y), new Y(r.to.x, a.from.y));
        i.addGap(o);
      }
    }
    return i;
  }
  normalize() {
    this.hLines = this.hLines.filter((s) => s.intersections.length > 1), this.vLines = this.vLines.filter((s) => s.intersections.length > 1), this.hLines.sort((s, i) => s.from.y - i.from.y), this.vLines.sort((s, i) => s.from.x - i.from.x);
    const t = [];
    for (; this.hLines.length > 0; ) {
      const s = this.hLines.shift();
      if (!s) continue;
      const i = this.getSameHorizontal(s), n = this.mergeHorizontalLines(i);
      t.push(n);
    }
    this.hLines = t;
    const e = [];
    for (; this.vLines.length > 0; ) {
      const s = this.vLines.shift();
      if (!s) continue;
      const i = this.getSameVertical(s), n = this.mergeVerticalLines(i);
      e.push(n);
    }
    this.vLines = e;
  }
  verticalExists(t, e, s) {
    if (t.direction !== jt.Vertical)
      throw new Error("Line is not vertical");
    if (e >= s)
      throw new Error("y1 must be less than y2");
    if (t.from.y <= e && t.to.y >= s) {
      for (const i of t.gaps)
        if (i.from.y <= e && i.to.y >= s)
          return !1;
      return !0;
    }
    return !1;
  }
  horizontalExists(t, e, s) {
    if (t.direction !== jt.Horizontal)
      throw new Error("Line is not horizontal");
    if (e >= s)
      throw new Error("x1 must be less than x2");
    if (t.from.x <= e && t.to.x >= s) {
      for (const i of t.gaps)
        if (i.from.x <= e && i.to.x >= s)
          return !1;
      return !0;
    }
    return !1;
  }
  findBottomLineIndex(t, e) {
    for (let s = t; s < this.hLines.length; s++) {
      const i = this.hLines[s];
      if (i.from.x <= e && i.to.x >= e)
        return s;
    }
    return -1;
  }
  findVerticalLineIndexs(t, e) {
    const s = [];
    for (let i = 0; i < this.vLines.length; i++) {
      const n = this.vLines[i];
      n.from.y <= e && n.to.y >= e && t.intersection(n) && s.push(i);
    }
    return s;
  }
  getRow(t, e, s) {
    const i = [], n = this.hLines[t], r = this.findVerticalLineIndexs(n, s);
    for (let a = 1; a < r.length; a++) {
      const o = this.vLines[r[a - 1]], l = this.vLines[r[a]], c = (o.from.x + l.from.x) / 2, d = this.findBottomLineIndex(e, c), u = this.hLines[d], f = {
        minXY: new Y(o.from.x, n.from.y),
        maxXY: new Y(l.from.x, u.from.y),
        width: l.from.x - o.from.x,
        height: u.from.y - n.from.y,
        text: []
      }, g = r[a] - r[a - 1], p = d - t;
      g > 1 && (f.colspan = g), p > 1 && (f.rowspan = p), i.push(f);
    }
    return i;
  }
  toData() {
    const t = this.rowPivots, e = this.colPivots, s = new Y(e[0], t[0]), i = new Y(e[e.length - 1], t[t.length - 1]), n = new pa(s, i, t, e);
    for (let r = 1; r < this.hLines.length; r++) {
      const a = this.hLines[r - 1], o = this.hLines[r], l = (a.from.y + o.from.y) / 2, c = this.getRow(r - 1, r, l);
      n.rows.push(c);
    }
    return n;
  }
}
class ga {
  hLines = [];
  vLines = [];
  add(t) {
    t.valid && (t.direction === jt.Horizontal ? this.hLines.push(t) : t.direction === jt.Vertical && this.vLines.push(t));
  }
  addRectangle(t) {
    for (const e of t.getLines())
      this.add(e);
  }
  getTableData() {
    const t = [], e = this.getTables();
    for (const s of e) {
      const i = s.toData();
      i && t.push(i);
    }
    return t;
  }
  getTables() {
    const t = [];
    for (; this.hLines.length !== 0; ) {
      const s = this.hLines.shift();
      if (!s || this.tryFill(t, s)) continue;
      const n = new Hi(s);
      this.fillTable(n), t.push(n);
    }
    for (; this.vLines.length !== 0; ) {
      const s = this.vLines.shift();
      if (!s || this.tryFill(t, s)) continue;
      const n = new Hi(s);
      this.fillTable(n), t.push(n);
    }
    const e = t.filter((s) => s.isValid);
    for (const s of e)
      s.normalize();
    return e;
  }
  normalize() {
    this.normalizeHorizontal(), this.normalizeVertical();
  }
  normalizeHorizontal() {
    this.hLines.sort((s, i) => s.from.y - i.from.y);
    const t = [];
    let e = [];
    for (const s of this.hLines)
      if (e.length === 0)
        e.push(s);
      else if (Math.abs(e[0]?.from.y - s.from.y) < mt.tolerance)
        e.push(s);
      else {
        const i = this.margeHorizontalLines(e);
        t.push(...i), e = [s];
      }
    if (e.length > 0) {
      const s = this.margeHorizontalLines(e);
      t.push(...s);
    }
    this.hLines = t;
  }
  normalizeVertical() {
    this.vLines.sort((s, i) => s.from.x - i.from.x);
    const t = [];
    let e = [];
    for (const s of this.vLines)
      if (e.length === 0)
        e.push(s);
      else if (Math.abs(e[0]?.from.x - s.from.x) < mt.tolerance)
        e.push(s);
      else {
        const i = this.margeVerticalLines(e);
        t.push(...i), e = [s];
      }
    if (e.length > 0) {
      const s = this.margeVerticalLines(e);
      t.push(...s);
    }
    this.vLines = t;
  }
  fillTable(t) {
    const e = [], s = [];
    for (const i of this.vLines)
      t.add(i) || e.push(i);
    for (const i of this.hLines)
      t.add(i) || s.push(i);
    this.hLines = s, this.vLines = e;
  }
  tryFill(t, e) {
    for (const s of t)
      if (s.add(e))
        return this.fillTable(s), !0;
    return !1;
  }
  margeHorizontalLines(t) {
    const e = [];
    t.sort((a, o) => a.from.x - o.from.x);
    const s = t[0]?.from.y;
    if (s === void 0) return e;
    let i = Number.MAX_SAFE_INTEGER, n = Number.MIN_SAFE_INTEGER;
    for (const a of t)
      a.from.x - n < mt.tolerance ? (a.from.x < i && (i = a.from.x), a.to.x > n && (n = a.to.x)) : (n > i && e.push(new At(new Y(i, s), new Y(n, s))), i = a.from.x, n = a.to.x);
    const r = e[e.length - 1];
    return r ? r.from.x !== i && r.to.x !== n && e.push(new At(new Y(i, s), new Y(n, s))) : e.push(new At(new Y(i, s), new Y(n, s))), e;
  }
  margeVerticalLines(t) {
    const e = [];
    t.sort((a, o) => a.from.y - o.from.y);
    const s = t[0]?.from.x;
    if (s === void 0) return e;
    let i = Number.MAX_SAFE_INTEGER, n = Number.MIN_SAFE_INTEGER;
    for (const a of t)
      a.from.y - n < mt.tolerance ? (a.from.y < i && (i = a.from.y), a.to.y > n && (n = a.to.y)) : (n > i && e.push(new At(new Y(s, i), new Y(s, n))), i = a.from.y, n = a.to.y);
    const r = e[e.length - 1];
    return r ? r.from.y !== i && r.to.y !== n && e.push(new At(new Y(s, i), new Y(s, n))) : e.push(new At(new Y(s, i), new Y(s, n))), e;
  }
}
class ma extends mt {
  from;
  width;
  height;
  constructor(t, e, s) {
    super(), this.from = t, this.width = e, this.height = s;
  }
  get to() {
    return new Y(this.from.x + this.width, this.from.y + this.height);
  }
  getLines() {
    const t = this.to;
    return [
      new At(this.from, new Y(t.x, this.from.y)),
      new At(this.from, new Y(this.from.x, t.y)),
      new At(new Y(t.x, this.from.y), t),
      new At(new Y(this.from.x, t.y), t)
    ].filter((s) => s.valid);
  }
  transform(t) {
    const e = mt.applyTransform([this.from.x, this.from.y], t), s = mt.applyTransform([this.from.x + this.width, this.from.y + this.height], t), i = Math.min(e[0], s[0]), n = Math.min(e[1], s[1]), r = Math.abs(e[0] - s[0]), a = Math.abs(e[1] - s[1]);
    return this.from = new Y(i, n), this.width = r, this.height = a, this;
  }
}
async function va(h, t = !1) {
  try {
    const e = globalThis.fetch;
    if (typeof e == "function") {
      const s = await e(h, { method: "HEAD" }), i = {};
      s.headers.forEach((a, o) => {
        i[o] = a;
      });
      const n = s.headers.get("content-length") ? parseInt(s.headers.get("content-length"), 10) : void 0;
      let r;
      if (t) {
        const a = await e(h, { method: "GET", headers: { Range: "bytes=0-4" } });
        if (a.ok) {
          const o = new Uint8Array(await a.arrayBuffer());
          r = Array.from(o).map((c) => String.fromCharCode(c)).join("").startsWith("%PDF");
        } else
          r = !1;
      }
      return { ok: s.ok, status: s.status, size: n, isPdf: r, headers: i };
    }
    throw new Error("Fetch API not available");
  } catch (e) {
    return { ok: !1, status: void 0, size: void 0, isPdf: !1, headers: {}, error: new Error(String(e)) };
  }
}
class ya {
  pages = [];
  total = 0;
  getPageImage(t, e) {
    for (const s of this.pages)
      if (s.pageNumber === t) {
        for (const i of s.images)
          if (i.name === e)
            return i;
      }
    return null;
  }
  constructor(t) {
    this.total = t;
  }
}
const oe = ["xmp:createdate", "xmp:modifydate", "xmp:metadatadate", "xap:createdate", "xap:modifydate", "xap:metadatadate"];
class ba {
  // Total number of pages in the PDF document (count of physical pages).
  total;
  /**
   * The PDF 'Info' dictionary. Typical fields include title, author, subject,
   * Creator, Producer and Creation/Modification dates. The exact structure is
   * determined by the PDF and as returned by PDF.js.
   */
  // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>
  info;
  // Low-level document metadata object (XMP). Use this to access extended
  // properties that are not present in the Info dictionary.
  metadata;
  /**
   * An array of document fingerprint strings provided by PDF.js. Useful
   * for caching, de-duplication or identifying a document across runs.
   */
  fingerprints;
  /**
   * Permission flags for the document as returned by PDF.js (or null).
   * These flags indicate capabilities such as printing, copying and
   * other restrictions imposed by the PDF security settings.
   */
  permission;
  /**
   * Optional document outline (bookmarks). When present this is the
   * hierarchical navigation structure which viewers use for quick access.
   */
  outline;
  // Results with per-page hyperlink extraction. Empty array by default.
  pages = [];
  /**
   * Collects dates from different sources (Info dictionary and XMP/XAP metadata)
   * and returns them as a DateNode where available. This helps callers compare
   * and choose the most relevant timestamp (for example a creation date vs XMP date).
   */
  getDateNode() {
    const t = {}, e = this.info?.CreationDate;
    e && (t.CreationDate = Pe.toDateObject(e));
    const s = this.info?.ModDate;
    if (s && (t.ModDate = Pe.toDateObject(s)), !this.metadata)
      return t;
    for (const i of oe) {
      const n = this.metadata?.get(i), r = this.parseISODateString(n);
      switch (i) {
        case oe[0]:
          t.XmpCreateDate = r;
          break;
        case oe[1]:
          t.XmpModifyDate = r;
          break;
        case oe[2]:
          t.XmpMetadataDate = r;
          break;
        case oe[3]:
          t.XapCreateDate = r;
          break;
        case oe[4]:
          t.XapModifyDate = r;
          break;
        case oe[5]:
          t.XapMetadataDate = r;
          break;
      }
    }
    return t;
  }
  /**
   * Try to parse an ISO-8601 date string from XMP/XAP metadata. If the
   * value is falsy or cannot be parsed, undefined is returned to indicate
   * absence or unparsable input.
   */
  parseISODateString(t) {
    if (!t) return;
    const e = Date.parse(t);
    if (!Number.isNaN(e))
      return new Date(e);
  }
  constructor(t) {
    this.total = t;
  }
}
function Ls(h) {
  return h.lineThreshold = h?.lineThreshold ?? 4.6, h.cellThreshold = h?.cellThreshold ?? 7, h.cellSeparator = h?.cellSeparator ?? "	", h.lineEnforce = h?.lineEnforce ?? !0, h.pageJoiner = h?.pageJoiner ?? `
-- page_number of total_number --`, h.imageThreshold = h?.imageThreshold ?? 80, h.imageDataUrl = h?.imageDataUrl ?? !0, h.imageBuffer = h?.imageBuffer ?? !0, h.scale = h?.scale ?? 1, h;
}
var te = /* @__PURE__ */ ((h) => (h[h.undefined = 0] = "undefined", h[h.hline = 1] = "hline", h[h.vline = 2] = "vline", h[h.rectangle = 3] = "rectangle", h))(te || {});
class Aa {
  pages = [];
  total = 0;
  constructor(t) {
    this.total = t;
  }
}
class wa {
  pages = [];
  mergedTables = [];
  total = 0;
  constructor(t) {
    this.total = t;
  }
}
class Ea {
  pages = [];
  text = "";
  total = 0;
  getPageText(t) {
    for (const e of this.pages)
      if (e.num === t) return e.text;
    return "";
  }
  constructor(t) {
    this.total = t;
  }
}
class hi {
  options;
  doc;
  progress = { loaded: -1, total: 0 };
  /**
   * Create a new parser with `DocumentInitParameters`.
   * Converts Node.js `Buffer` data to `Uint8Array` automatically and ensures a default verbosity level.
   * @param options Initialization parameters.
   */
  constructor(t) {
    t.verbosity === void 0 && (t.verbosity = Ie.ERRORS), typeof Buffer < "u" && t.data instanceof Buffer && (t.data = new Uint8Array(t.data)), this.options = t;
  }
  async destroy() {
    this.doc && (await this.doc.destroy(), this.doc = void 0);
  }
  static get isNodeJS() {
    return typeof process == "object" && `${process}` == "[object process]" && !process.versions.nw && // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>
    !(process.versions.electron && typeof process.type < "u" && process.type !== "browser");
  }
  static setWorker(t) {
    return typeof globalThis.pdfjs > "u" && (globalThis.pdfjs = fa), $t === null ? "" : t !== void 0 ? ($t.workerSrc = t, $t.workerSrc) : (hi.isNodeJS || ($t.workerSrc = "https://cdn.jsdelivr.net/npm/pdf-parse@latest/dist/browser/pdf.worker.min.mjs"), $t.workerSrc);
  }
  /**
   * Perform an HTTP HEAD request to retrieve the file size and verify existence;
   * when `check` is true, fetch a small range and inspect the magic number to confirm the URL points to a valid PDF.
   * @param check When `true`, download a small byte range to validate the file signature.
   * Default: `false`.
   */
  async getHeader(t = !1) {
    if (!this.options.url)
      throw new Error("getHeader: options.url is not set");
    return await va(this.options.url, t);
  }
  /**
   * Load document-level metadata (info, outline, permissions, page labels) and optionally gather per-page link details.
   * @param params Parse options; set `parsePageInfo` to collect per-page metadata described in `ParseParameters`.
   * @returns Aggregated document metadata in an `InfoResult`.
   */
  async getInfo(t = {}) {
    const e = await this.load(), s = new ba(e.numPages), { info: i, metadata: n } = await e.getMetadata();
    s.info = i, s.metadata = n, s.fingerprints = e.fingerprints, s.outline = await e.getOutline(), s.permission = await e.getPermissions();
    const r = await e.getPageLabels();
    if (t.parsePageInfo) {
      for (let a = 1; a <= s.total; a++)
        if (this.shouldParse(a, s.total, t)) {
          const o = await e.getPage(a), l = await this.getPageLinks(o);
          l.pageLabel = r?.[o.pageNumber], s.pages.push(l), o.cleanup();
        }
    }
    return s;
  }
  async getPageLinks(t) {
    const e = t.getViewport({ scale: 1 }), s = {
      pageNumber: t.pageNumber,
      links: [],
      width: e.width,
      height: e.height
    }, i = await t.getAnnotations({ intent: "display" }) || [];
    for (const n of i) {
      if (n.subtype !== "Link") continue;
      const r = n.url ?? n.unsafeUrl;
      if (!r) continue;
      const a = n.overlaidText || "";
      s.links.push({ url: r, text: a });
    }
    return s;
  }
  /**
   * Extract plain text for each requested page, optionally enriching hyperlinks and enforcing line or cell separators.
   * @param params Parse options controlling pagination, link handling, and line/cell thresholds.
   * @returns A `TextResult` containing page-wise text and a concatenated document string.
   */
  async getText(t = {}) {
    const e = await this.load(), s = new Ea(e.numPages);
    for (let i = 1; i <= s.total; i++)
      if (this.shouldParse(i, s.total, t)) {
        const n = await e.getPage(i), r = await this.getPageText(n, t, s.total);
        s.pages.push({
          text: r,
          num: i
        }), n.cleanup();
      }
    for (const i of s.pages)
      s.text += `${i.text}

`;
    return s;
  }
  async load() {
    if (this.doc === void 0) {
      const t = ei(this.options);
      t.onProgress = (e) => {
        this.progress = e;
      }, this.doc = await t.promise;
    }
    return this.doc;
  }
  shouldParse(t, e, s) {
    return s.partial = s?.partial ?? [], s.first = s?.first ?? 0, s.last = s?.last ?? 0, s.partial.length > 0 ? !!s.partial.includes(t) : s.first > 0 && s.last > 0 ? t >= s.first && t <= s.last : s.first > 0 ? t <= s.first : s.last > 0 ? t > e - s.last : !0;
  }
  async getPageText(t, e, s) {
    const i = t.getViewport({ scale: 1 }), n = Ls(e), r = await t.getTextContent({
      includeMarkedContent: !!n.includeMarkedContent,
      disableNormalization: !!n.disableNormalization
    });
    let a = /* @__PURE__ */ new Map();
    n.parseHyperlinks && (a = await this.getHyperlinks(t, i));
    const o = [];
    let l, c;
    for (const d of r.items) {
      if (!("str" in d)) continue;
      const u = d.transform ?? d.transform, [f, g] = i.convertToViewportPoint(u[4], u[5]);
      if (n.parseHyperlinks) {
        const v = (a.get(d.str) || []).find((m) => f >= m.rect.left && f <= m.rect.right && g >= m.rect.top && g <= m.rect.bottom);
        v && (d.str = `[${d.str}](${v.url})`);
      }
      if (n.lineEnforce && c !== void 0 && Math.abs(c - g) > n.lineThreshold) {
        const p = o.length ? o[o.length - 1] : void 0, v = d.str.startsWith(`
`) || d.str.trim() === "" && d.hasEOL;
        p?.endsWith(`
`) === !1 && !v && o.push(`
`);
      }
      n.cellSeparator && c !== void 0 && Math.abs(c - g) < n.lineThreshold && l !== void 0 && Math.abs(l - f) > n.cellThreshold && (d.str = `${n.cellSeparator}${d.str}`), o.push(d.str), l = f + d.width, c = g, d.hasEOL && o.push(`
`);
    }
    if (n.pageJoiner) {
      let d = n.pageJoiner.replace("page_number", `${t.pageNumber}`);
      d = d.replace("total_number", `${s}`), o.push(d);
    }
    return n.itemJoiner ? o.join(n.itemJoiner) : o.join("");
  }
  async getHyperlinks(t, e) {
    const s = /* @__PURE__ */ new Map(), i = await t.getAnnotations({ intent: "display" }) || [];
    for (const n of i) {
      if (n.subtype !== "Link") continue;
      const r = n.url ?? n.unsafeUrl;
      if (!r) continue;
      const a = n.overlaidText;
      if (!a) continue;
      const o = e.convertToViewportRectangle(n.rect), l = Math.min(o[0], o[2]) - 0.5, c = Math.min(o[1], o[3]) - 0.5, d = Math.max(o[0], o[2]) + 0.5, u = Math.max(o[1], o[3]) + 0.5, f = { rect: { left: l, top: c, right: d, bottom: u }, url: r, text: a, used: !1 }, g = s.get(a);
      g ? g.push(f) : s.set(a, [f]);
    }
    return s;
  }
  /**
   * Extract embedded images from requested pages.
   *
   * Behavior notes:
   * - Pages are selected according to ParseParameters (partial, first, last).
   * - Images smaller than `params.imageThreshold` (width OR height) are skipped.
   * - Returned ImageResult contains per-page PageImages; each image entry includes:
   *     - data: Uint8Array (present when params.imageBuffer === true)
   *     - dataUrl: string (present when params.imageDataUrl === true)
   *     - width, height, kind, name
   * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
   *
   * @param params ParseParameters controlling page selection, thresholds and output format.
   * @returns Promise<ImageResult> with extracted images grouped by page.
   */
  async getImage(t = {}) {
    const e = await this.load(), s = new ya(e.numPages);
    Ls(t);
    for (let i = 1; i <= s.total; i++)
      if (this.shouldParse(i, s.total, t)) {
        const n = await e.getPage(i), r = await n.getOperatorList(), a = { pageNumber: i, images: [] };
        s.pages.push(a);
        for (let o = 0; o < r.fnArray.length; o++)
          if (r.fnArray[o] === It.paintInlineImageXObject || r.fnArray[o] === It.paintImageXObject) {
            const l = r.argsArray[o][0], d = n.commonObjs.has(l) ? this.resolveEmbeddedImage(n.commonObjs, l) : this.resolveEmbeddedImage(n.objs, l), { width: u, height: f, kind: g, data: p } = await d;
            if (t.imageThreshold && (t.imageThreshold >= u || t.imageThreshold >= f))
              continue;
            const m = e.canvasFactory.create(u, f), b = m.context;
            let y = null;
            g === Vt.RGBA_32BPP ? (y = b.createImageData(u, f), y.data.set(p)) : (y = b.createImageData(u, f), this.convertToRGBA({
              src: p,
              dest: new Uint32Array(y.data.buffer),
              width: u,
              height: f,
              kind: g
            })), b.putImageData(y, 0, 0);
            let E = new Uint8Array(), A = "";
            if (typeof m.canvas.toBuffer == "function") {
              let w;
              t.imageBuffer && (w = m.canvas.toBuffer("image/png"), E = new Uint8Array(w)), t.imageDataUrl && (w ? A = `data:image/png;base64,${w.toString("base64")}` : (w = m.canvas.toBuffer("image/png"), E = new Uint8Array(w), A = `data:image/png;base64,${w.toString("base64")}`));
            } else {
              if (t.imageBuffer) {
                const w = m.context.getImageData(0, 0, m.canvas.width, m.canvas.height);
                E = new Uint8Array(w.data);
              }
              t.imageDataUrl && (A = m.canvas.toDataURL("image/png"));
            }
            a.images.push({
              data: E,
              dataUrl: A,
              name: l,
              height: f,
              width: u,
              kind: g
            });
          }
      }
    return s;
  }
  convertToRGBA({ src: t, dest: e, width: s, height: i, kind: n }) {
    if (n === Vt.RGB_24BPP)
      for (let r = 0, a = 0; r < t.length; r += 3, a++) {
        const o = t[r], l = t[r + 1], c = t[r + 2];
        e[a] = 255 << 24 | c << 16 | l << 8 | o;
      }
    else if (n === Vt.GRAYSCALE_1BPP) {
      let r = 0;
      for (let a = 0; a < t.length; a++) {
        const o = t[a];
        for (let l = 7; l >= 0 && !(r >= s * i); l--) {
          const d = (o >> l & 1) === 1 ? 255 : 0;
          e[r++] = 255 << 24 | d << 16 | d << 8 | d;
        }
      }
    } else if (n == null) {
      const r = t.length / (s * i);
      if (Math.abs(r - 3) < 0.1)
        for (let a = 0, o = 0; a < t.length; a += 3, o++) {
          const l = t[a], c = t[a + 1], d = t[a + 2];
          e[o] = 255 << 24 | d << 16 | c << 8 | l;
        }
      else if (Math.abs(r - 4) < 0.1)
        for (let a = 0, o = 0; a < t.length; a += 4, o++) {
          const l = t[a], c = t[a + 1], d = t[a + 2], u = t[a + 3];
          e[o] = u << 24 | d << 16 | c << 8 | l;
        }
      else if (Math.abs(r - 1) < 0.1)
        for (let a = 0; a < t.length; a++) {
          const o = t[a];
          e[a] = 255 << 24 | o << 16 | o << 8 | o;
        }
      else
        throw new Error(`convertToRGBA: Cannot infer image format. kind: ${n}, bytesPerPixel: ${r}, width: ${s}, height: ${i}, dataLength: ${t.length}`);
    } else
      throw new Error(
        `convertToRGBA: Unsupported image kind: ${n}. Available kinds: GRAYSCALE_1BPP=${Vt.GRAYSCALE_1BPP}, RGB_24BPP=${Vt.RGB_24BPP}, RGBA_32BPP=${Vt.RGBA_32BPP}`
      );
  }
  resolveEmbeddedImage(t, e) {
    return new Promise((s, i) => {
      t.get(e, (n) => {
        if (n) {
          let r;
          if (n.data instanceof Uint8Array)
            r = n.data;
          else if (n.data instanceof Uint8ClampedArray)
            r = new Uint8Array(n.data);
          else if (n.data?.buffer)
            r = new Uint8Array(n.data.buffer);
          else if (n.bitmap) {
            const o = this.doc.canvasFactory.create(n.bitmap.width, n.bitmap.height);
            o.context.drawImage(n.bitmap, 0, 0);
            const l = o.context.getImageData(0, 0, n.bitmap.width, n.bitmap.height);
            r = new Uint8Array(l.data.buffer);
          } else ArrayBuffer.isView(n.data) && (r = new Uint8Array(n.data.buffer, n.data.byteOffset, n.data.byteLength));
          if (!r) {
            i(new Error(`Image object ${e}: data field is empty or invalid. Available fields: ${Object.keys(n).join(", ")}`));
            return;
          }
          if (r.length === 0) {
            i(new Error(`Image object ${e}: data buffer is empty (length: 0)`));
            return;
          }
          s({ width: n.width, height: n.height, kind: n.kind, data: r });
        } else
          i(new Error(`Image object ${e} not found`));
      });
    });
  }
  /**
   * Render pages to raster screenshots.
   *
   * Behavior notes:
   * - Pages are selected according to ParseParameters (partial, first, last).
   * - Use params.scale for zoom; if params.desiredWidth is specified it takes precedence.
   * - Each ScreenshotResult page contains:
   *     - data: Uint8Array (when params.imageBuffer === true)
   *     - dataUrl: string (when params.imageDataUrl === true)
   *     - pageNumber, width, height, scale
   * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
   *
   * @param parseParams ParseParameters controlling page selection and render options.
   * @returns Promise<ScreenshotResult> with rendered page images.
   */
  async getScreenshot(t = {}) {
    const e = Ls(t), s = await this.load(), i = new Aa(s.numPages);
    if (this.doc === void 0)
      throw new Error("PDF document not loaded");
    for (let n = 1; n <= i.total; n++)
      if (this.shouldParse(n, i.total, e)) {
        const r = await this.doc.getPage(n);
        let a = r.getViewport({ scale: e.scale });
        if (e.desiredWidth) {
          a = r.getViewport({ scale: 1 });
          const g = e.desiredWidth / a.width;
          a = r.getViewport({ scale: g });
        }
        const l = this.doc.canvasFactory.create(a.width, a.height), c = {
          canvasContext: l.context,
          viewport: a,
          canvas: l.canvas
        };
        await r.render(c).promise;
        let u = new Uint8Array(), f = "";
        if (typeof l.canvas.toBuffer == "function") {
          let g;
          e.imageBuffer && (g = l.canvas.toBuffer("image/png"), u = new Uint8Array(g)), e.imageDataUrl && (g ? f = `data:image/png;base64,${g.toString("base64")}` : (g = l.canvas.toBuffer("image/png"), u = new Uint8Array(g), f = `data:image/png;base64,${g.toString("base64")}`));
        } else {
          if (e.imageBuffer) {
            const g = l.context.getImageData(0, 0, l.canvas.width, l.canvas.height);
            u = new Uint8Array(g.data);
          }
          e.imageDataUrl && (f = l.canvas.toDataURL("image/png"));
        }
        i.pages.push({
          data: u,
          dataUrl: f,
          pageNumber: n,
          width: a.width,
          height: a.height,
          scale: a.scale
        }), r.cleanup();
      }
    return i;
  }
  /**
   * Detect and extract tables from pages by analysing vector drawing operators, then populate cells with text.
   *
   * Behavior notes:
   * - Scans operator lists for rectangles/lines that form table grids (uses PathGeometry and LineStore).
   * - Normalizes detected geometry and matches positioned text to table cells.
   * - Honors ParseParameters for page selection.
   *
   * @param params ParseParameters controlling which pages to analyse (partial/first/last).
   * @returns Promise<TableResult> containing discovered tables per page.
   */
  async getTable(t = {}) {
    const e = await this.load(), s = new wa(e.numPages);
    if (this.doc === void 0)
      throw new Error("PDF document not loaded");
    for (let i = 1; i <= s.total; i++)
      if (this.shouldParse(i, s.total, t)) {
        const n = await this.doc.getPage(i), r = await this.getPageTables(n);
        r.normalize();
        const a = r.getTableData();
        await this.fillPageTables(n, a);
        for (const o of a) {
          const l = { num: i, tables: o.toArray() };
          s.pages.push(l);
        }
        n.cleanup();
      }
    return s;
  }
  getPathGeometry(t) {
    const e = t[2] - t[0], s = t[3] - t[1];
    return t[0] === 1 / 0 ? te.undefined : e > 5 && s > 5 ? te.rectangle : e > 5 && s === 0 ? te.hline : e === 0 && s > 5 ? te.vline : te.undefined;
  }
  async getPageTables(t) {
    const e = new ga(), s = t.getViewport({ scale: 1 });
    let i = [1, 0, 0, 1, 0, 0];
    const n = [], r = await t.getOperatorList();
    for (let a = 0; a < r.fnArray.length; a++) {
      const o = r.fnArray[a], l = r.argsArray[a], c = l?.[0] ?? 0, d = l?.[2] ?? [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      if (o === It.constructPath) {
        if (It.fill, c !== It.stroke)
          continue;
        const u = this.getPathGeometry(d);
        if (u === te.rectangle) {
          const f = new ma(new Y(d[0], d[1]), d[2] - d[0], d[3] - d[1]);
          f.transform(i), f.transform(s.transform), e.addRectangle(f);
        } else if (u === te.hline || u === te.vline) {
          const f = new Y(d[0], d[1]), g = new Y(d[2], d[3]), p = new At(f, g);
          p.transform(i), p.transform(s.transform), e.add(p);
        }
      } else if (o !== It.setLineWidth) if (o === It.save)
        n.push(i);
      else if (o === It.restore) {
        const u = n.pop();
        u && (i = u);
      } else o === It.transform && (i = B.transform(i, l));
    }
    return e;
  }
  // private async getPageGeometry(page: PDFPageProxy): Promise<LineStore> {
  // 	const lineStore: LineStore = new LineStore();
  // 	const opList = await page.getOperatorList();
  // 	const viewport = page.getViewport({ scale: 1 });
  // 	let transformMatrix = [1, 0, 0, 1, 0, 0];
  // 	const transformStack: Array<Array<number>> = [];
  // 	let current_x: number = 0;
  // 	let current_y: number = 0;
  // 	for (let j = 0; j < opList.fnArray.length; j++) {
  // 		const fn = opList.fnArray[j];
  // 		const args = opList.argsArray[j];
  // 		if (fn === pdfjs.OPS.constructPath) {
  // 			while (args[0].length) {
  // 				const op = args[0].shift();
  // 				const combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);
  // 				if (op === pdfjs.OPS.rectangle) {
  // 					const x = args[1].shift();
  // 					const y = args[1].shift();
  // 					const width = args[1].shift();
  // 					const height = args[1].shift();
  // 					if (Math.min(width, height) <= 2) {
  // 						// TODO remove
  // 						debugger;
  // 					}
  // 					const rect = new Rectangle(new Point(x, y), width, height);
  // 					rect.transform(combinedMatrix);
  // 					//rect.transform(viewport.transform);
  // 					lineStore.addRectangle(rect);
  // 				} else if (op === pdfjs.OPS.moveTo) {
  // 					current_x = args[1].shift();
  // 					current_y = args[1].shift();
  // 				} else if (op === pdfjs.OPS.lineTo) {
  // 					const x = args[1].shift();
  // 					const y = args[1].shift();
  // 					//default trasform
  // 					const from = new Point(current_x, current_y);
  // 					const to = new Point(x, y);
  // 					const line = new Line(from, to);
  // 					line.transform(combinedMatrix);
  // 					//line.transform(viewport.transform);
  // 					// // viewport transform
  // 					// const _from = viewport.convertToViewportPoint(line.from.x, line.from.y)
  // 					// const _to = viewport.convertToViewportPoint(line.to.x, line.to.y)
  // 					//
  // 					// const transformedLine = new Line(new Point(_from[0], _from[1]), new Point(_to[0], _to[1]))
  // 					lineStore.add(line);
  // 					current_x = x;
  // 					current_y = y;
  // 				}
  // 			}
  // 		} else if (fn === pdfjs.OPS.save) {
  // 			transformStack.push(transformMatrix);
  // 		} else if (fn === pdfjs.OPS.restore) {
  // 			const restoredMatrix = transformStack.pop();
  // 			if (restoredMatrix) {
  // 				transformMatrix = restoredMatrix;
  // 			}
  // 		} else if (fn === pdfjs.OPS.transform) {
  // 			//transformMatrix = this.transform_fn(transformMatrix, args);
  // 			transformMatrix = pdfjs.Util.transform(transformMatrix, args);
  // 		}
  // 	}
  // 	return lineStore;
  // }
  async fillPageTables(t, e) {
    const s = t.getViewport({ scale: 1 }), i = await t.getTextContent({
      includeMarkedContent: !1,
      disableNormalization: !1
    });
    for (const n of i.items) {
      if (!("str" in n)) continue;
      const r = B.transform(B.transform(s.transform, n.transform), [1, 0, 0, -1, 0, 0]);
      for (const a of e) {
        const o = a.findCell(r[4], r[5]);
        if (o) {
          o.text.push(n.str), n.hasEOL && o.text.push(`
`);
          break;
        }
      }
    }
  }
}
hi.setWorker();
export {
  hi as PDFParse,
  Ie as VerbosityLevel,
  va as getHeader
};
